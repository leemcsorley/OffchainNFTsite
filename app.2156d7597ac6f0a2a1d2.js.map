{"version":3,"file":"app.2156d7597ac6f0a2a1d2.js","mappings":"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EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,IAAK,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,EAAG,EAAG,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,EAAG,IAAK,GAAI,EAAG,IAAK,GAAI,GAAI,IAAK,IAAK,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","sources":["webpack://CubeHeadsUI/./src/web3tree-abi.js","webpack://CubeHeadsUI/../../src/fable-library/Util.ts","webpack://CubeHeadsUI/../../src/fable-library/Types.ts","webpack://CubeHeadsUI/../../src/fable-library/Reflection.ts","webpack://CubeHeadsUI/../../src/fable-library/Option.ts","webpack://CubeHeadsUI/../../src/fable-library/lib/big.js","webpack://CubeHeadsUI/../../src/fable-library/Decimal.ts","webpack://CubeHeadsUI/../../src/fable-library/Int32.ts","webpack://CubeHeadsUI/../../src/fable-library/lib/long.js","webpack://CubeHeadsUI/../../src/fable-library/Long.ts","webpack://CubeHeadsUI/../../src/fable-library/Seq.ts","webpack://CubeHeadsUI/../../src/fable-library/Date.ts","webpack://CubeHeadsUI/../../src/fable-library/String.ts","webpack://CubeHeadsUI/./.fable/fable-library.2.13.0/MutableMap.js","webpack://CubeHeadsUI/./.fable/fable-library.2.13.0/Map.js","webpack://CubeHeadsUI/./.fable/fable-library.2.13.0/MutableSet.js","webpack://CubeHeadsUI/./.fable/fable-library.2.13.0/Set.js","webpack://CubeHeadsUI/./.fable/fable-library.2.13.0/Array.js","webpack://CubeHeadsUI/./.fable/fable-library.2.13.0/List.js","webpack://CubeHeadsUI/./.fable/fable-library.2.13.0/System.Text.js","webpack://CubeHeadsUI/../../src/fable-library/Double.ts","webpack://CubeHeadsUI/./.fable/Fable.Parsimmon.4.1.0/Parsimmon.js","webpack://CubeHeadsUI/.fable/Fable.Parsimmon.4.1.0/Parsimmon.fs","webpack://CubeHeadsUI/.fable/Fable.SimpleJson.3.24.0/Parser.fs","webpack://CubeHeadsUI/./.fable/fable-library.2.13.0/BigInt/n.js","webpack://CubeHeadsUI/./.fable/fable-library.2.13.0/BigInt/z.js","webpack://CubeHeadsUI/.fable/Fable.SimpleJson.3.24.0/Json.Converter.fs","webpack://CubeHeadsUI/./.fable/fable-library.2.13.0/BigInt.js","webpack://CubeHeadsUI/.fable/Fable.SimpleJson.3.24.0/TypeInfo.Converter.fs","webpack://CubeHeadsUI/./.fable/Fable.SimpleJson.3.24.0/isBrowser.js","webpack://CubeHeadsUI/../../src/fable-library/AsyncBuilder.ts","webpack://CubeHeadsUI/../../src/fable-library/Async.ts","webpack://CubeHeadsUI/.fable/Fable.SimpleHttp.3.3.0/Http.fs","webpack://CubeHeadsUI/src/Common.fs","webpack://CubeHeadsUI/.fable/Fable.Promise.3.1.3/Promise.fs","webpack://CubeHeadsUI/.fable/Fable.Elmish.React.3.0.1/react.fs","webpack://CubeHeadsUI/.fable/Fable.React.8.0.1/Fable.React.Helpers.fs","webpack://CubeHeadsUI/src/Utils.fs","webpack://CubeHeadsUI/src/ViewComponents.fs","webpack://CubeHeadsUI/.fable/Feliz.1.64.0/React.fs","webpack://CubeHeadsUI/./.fable/Feliz.1.64.0/ReactInterop.js","webpack://CubeHeadsUI/src/Home/View.fs","webpack://CubeHeadsUI/.fable/Fable.Elmish.3.1.0/prelude.fs","webpack://CubeHeadsUI/.fable/Fable.Elmish.Browser.3.0.5/parser.fs","webpack://CubeHeadsUI/.fable/Fable.Elmish.React.3.0.1/common.fs","webpack://CubeHeadsUI/.fable/Fable.Elmish.Browser.3.0.5/navigation.fs","webpack://CubeHeadsUI/src/Home/State.fs","webpack://CubeHeadsUI/.fable/Fable.Elmish.3.1.0/program.fs","webpack://CubeHeadsUI/src/App.fs"],"sourcesContent":["module.exports = [\r\n\t{\r\n\t\t\"inputs\": [\r\n\t\t\t{\r\n\t\t\t\t\"internalType\": \"address\",\r\n\t\t\t\t\"name\": \"tokenAddress\",\r\n\t\t\t\t\"type\": \"address\"\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t\"internalType\": \"uint256\",\r\n\t\t\t\t\"name\": \"tokenId\",\r\n\t\t\t\t\"type\": \"uint256\"\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t\"internalType\": \"string\",\r\n\t\t\t\t\"name\": \"text\",\r\n\t\t\t\t\"type\": \"string\"\r\n\t\t\t}\r\n\t\t],\r\n\t\t\"name\": \"addComment\",\r\n\t\t\"outputs\": [],\r\n\t\t\"stateMutability\": \"nonpayable\",\r\n\t\t\"type\": \"function\"\r\n\t},\r\n\t{\r\n\t\t\"inputs\": [\r\n\t\t\t{\r\n\t\t\t\t\"internalType\": \"address\",\r\n\t\t\t\t\"name\": \"tokenAddress\",\r\n\t\t\t\t\"type\": \"address\"\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t\"internalType\": \"uint256\",\r\n\t\t\t\t\"name\": \"tokenId\",\r\n\t\t\t\t\"type\": \"uint256\"\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t\"internalType\": \"string\",\r\n\t\t\t\t\"name\": \"text\",\r\n\t\t\t\t\"type\": \"string\"\r\n\t\t\t}\r\n\t\t],\r\n\t\t\"name\": \"addLike\",\r\n\t\t\"outputs\": [],\r\n\t\t\"stateMutability\": \"nonpayable\",\r\n\t\t\"type\": \"function\"\r\n\t},\r\n\t{\r\n\t\t\"inputs\": [],\r\n\t\t\"stateMutability\": \"nonpayable\",\r\n\t\t\"type\": \"constructor\"\r\n\t},\r\n\t{\r\n\t\t\"anonymous\": false,\r\n\t\t\"inputs\": [\r\n\t\t\t{\r\n\t\t\t\t\"indexed\": true,\r\n\t\t\t\t\"internalType\": \"address\",\r\n\t\t\t\t\"name\": \"user\",\r\n\t\t\t\t\"type\": \"address\"\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t\"indexed\": true,\r\n\t\t\t\t\"internalType\": \"address\",\r\n\t\t\t\t\"name\": \"tokenAddress\",\r\n\t\t\t\t\"type\": \"address\"\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t\"indexed\": true,\r\n\t\t\t\t\"internalType\": \"uint256\",\r\n\t\t\t\t\"name\": \"tokenId\",\r\n\t\t\t\t\"type\": \"uint256\"\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t\"indexed\": false,\r\n\t\t\t\t\"internalType\": \"string\",\r\n\t\t\t\t\"name\": \"text\",\r\n\t\t\t\t\"type\": \"string\"\r\n\t\t\t}\r\n\t\t],\r\n\t\t\"name\": \"Comment\",\r\n\t\t\"type\": \"event\"\r\n\t},\r\n\t{\r\n\t\t\"anonymous\": false,\r\n\t\t\"inputs\": [\r\n\t\t\t{\r\n\t\t\t\t\"indexed\": true,\r\n\t\t\t\t\"internalType\": \"address\",\r\n\t\t\t\t\"name\": \"user\",\r\n\t\t\t\t\"type\": \"address\"\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t\"indexed\": true,\r\n\t\t\t\t\"internalType\": \"address\",\r\n\t\t\t\t\"name\": \"tokenAddress\",\r\n\t\t\t\t\"type\": \"address\"\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t\"indexed\": true,\r\n\t\t\t\t\"internalType\": \"uint256\",\r\n\t\t\t\t\"name\": \"tokenId\",\r\n\t\t\t\t\"type\": \"uint256\"\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t\"indexed\": false,\r\n\t\t\t\t\"internalType\": \"string\",\r\n\t\t\t\t\"name\": \"text\",\r\n\t\t\t\t\"type\": \"string\"\r\n\t\t\t}\r\n\t\t],\r\n\t\t\"name\": \"Like\",\r\n\t\t\"type\": \"event\"\r\n\t},\r\n\t{\r\n\t\t\"anonymous\": false,\r\n\t\t\"inputs\": [\r\n\t\t\t{\r\n\t\t\t\t\"indexed\": true,\r\n\t\t\t\t\"internalType\": \"address\",\r\n\t\t\t\t\"name\": \"user\",\r\n\t\t\t\t\"type\": \"address\"\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t\"indexed\": false,\r\n\t\t\t\t\"internalType\": \"string\",\r\n\t\t\t\t\"name\": \"text\",\r\n\t\t\t\t\"type\": \"string\"\r\n\t\t\t}\r\n\t\t],\r\n\t\t\"name\": \"Profile\",\r\n\t\t\"type\": \"event\"\r\n\t},\r\n\t{\r\n\t\t\"inputs\": [\r\n\t\t\t{\r\n\t\t\t\t\"internalType\": \"string\",\r\n\t\t\t\t\"name\": \"text\",\r\n\t\t\t\t\"type\": \"string\"\r\n\t\t\t}\r\n\t\t],\r\n\t\t\"name\": \"updateProfile\",\r\n\t\t\"outputs\": [],\r\n\t\t\"stateMutability\": \"nonpayable\",\r\n\t\t\"type\": \"function\"\r\n\t}\r\n]",null,null,null,null,null,null,null,null,null,null,null,null,"import { declare, FSharpRef } from \"./Types.js\";\nimport { iterateIndexed, toIterator, getEnumerator, delay, collect, map, sumBy, iterate } from \"./Seq.js\";\nimport { class_type } from \"./Reflection.js\";\nimport { equals, getItemFromDict, tryGetValue } from \"./Util.js\";\nimport { format } from \"./String.js\";\nexport const MutableMap$00602 = declare(function Fable_Collections_MutableMap(pairs, comparer) {\n  const $this$$1 = this;\n  const this$ = new FSharpRef(null);\n  $this$$1.comparer = comparer;\n  this$.contents = $this$$1;\n  $this$$1.hashMap = new Map([]);\n  $this$$1[\"init@20-1\"] = 1;\n  iterate(function (pair) {\n    MutableMap$00602$$Add$$5BDDA1(this$.contents, pair[0], pair[1]);\n  }, pairs);\n  void null;\n});\nexport function MutableMap$00602$reflection($gen$$4, $gen$$5) {\n  return class_type(\"Fable.Collections.MutableMap`2\", [$gen$$4, $gen$$5], MutableMap$00602);\n}\nexport function MutableMap$00602$$$$002Ector$$6623D9B3(pairs, comparer) {\n  return this instanceof MutableMap$00602 ? MutableMap$00602.call(this, pairs, comparer) : new MutableMap$00602(pairs, comparer);\n}\n\nfunction MutableMap$00602$$TryFindIndex$$2B595(this$$$1, k) {\n  const h = this$$$1.comparer.GetHashCode(k) | 0;\n  const matchValue = tryGetValue(this$$$1.hashMap, h, null);\n\n  if (matchValue[0]) {\n    return [true, h, matchValue[1].findIndex(function (pair$$1) {\n      return this$$$1.comparer.Equals(k, pair$$1[0]);\n    })];\n  } else {\n    return [false, h, -1];\n  }\n}\n\nexport function MutableMap$00602$$TryFind$$2B595(this$$$2, k$$1) {\n  const matchValue$$1 = MutableMap$00602$$TryFindIndex$$2B595(this$$$2, k$$1);\n  var $target$$10;\n\n  if (matchValue$$1[0]) {\n    if (matchValue$$1[2] > -1) {\n      $target$$10 = 0;\n    } else {\n      $target$$10 = 1;\n    }\n  } else {\n    $target$$10 = 1;\n  }\n\n  switch ($target$$10) {\n    case 0:\n      {\n        return getItemFromDict(this$$$2.hashMap, matchValue$$1[1])[matchValue$$1[2]];\n      }\n\n    case 1:\n      {\n        return undefined;\n      }\n  }\n}\nexport function MutableMap$00602$$get_Comparer(this$$$3) {\n  return this$$$3.comparer;\n}\nexport function MutableMap$00602$$Clear(this$$$4) {\n  this$$$4.hashMap.clear();\n}\nexport function MutableMap$00602$$get_Count(this$$$5) {\n  const source = this$$$5.hashMap.values();\n  return sumBy(function projection(pairs$$2) {\n    return pairs$$2.length;\n  }, source, {\n    GetZero() {\n      return 0;\n    },\n\n    Add($x$$2, $y$$3) {\n      return $x$$2 + $y$$3;\n    }\n\n  }) | 0;\n}\nexport function MutableMap$00602$$get_Item$$2B595(this$$$6, k$$2) {\n  const matchValue$$2 = MutableMap$00602$$TryFind$$2B595(this$$$6, k$$2);\n\n  if (matchValue$$2 != null) {\n    const pair$$2 = matchValue$$2;\n    return pair$$2[1];\n  } else {\n    throw new Error(\"The item was not found in collection\");\n  }\n}\nexport function MutableMap$00602$$set_Item$$5BDDA1(this$$$7, k$$3, v) {\n  const matchValue$$3 = MutableMap$00602$$TryFindIndex$$2B595(this$$$7, k$$3);\n  var $target$$20;\n\n  if (matchValue$$3[0]) {\n    if (matchValue$$3[2] > -1) {\n      $target$$20 = 0;\n    } else {\n      $target$$20 = 1;\n    }\n  } else {\n    $target$$20 = 1;\n  }\n\n  switch ($target$$20) {\n    case 0:\n      {\n        getItemFromDict(this$$$7.hashMap, matchValue$$3[1])[matchValue$$3[2]] = [k$$3, v];\n        break;\n      }\n\n    case 1:\n      {\n        if (matchValue$$3[0]) {\n          const value = void getItemFromDict(this$$$7.hashMap, matchValue$$3[1]).push([k$$3, v]);\n          void null;\n        } else {\n          this$$$7.hashMap.set(matchValue$$3[1], [[k$$3, v]]);\n        }\n\n        break;\n      }\n  }\n}\nexport function MutableMap$00602$$Add$$5BDDA1(this$$$8, k$$4, v$$1) {\n  const matchValue$$4 = MutableMap$00602$$TryFindIndex$$2B595(this$$$8, k$$4);\n  var $target$$24;\n\n  if (matchValue$$4[0]) {\n    if (matchValue$$4[2] > -1) {\n      $target$$24 = 0;\n    } else {\n      $target$$24 = 1;\n    }\n  } else {\n    $target$$24 = 1;\n  }\n\n  switch ($target$$24) {\n    case 0:\n      {\n        const msg = format(\"An item with the same key has already been added. Key: {0}\", k$$4);\n        throw new Error(msg);\n        break;\n      }\n\n    case 1:\n      {\n        if (matchValue$$4[0]) {\n          const value$$1 = void getItemFromDict(this$$$8.hashMap, matchValue$$4[1]).push([k$$4, v$$1]);\n          void null;\n        } else {\n          this$$$8.hashMap.set(matchValue$$4[1], [[k$$4, v$$1]]);\n        }\n\n        break;\n      }\n  }\n}\nexport function MutableMap$00602$$ContainsKey$$2B595(this$$$9, k$$5) {\n  const matchValue$$5 = MutableMap$00602$$TryFindIndex$$2B595(this$$$9, k$$5);\n  var $target$$27;\n\n  if (matchValue$$5[0]) {\n    if (matchValue$$5[2] > -1) {\n      $target$$27 = 0;\n    } else {\n      $target$$27 = 1;\n    }\n  } else {\n    $target$$27 = 1;\n  }\n\n  switch ($target$$27) {\n    case 0:\n      {\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\nexport function MutableMap$00602$$Remove$$2B595(this$$$10, k$$6) {\n  const matchValue$$6 = MutableMap$00602$$TryFindIndex$$2B595(this$$$10, k$$6);\n  var $target$$30;\n\n  if (matchValue$$6[0]) {\n    if (matchValue$$6[2] > -1) {\n      $target$$30 = 0;\n    } else {\n      $target$$30 = 1;\n    }\n  } else {\n    $target$$30 = 1;\n  }\n\n  switch ($target$$30) {\n    case 0:\n      {\n        getItemFromDict(this$$$10.hashMap, matchValue$$6[1]).splice(matchValue$$6[2], 1);\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\n\nMutableMap$00602.prototype[Symbol.iterator] = function () {\n  var elems;\n  const this$$$11 = this;\n  return toIterator((elems = delay(function () {\n    return collect(function (pairs$$3) {\n      return map(function (pair$$3) {\n        return pair$$3;\n      }, pairs$$3);\n    }, this$$$11.hashMap.values());\n  }), getEnumerator(elems)));\n};\n\nMutableMap$00602.prototype.Add = function (item) {\n  const this$$$12 = this;\n  MutableMap$00602$$Add$$5BDDA1(this$$$12, item[0], item[1]);\n};\n\nMutableMap$00602.prototype.Clear = function () {\n  const this$$$13 = this;\n  MutableMap$00602$$Clear(this$$$13);\n};\n\nMutableMap$00602.prototype.Contains = function (item$$1) {\n  var p;\n  const this$$$14 = this;\n  const matchValue$$7 = MutableMap$00602$$TryFind$$2B595(this$$$14, item$$1[0]);\n  var $target$$31;\n\n  if (matchValue$$7 != null) {\n    if (p = matchValue$$7, equals(p[1], item$$1[1])) {\n      $target$$31 = 0;\n    } else {\n      $target$$31 = 1;\n    }\n  } else {\n    $target$$31 = 1;\n  }\n\n  switch ($target$$31) {\n    case 0:\n      {\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n};\n\nMutableMap$00602.prototype.CopyTo = function (array, arrayIndex) {\n  const this$$$15 = this;\n  iterateIndexed(function action(i$$10, e) {\n    array[arrayIndex + i$$10] = e;\n  }, this$$$15);\n};\n\nObject.defineProperty(MutableMap$00602.prototype, \"Count\", {\n  \"get\": function () {\n    const this$$$16 = this;\n    return MutableMap$00602$$get_Count(this$$$16) | 0;\n  }\n});\nObject.defineProperty(MutableMap$00602.prototype, \"IsReadOnly\", {\n  \"get\": function () {\n    return false;\n  }\n});\n\nMutableMap$00602.prototype.Remove = function (item$$2) {\n  const this$$$18 = this;\n  const matchValue$$8 = MutableMap$00602$$TryFind$$2B595(this$$$18, item$$2[0]);\n\n  if (matchValue$$8 != null) {\n    const pair$$4 = matchValue$$8;\n\n    if (equals(pair$$4[1], item$$2[1])) {\n      const value$$2 = MutableMap$00602$$Remove$$2B595(this$$$18, item$$2[0]);\n      void value$$2;\n    } else {\n      void null;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n};\n\nObject.defineProperty(MutableMap$00602.prototype, \"size\", {\n  \"get\": function () {\n    const this$$$19 = this;\n    return MutableMap$00602$$get_Count(this$$$19) | 0;\n  }\n});\n\nMutableMap$00602.prototype.clear = function () {\n  const this$$$20 = this;\n  MutableMap$00602$$Clear(this$$$20);\n};\n\nMutableMap$00602.prototype.delete = function (k$$7) {\n  const this$$$21 = this;\n  return MutableMap$00602$$Remove$$2B595(this$$$21, k$$7);\n};\n\nMutableMap$00602.prototype.entries = function () {\n  const this$$$22 = this;\n  return map(function mapping(x) {\n    return x;\n  }, this$$$22);\n};\n\nMutableMap$00602.prototype.get = function (k$$8) {\n  const this$$$23 = this;\n  return MutableMap$00602$$get_Item$$2B595(this$$$23, k$$8);\n};\n\nMutableMap$00602.prototype.has = function (k$$9) {\n  const this$$$24 = this;\n  return MutableMap$00602$$ContainsKey$$2B595(this$$$24, k$$9);\n};\n\nMutableMap$00602.prototype.keys = function () {\n  const this$$$25 = this;\n  return map(function mapping$$1(pair$$5) {\n    return pair$$5[0];\n  }, this$$$25);\n};\n\nMutableMap$00602.prototype.set = function (k$$10, v$$2) {\n  const this$$$26 = this;\n  MutableMap$00602$$set_Item$$5BDDA1(this$$$26, k$$10, v$$2);\n  return this$$$26;\n};\n\nMutableMap$00602.prototype.values = function () {\n  const this$$$27 = this;\n  return map(function mapping$$2(pair$$6) {\n    return pair$$6[1];\n  }, this$$$27);\n};","import { Record, List, declare, Union } from \"./Types.js\";\nimport { class_type, record_type, bool_type, list_type, union_type, int32_type } from \"./Reflection.js\";\nimport { value as value$$3, some } from \"./Option.js\";\nimport { iterate as iterate$$1, empty as empty$$1, toIterator, map as map$$2, unfold, getEnumerator, fold as fold$$1 } from \"./Seq.js\";\nimport { compare, structuralHash, isDisposable } from \"./Util.js\";\nimport { join, format } from \"./String.js\";\nimport { MutableMap$00602$$$$002Ector$$6623D9B3 as MutableMap$002400602$0024$0024$0024$0024002Ector$0024$00246623D9B3 } from \"./MutableMap\";\nexport const MapTree$00602 = declare(function Map_MapTree(tag, name, ...fields) {\n  this.tag = tag | 0;\n  this.name = name;\n  this.fields = fields;\n}, Union);\nexport function MapTree$00602$reflection($gen$$3, $gen$$4) {\n  return union_type(\"Map.MapTree`2\", [$gen$$3, $gen$$4], MapTree$00602, () => [\"MapEmpty\", [\"MapOne\", [[\"Item1\", $gen$$3], [\"Item2\", $gen$$4]]], [\"MapNode\", [[\"Item1\", $gen$$3], [\"Item2\", $gen$$4], [\"Item3\", MapTree$00602$reflection($gen$$3, $gen$$4)], [\"Item4\", MapTree$00602$reflection($gen$$3, $gen$$4)], [\"Item5\", int32_type]]]]);\n}\nexport function MapTreeModule$$$sizeAux($acc$$5, $m$$6) {\n  MapTreeModule$$$sizeAux: while (true) {\n    const acc = $acc$$5,\n          m = $m$$6;\n\n    switch (m.tag) {\n      case 1:\n        {\n          return acc + 1 | 0;\n        }\n\n      case 2:\n        {\n          $acc$$5 = MapTreeModule$$$sizeAux(acc + 1, m.fields[2]);\n          $m$$6 = m.fields[3];\n          continue MapTreeModule$$$sizeAux;\n        }\n\n      default:\n        {\n          return acc | 0;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$size(x) {\n  return MapTreeModule$$$sizeAux(0, x);\n}\nexport function MapTreeModule$$$empty() {\n  return new MapTree$00602(0, \"MapEmpty\");\n}\nexport function MapTreeModule$$$height(_arg1) {\n  switch (_arg1.tag) {\n    case 1:\n      {\n        return 1;\n      }\n\n    case 2:\n      {\n        return _arg1.fields[4] | 0;\n      }\n\n    default:\n      {\n        return 0;\n      }\n  }\n}\nexport function MapTreeModule$$$isEmpty(m$$1) {\n  if (m$$1.tag === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function MapTreeModule$$$mk(l$$1, k, v, r$$1) {\n  var $target$$14;\n\n  if (l$$1.tag === 0) {\n    if (r$$1.tag === 0) {\n      $target$$14 = 0;\n    } else {\n      $target$$14 = 1;\n    }\n  } else {\n    $target$$14 = 1;\n  }\n\n  switch ($target$$14) {\n    case 0:\n      {\n        return new MapTree$00602(1, \"MapOne\", k, v);\n      }\n\n    case 1:\n      {\n        const hl = MapTreeModule$$$height(l$$1) | 0;\n        const hr = MapTreeModule$$$height(r$$1) | 0;\n        const m$$2 = (hl < hr ? hr : hl) | 0;\n        return new MapTree$00602(2, \"MapNode\", k, v, l$$1, r$$1, m$$2 + 1);\n      }\n  }\n}\nexport function MapTreeModule$$$rebalance(t1, k$$1, v$$1, t2) {\n  const t1h = MapTreeModule$$$height(t1) | 0;\n  const t2h = MapTreeModule$$$height(t2) | 0;\n\n  if (t2h > t1h + 2) {\n    if (t2.tag === 2) {\n      if (MapTreeModule$$$height(t2.fields[2]) > t1h + 1) {\n        if (t2.fields[2].tag === 2) {\n          return MapTreeModule$$$mk(MapTreeModule$$$mk(t1, k$$1, v$$1, t2.fields[2].fields[2]), t2.fields[2].fields[0], t2.fields[2].fields[1], MapTreeModule$$$mk(t2.fields[2].fields[3], t2.fields[0], t2.fields[1], t2.fields[3]));\n        } else {\n          throw new Error(\"rebalance\");\n        }\n      } else {\n        return MapTreeModule$$$mk(MapTreeModule$$$mk(t1, k$$1, v$$1, t2.fields[2]), t2.fields[0], t2.fields[1], t2.fields[3]);\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else if (t1h > t2h + 2) {\n    if (t1.tag === 2) {\n      if (MapTreeModule$$$height(t1.fields[3]) > t2h + 1) {\n        if (t1.fields[3].tag === 2) {\n          return MapTreeModule$$$mk(MapTreeModule$$$mk(t1.fields[2], t1.fields[0], t1.fields[1], t1.fields[3].fields[2]), t1.fields[3].fields[0], t1.fields[3].fields[1], MapTreeModule$$$mk(t1.fields[3].fields[3], k$$1, v$$1, t2));\n        } else {\n          throw new Error(\"re  balance\");\n        }\n      } else {\n        return MapTreeModule$$$mk(t1.fields[2], t1.fields[0], t1.fields[1], MapTreeModule$$$mk(t1.fields[3], k$$1, v$$1, t2));\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else {\n    return MapTreeModule$$$mk(t1, k$$1, v$$1, t2);\n  }\n}\nexport function MapTreeModule$$$add(comparer, k$$2, v$$2, m$$3) {\n  switch (m$$3.tag) {\n    case 1:\n      {\n        const c = comparer.Compare(k$$2, m$$3.fields[0]) | 0;\n\n        if (c < 0) {\n          return new MapTree$00602(2, \"MapNode\", k$$2, v$$2, new MapTree$00602(0, \"MapEmpty\"), m$$3, 2);\n        } else if (c === 0) {\n          return new MapTree$00602(1, \"MapOne\", k$$2, v$$2);\n        } else {\n          return new MapTree$00602(2, \"MapNode\", k$$2, v$$2, m$$3, new MapTree$00602(0, \"MapEmpty\"), 2);\n        }\n      }\n\n    case 2:\n      {\n        const c$$1 = comparer.Compare(k$$2, m$$3.fields[0]) | 0;\n\n        if (c$$1 < 0) {\n          return MapTreeModule$$$rebalance(MapTreeModule$$$add(comparer, k$$2, v$$2, m$$3.fields[2]), m$$3.fields[0], m$$3.fields[1], m$$3.fields[3]);\n        } else if (c$$1 === 0) {\n          return new MapTree$00602(2, \"MapNode\", k$$2, v$$2, m$$3.fields[2], m$$3.fields[3], m$$3.fields[4]);\n        } else {\n          return MapTreeModule$$$rebalance(m$$3.fields[2], m$$3.fields[0], m$$3.fields[1], MapTreeModule$$$add(comparer, k$$2, v$$2, m$$3.fields[3]));\n        }\n      }\n\n    default:\n      {\n        return new MapTree$00602(1, \"MapOne\", k$$2, v$$2);\n      }\n  }\n}\nexport function MapTreeModule$$$find($comparer$$1$$23, $k$$3$$24, $m$$4$$25) {\n  MapTreeModule$$$find: while (true) {\n    const comparer$$1 = $comparer$$1$$23,\n          k$$3 = $k$$3$$24,\n          m$$4 = $m$$4$$25;\n\n    switch (m$$4.tag) {\n      case 1:\n        {\n          const c$$2 = comparer$$1.Compare(k$$3, m$$4.fields[0]) | 0;\n\n          if (c$$2 === 0) {\n            return m$$4.fields[1];\n          } else {\n            throw new Error(\"key not found\");\n          }\n        }\n\n      case 2:\n        {\n          const c$$3 = comparer$$1.Compare(k$$3, m$$4.fields[0]) | 0;\n\n          if (c$$3 < 0) {\n            $comparer$$1$$23 = comparer$$1;\n            $k$$3$$24 = k$$3;\n            $m$$4$$25 = m$$4.fields[2];\n            continue MapTreeModule$$$find;\n          } else if (c$$3 === 0) {\n            return m$$4.fields[1];\n          } else {\n            $comparer$$1$$23 = comparer$$1;\n            $k$$3$$24 = k$$3;\n            $m$$4$$25 = m$$4.fields[3];\n            continue MapTreeModule$$$find;\n          }\n        }\n\n      default:\n        {\n          throw new Error(\"key not found\");\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$tryFind($comparer$$2$$26, $k$$4$$27, $m$$5$$28) {\n  MapTreeModule$$$tryFind: while (true) {\n    const comparer$$2 = $comparer$$2$$26,\n          k$$4 = $k$$4$$27,\n          m$$5 = $m$$5$$28;\n\n    switch (m$$5.tag) {\n      case 1:\n        {\n          const c$$4 = comparer$$2.Compare(k$$4, m$$5.fields[0]) | 0;\n\n          if (c$$4 === 0) {\n            return some(m$$5.fields[1]);\n          } else {\n            return undefined;\n          }\n        }\n\n      case 2:\n        {\n          const c$$5 = comparer$$2.Compare(k$$4, m$$5.fields[0]) | 0;\n\n          if (c$$5 < 0) {\n            $comparer$$2$$26 = comparer$$2;\n            $k$$4$$27 = k$$4;\n            $m$$5$$28 = m$$5.fields[2];\n            continue MapTreeModule$$$tryFind;\n          } else if (c$$5 === 0) {\n            return some(m$$5.fields[1]);\n          } else {\n            $comparer$$2$$26 = comparer$$2;\n            $k$$4$$27 = k$$4;\n            $m$$5$$28 = m$$5.fields[3];\n            continue MapTreeModule$$$tryFind;\n          }\n        }\n\n      default:\n        {\n          return undefined;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$partition1(comparer$$3, f, k$$5, v$$3, acc1, acc2) {\n  if (f(k$$5, v$$3)) {\n    return [MapTreeModule$$$add(comparer$$3, k$$5, v$$3, acc1), acc2];\n  } else {\n    return [acc1, MapTreeModule$$$add(comparer$$3, k$$5, v$$3, acc2)];\n  }\n}\nexport function MapTreeModule$$$partitionAux($comparer$$4$$35, $f$$1$$36, $s$$37, $acc_0$$38, $acc_1$$39) {\n  MapTreeModule$$$partitionAux: while (true) {\n    const comparer$$4 = $comparer$$4$$35,\n          f$$1 = $f$$1$$36,\n          s = $s$$37,\n          acc_0 = $acc_0$$38,\n          acc_1 = $acc_1$$39;\n\n    switch (s.tag) {\n      case 1:\n        {\n          return MapTreeModule$$$partition1(comparer$$4, f$$1, s.fields[0], s.fields[1], acc_0, acc_1);\n        }\n\n      case 2:\n        {\n          const acc$$2 = MapTreeModule$$$partitionAux(comparer$$4, f$$1, s.fields[3], acc_0, acc_1);\n          const acc$$3 = MapTreeModule$$$partition1(comparer$$4, f$$1, s.fields[0], s.fields[1], acc$$2[0], acc$$2[1]);\n          $comparer$$4$$35 = comparer$$4;\n          $f$$1$$36 = f$$1;\n          $s$$37 = s.fields[2];\n          $acc_0$$38 = acc$$3[0];\n          $acc_1$$39 = acc$$3[1];\n          continue MapTreeModule$$$partitionAux;\n        }\n\n      default:\n        {\n          return [acc_0, acc_1];\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$partition(comparer$$5, f$$2, s$$1) {\n  return MapTreeModule$$$partitionAux(comparer$$5, f$$2, s$$1, MapTreeModule$$$empty(), MapTreeModule$$$empty());\n}\nexport function MapTreeModule$$$filter1(comparer$$6, f$$3, k$$8, v$$6, acc$$4) {\n  if (f$$3(k$$8, v$$6)) {\n    return MapTreeModule$$$add(comparer$$6, k$$8, v$$6, acc$$4);\n  } else {\n    return acc$$4;\n  }\n}\nexport function MapTreeModule$$$filterAux($comparer$$7$$48, $f$$4$$49, $s$$2$$50, $acc$$5$$51) {\n  MapTreeModule$$$filterAux: while (true) {\n    const comparer$$7 = $comparer$$7$$48,\n          f$$4 = $f$$4$$49,\n          s$$2 = $s$$2$$50,\n          acc$$5 = $acc$$5$$51;\n\n    switch (s$$2.tag) {\n      case 1:\n        {\n          return MapTreeModule$$$filter1(comparer$$7, f$$4, s$$2.fields[0], s$$2.fields[1], acc$$5);\n        }\n\n      case 2:\n        {\n          const acc$$6 = MapTreeModule$$$filterAux(comparer$$7, f$$4, s$$2.fields[2], acc$$5);\n          const acc$$7 = MapTreeModule$$$filter1(comparer$$7, f$$4, s$$2.fields[0], s$$2.fields[1], acc$$6);\n          $comparer$$7$$48 = comparer$$7;\n          $f$$4$$49 = f$$4;\n          $s$$2$$50 = s$$2.fields[3];\n          $acc$$5$$51 = acc$$7;\n          continue MapTreeModule$$$filterAux;\n        }\n\n      default:\n        {\n          return acc$$5;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$filter(comparer$$8, f$$5, s$$3) {\n  return MapTreeModule$$$filterAux(comparer$$8, f$$5, s$$3, MapTreeModule$$$empty());\n}\nexport function MapTreeModule$$$spliceOutSuccessor(m$$6) {\n  switch (m$$6.tag) {\n    case 1:\n      {\n        return [m$$6.fields[0], m$$6.fields[1], new MapTree$00602(0, \"MapEmpty\")];\n      }\n\n    case 2:\n      {\n        if (m$$6.fields[2].tag === 0) {\n          return [m$$6.fields[0], m$$6.fields[1], m$$6.fields[3]];\n        } else {\n          const patternInput = MapTreeModule$$$spliceOutSuccessor(m$$6.fields[2]);\n          return [patternInput[0], patternInput[1], MapTreeModule$$$mk(patternInput[2], m$$6.fields[0], m$$6.fields[1], m$$6.fields[3])];\n        }\n      }\n\n    default:\n      {\n        throw new Error(\"internal error: Map.spliceOutSuccessor\");\n      }\n  }\n}\nexport function MapTreeModule$$$remove(comparer$$9, k$$11, m$$7) {\n  switch (m$$7.tag) {\n    case 1:\n      {\n        const c$$6 = comparer$$9.Compare(k$$11, m$$7.fields[0]) | 0;\n\n        if (c$$6 === 0) {\n          return new MapTree$00602(0, \"MapEmpty\");\n        } else {\n          return m$$7;\n        }\n      }\n\n    case 2:\n      {\n        const c$$7 = comparer$$9.Compare(k$$11, m$$7.fields[0]) | 0;\n\n        if (c$$7 < 0) {\n          return MapTreeModule$$$rebalance(MapTreeModule$$$remove(comparer$$9, k$$11, m$$7.fields[2]), m$$7.fields[0], m$$7.fields[1], m$$7.fields[3]);\n        } else if (c$$7 === 0) {\n          if (m$$7.fields[2].tag === 0) {\n            return m$$7.fields[3];\n          } else if (m$$7.fields[3].tag === 0) {\n            return m$$7.fields[2];\n          } else {\n            const patternInput$$1 = MapTreeModule$$$spliceOutSuccessor(m$$7.fields[3]);\n            return MapTreeModule$$$mk(m$$7.fields[2], patternInput$$1[0], patternInput$$1[1], patternInput$$1[2]);\n          }\n        } else {\n          return MapTreeModule$$$rebalance(m$$7.fields[2], m$$7.fields[0], m$$7.fields[1], MapTreeModule$$$remove(comparer$$9, k$$11, m$$7.fields[3]));\n        }\n      }\n\n    default:\n      {\n        return MapTreeModule$$$empty();\n      }\n  }\n}\nexport function MapTreeModule$$$mem($comparer$$10$$59, $k$$12$$60, $m$$8$$61) {\n  MapTreeModule$$$mem: while (true) {\n    const comparer$$10 = $comparer$$10$$59,\n          k$$12 = $k$$12$$60,\n          m$$8 = $m$$8$$61;\n\n    switch (m$$8.tag) {\n      case 1:\n        {\n          return comparer$$10.Compare(k$$12, m$$8.fields[0]) === 0;\n        }\n\n      case 2:\n        {\n          const c$$8 = comparer$$10.Compare(k$$12, m$$8.fields[0]) | 0;\n\n          if (c$$8 < 0) {\n            $comparer$$10$$59 = comparer$$10;\n            $k$$12$$60 = k$$12;\n            $m$$8$$61 = m$$8.fields[2];\n            continue MapTreeModule$$$mem;\n          } else if (c$$8 === 0) {\n            return true;\n          } else {\n            $comparer$$10$$59 = comparer$$10;\n            $k$$12$$60 = k$$12;\n            $m$$8$$61 = m$$8.fields[3];\n            continue MapTreeModule$$$mem;\n          }\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$iter($f$$6$$62, $m$$9$$63) {\n  MapTreeModule$$$iter: while (true) {\n    const f$$6 = $f$$6$$62,\n          m$$9 = $m$$9$$63;\n\n    switch (m$$9.tag) {\n      case 1:\n        {\n          f$$6(m$$9.fields[0], m$$9.fields[1]);\n          break;\n        }\n\n      case 2:\n        {\n          MapTreeModule$$$iter(f$$6, m$$9.fields[2]);\n          f$$6(m$$9.fields[0], m$$9.fields[1]);\n          $f$$6$$62 = f$$6;\n          $m$$9$$63 = m$$9.fields[3];\n          continue MapTreeModule$$$iter;\n          break;\n        }\n\n      default:\n        {\n          void null;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$tryPick($f$$7$$64, $m$$10$$65) {\n  MapTreeModule$$$tryPick: while (true) {\n    const f$$7 = $f$$7$$64,\n          m$$10 = $m$$10$$65;\n\n    switch (m$$10.tag) {\n      case 1:\n        {\n          return f$$7(m$$10.fields[0], m$$10.fields[1]);\n        }\n\n      case 2:\n        {\n          const matchValue$$2 = MapTreeModule$$$tryPick(f$$7, m$$10.fields[2]);\n\n          if (matchValue$$2 == null) {\n            const matchValue$$3 = f$$7(m$$10.fields[0], m$$10.fields[1]);\n\n            if (matchValue$$3 == null) {\n              $f$$7$$64 = f$$7;\n              $m$$10$$65 = m$$10.fields[3];\n              continue MapTreeModule$$$tryPick;\n            } else {\n              return matchValue$$3;\n            }\n          } else {\n            return matchValue$$2;\n          }\n        }\n\n      default:\n        {\n          return undefined;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$exists($f$$8$$66, $m$$11$$67) {\n  MapTreeModule$$$exists: while (true) {\n    const f$$8 = $f$$8$$66,\n          m$$11 = $m$$11$$67;\n\n    switch (m$$11.tag) {\n      case 1:\n        {\n          return f$$8(m$$11.fields[0], m$$11.fields[1]);\n        }\n\n      case 2:\n        {\n          if (MapTreeModule$$$exists(f$$8, m$$11.fields[2]) ? true : f$$8(m$$11.fields[0], m$$11.fields[1])) {\n            return true;\n          } else {\n            $f$$8$$66 = f$$8;\n            $m$$11$$67 = m$$11.fields[3];\n            continue MapTreeModule$$$exists;\n          }\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$forall($f$$9$$68, $m$$12$$69) {\n  MapTreeModule$$$forall: while (true) {\n    const f$$9 = $f$$9$$68,\n          m$$12 = $m$$12$$69;\n\n    switch (m$$12.tag) {\n      case 1:\n        {\n          return f$$9(m$$12.fields[0], m$$12.fields[1]);\n        }\n\n      case 2:\n        {\n          if (MapTreeModule$$$forall(f$$9, m$$12.fields[2]) ? f$$9(m$$12.fields[0], m$$12.fields[1]) : false) {\n            $f$$9$$68 = f$$9;\n            $m$$12$$69 = m$$12.fields[3];\n            continue MapTreeModule$$$forall;\n          } else {\n            return false;\n          }\n        }\n\n      default:\n        {\n          return true;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$map(f$$10, m$$13) {\n  switch (m$$13.tag) {\n    case 1:\n      {\n        return new MapTree$00602(1, \"MapOne\", m$$13.fields[0], f$$10(m$$13.fields[1]));\n      }\n\n    case 2:\n      {\n        const l2 = MapTreeModule$$$map(f$$10, m$$13.fields[2]);\n        const v2$$16 = f$$10(m$$13.fields[1]);\n        const r2 = MapTreeModule$$$map(f$$10, m$$13.fields[3]);\n        return new MapTree$00602(2, \"MapNode\", m$$13.fields[0], v2$$16, l2, r2, m$$13.fields[4]);\n      }\n\n    default:\n      {\n        return MapTreeModule$$$empty();\n      }\n  }\n}\nexport function MapTreeModule$$$mapi(f$$11, m$$14) {\n  switch (m$$14.tag) {\n    case 1:\n      {\n        return new MapTree$00602(1, \"MapOne\", m$$14.fields[0], f$$11(m$$14.fields[0], m$$14.fields[1]));\n      }\n\n    case 2:\n      {\n        const l2$$1 = MapTreeModule$$$mapi(f$$11, m$$14.fields[2]);\n        const v2$$17 = f$$11(m$$14.fields[0], m$$14.fields[1]);\n        const r2$$1 = MapTreeModule$$$mapi(f$$11, m$$14.fields[3]);\n        return new MapTree$00602(2, \"MapNode\", m$$14.fields[0], v2$$17, l2$$1, r2$$1, m$$14.fields[4]);\n      }\n\n    default:\n      {\n        return MapTreeModule$$$empty();\n      }\n  }\n}\nexport function MapTreeModule$$$foldBack($f$$12$$74, $m$$15$$75, $x$$1$$76) {\n  MapTreeModule$$$foldBack: while (true) {\n    const f$$12 = $f$$12$$74,\n          m$$15 = $m$$15$$75,\n          x$$1 = $x$$1$$76;\n\n    switch (m$$15.tag) {\n      case 1:\n        {\n          return f$$12(m$$15.fields[0], m$$15.fields[1], x$$1);\n        }\n\n      case 2:\n        {\n          const x$$2 = MapTreeModule$$$foldBack(f$$12, m$$15.fields[3], x$$1);\n          const x$$3 = f$$12(m$$15.fields[0], m$$15.fields[1], x$$2);\n          $f$$12$$74 = f$$12;\n          $m$$15$$75 = m$$15.fields[2];\n          $x$$1$$76 = x$$3;\n          continue MapTreeModule$$$foldBack;\n        }\n\n      default:\n        {\n          return x$$1;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$fold($f$$13$$77, $x$$4$$78, $m$$16$$79) {\n  MapTreeModule$$$fold: while (true) {\n    const f$$13 = $f$$13$$77,\n          x$$4 = $x$$4$$78,\n          m$$16 = $m$$16$$79;\n\n    switch (m$$16.tag) {\n      case 1:\n        {\n          return f$$13(x$$4, m$$16.fields[0], m$$16.fields[1]);\n        }\n\n      case 2:\n        {\n          const x$$5 = MapTreeModule$$$fold(f$$13, x$$4, m$$16.fields[2]);\n          const x$$6 = f$$13(x$$5, m$$16.fields[0], m$$16.fields[1]);\n          $f$$13$$77 = f$$13;\n          $x$$4$$78 = x$$6;\n          $m$$16$$79 = m$$16.fields[3];\n          continue MapTreeModule$$$fold;\n        }\n\n      default:\n        {\n          return x$$4;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$foldFromTo(comparer$$11, lo, hi, f$$14, m$$17, x$$7) {\n  switch (m$$17.tag) {\n    case 1:\n      {\n        const cLoKey = comparer$$11.Compare(lo, m$$17.fields[0]) | 0;\n        const cKeyHi = comparer$$11.Compare(m$$17.fields[0], hi) | 0;\n        const x$$8 = (cLoKey <= 0 ? cKeyHi <= 0 : false) ? f$$14(m$$17.fields[0], m$$17.fields[1], x$$7) : x$$7;\n        return x$$8;\n      }\n\n    case 2:\n      {\n        const cLoKey$$1 = comparer$$11.Compare(lo, m$$17.fields[0]) | 0;\n        const cKeyHi$$1 = comparer$$11.Compare(m$$17.fields[0], hi) | 0;\n        const x$$9 = cLoKey$$1 < 0 ? MapTreeModule$$$foldFromTo(comparer$$11, lo, hi, f$$14, m$$17.fields[2], x$$7) : x$$7;\n        const x$$10 = (cLoKey$$1 <= 0 ? cKeyHi$$1 <= 0 : false) ? f$$14(m$$17.fields[0], m$$17.fields[1], x$$9) : x$$9;\n        const x$$11 = cKeyHi$$1 < 0 ? MapTreeModule$$$foldFromTo(comparer$$11, lo, hi, f$$14, m$$17.fields[3], x$$10) : x$$10;\n        return x$$11;\n      }\n\n    default:\n      {\n        return x$$7;\n      }\n  }\n}\nexport function MapTreeModule$$$foldSection(comparer$$12, lo$$1, hi$$1, f$$15, m$$18, x$$12) {\n  if (comparer$$12.Compare(lo$$1, hi$$1) === 1) {\n    return x$$12;\n  } else {\n    return MapTreeModule$$$foldFromTo(comparer$$12, lo$$1, hi$$1, f$$15, m$$18, x$$12);\n  }\n}\nexport function MapTreeModule$$$loop($m$$19$$92, $acc$$8$$93) {\n  MapTreeModule$$$loop: while (true) {\n    const m$$19 = $m$$19$$92,\n          acc$$8 = $acc$$8$$93;\n\n    switch (m$$19.tag) {\n      case 1:\n        {\n          return new List([m$$19.fields[0], m$$19.fields[1]], acc$$8);\n        }\n\n      case 2:\n        {\n          $m$$19$$92 = m$$19.fields[2];\n          $acc$$8$$93 = new List([m$$19.fields[0], m$$19.fields[1]], MapTreeModule$$$loop(m$$19.fields[3], acc$$8));\n          continue MapTreeModule$$$loop;\n        }\n\n      default:\n        {\n          return acc$$8;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$toList(m$$20) {\n  return MapTreeModule$$$loop(m$$20, new List());\n}\nexport function MapTreeModule$$$ofList(comparer$$13, l$$20) {\n  return fold$$1(function (acc$$9, tupledArg) {\n    return MapTreeModule$$$add(comparer$$13, tupledArg[0], tupledArg[1], acc$$9);\n  }, MapTreeModule$$$empty(), l$$20);\n}\nexport function MapTreeModule$$$mkFromEnumerator($comparer$$14$$97, $acc$$10$$98, $e$$99) {\n  MapTreeModule$$$mkFromEnumerator: while (true) {\n    const comparer$$14 = $comparer$$14$$97,\n          acc$$10 = $acc$$10$$98,\n          e = $e$$99;\n\n    if (e.MoveNext()) {\n      const patternInput$$2 = e.Current;\n      $comparer$$14$$97 = comparer$$14;\n      $acc$$10$$98 = MapTreeModule$$$add(comparer$$14, patternInput$$2[0], patternInput$$2[1], acc$$10);\n      $e$$99 = e;\n      continue MapTreeModule$$$mkFromEnumerator;\n    } else {\n      return acc$$10;\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$ofArray(comparer$$15, arr) {\n  let res$$2 = MapTreeModule$$$empty();\n\n  for (let i = 0; i <= arr.length - 1; i++) {\n    const patternInput$$3 = arr[i];\n    res$$2 = MapTreeModule$$$add(comparer$$15, patternInput$$3[0], patternInput$$3[1], res$$2);\n  }\n\n  return res$$2;\n}\nexport function MapTreeModule$$$ofSeq(comparer$$16, c$$9) {\n  const ie = getEnumerator(c$$9);\n\n  try {\n    return MapTreeModule$$$mkFromEnumerator(comparer$$16, MapTreeModule$$$empty(), ie);\n  } finally {\n    if (isDisposable(ie)) {\n      ie.Dispose();\n    } else {\n      void null;\n    }\n  }\n}\nexport function MapTreeModule$$$copyToArray(s$$4, arr$$1, i$$1) {\n  let j = i$$1 | 0;\n  MapTreeModule$$$iter(function f$$16(x$$15, y$$2) {\n    arr$$1[j] = [x$$15, y$$2];\n    j = j + 1;\n  }, s$$4);\n}\nexport const MapTreeModule$002EMapIterator$00602 = declare(function Map_MapTreeModule_MapIterator(stack, started) {\n  this.stack = stack;\n  this.started = started;\n}, Record);\nexport function MapTreeModule$002EMapIterator$00602$reflection($gen$$109, $gen$$110) {\n  return record_type(\"Map.MapTreeModule.MapIterator`2\", [$gen$$109, $gen$$110], MapTreeModule$002EMapIterator$00602, () => [[\"stack\", list_type(MapTree$00602$reflection($gen$$109, $gen$$110))], [\"started\", bool_type]]);\n}\nexport function MapTreeModule$$$collapseLHS($stack$$111) {\n  MapTreeModule$$$collapseLHS: while (true) {\n    const stack = $stack$$111;\n\n    if (stack.tail != null) {\n      if (stack.head.tag === 1) {\n        return stack;\n      } else if (stack.head.tag === 2) {\n        $stack$$111 = new List(stack.head.fields[2], new List(new MapTree$00602(1, \"MapOne\", stack.head.fields[0], stack.head.fields[1]), new List(stack.head.fields[3], stack.tail)));\n        continue MapTreeModule$$$collapseLHS;\n      } else {\n        $stack$$111 = stack.tail;\n        continue MapTreeModule$$$collapseLHS;\n      }\n    } else {\n      return new List();\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$mkIterator(s$$5) {\n  return new MapTreeModule$002EMapIterator$00602(MapTreeModule$$$collapseLHS(new List(s$$5, new List())), false);\n}\nexport function MapTreeModule$$$notStarted() {\n  throw new Error(\"enumeration not started\");\n}\nexport function MapTreeModule$$$alreadyFinished() {\n  throw new Error(\"enumeration already finished\");\n}\nexport function MapTreeModule$$$current(i$$2) {\n  if (i$$2.started) {\n    const matchValue$$4 = i$$2.stack;\n\n    if (matchValue$$4.tail == null) {\n      return MapTreeModule$$$alreadyFinished();\n    } else if (matchValue$$4.head.tag === 1) {\n      return [matchValue$$4.head.fields[0], matchValue$$4.head.fields[1]];\n    } else {\n      throw new Error(\"Please report error: Map iterator, unexpected stack for current\");\n    }\n  } else {\n    return MapTreeModule$$$notStarted();\n  }\n}\nexport function MapTreeModule$$$moveNext(i$$3) {\n  if (i$$3.started) {\n    const matchValue$$5 = i$$3.stack;\n\n    if (matchValue$$5.tail == null) {\n      return false;\n    } else if (matchValue$$5.head.tag === 1) {\n      i$$3.stack = MapTreeModule$$$collapseLHS(matchValue$$5.tail);\n      return !(i$$3.stack.tail == null);\n    } else {\n      throw new Error(\"Please report error: Map iterator, unexpected stack for moveNext\");\n    }\n  } else {\n    i$$3.started = true;\n    return !(i$$3.stack.tail == null);\n  }\n}\nexport const MapTreeModule$002EmkIEnumerator$0027$00602 = declare(function Map_MapTreeModule_mkIEnumerator_(s$$6) {\n  const $this$$1 = this;\n  $this$$1.s = s$$6;\n  $this$$1.i = MapTreeModule$$$mkIterator($this$$1.s);\n  void null;\n});\nexport function MapTreeModule$002EmkIEnumerator$0027$00602$reflection($gen$$115, $gen$$116) {\n  return class_type(\"Map.MapTreeModule.mkIEnumerator'`2\", [$gen$$115, $gen$$116], MapTreeModule$002EmkIEnumerator$0027$00602);\n}\nexport function MapTreeModule$002EmkIEnumerator$0027$00602$$$$002Ector$$Z26BC498C(s$$6) {\n  return this instanceof MapTreeModule$002EmkIEnumerator$0027$00602 ? MapTreeModule$002EmkIEnumerator$0027$00602.call(this, s$$6) : new MapTreeModule$002EmkIEnumerator$0027$00602(s$$6);\n}\nObject.defineProperty(MapTreeModule$002EmkIEnumerator$0027$00602.prototype, \"Current\", {\n  \"get\": function () {\n    const __ = this;\n    return MapTreeModule$$$current(__.i);\n  }\n});\n\nMapTreeModule$002EmkIEnumerator$0027$00602.prototype.MoveNext = function () {\n  const __$$1 = this;\n  return MapTreeModule$$$moveNext(__$$1.i);\n};\n\nMapTreeModule$002EmkIEnumerator$0027$00602.prototype.Reset = function () {\n  const __$$2 = this;\n  __$$2.i = MapTreeModule$$$mkIterator(__$$2.s);\n};\n\nMapTreeModule$002EmkIEnumerator$0027$00602.prototype.Dispose = function () {\n  void null;\n};\n\nexport function MapTreeModule$$$mkIEnumerator(s$$7) {\n  return MapTreeModule$002EmkIEnumerator$0027$00602$$$$002Ector$$Z26BC498C(s$$7);\n}\nexport function MapTreeModule$$$toSeq(s$$8) {\n  const en = MapTreeModule$$$mkIEnumerator(s$$8);\n  return unfold(function generator(en$$1) {\n    if (en$$1.MoveNext()) {\n      return [en$$1.Current, en$$1];\n    } else {\n      return undefined;\n    }\n  }, en);\n}\nexport const FSharpMap = declare(function Map_Map(comparer$$17, tree) {\n  const $this$$2 = this;\n  $this$$2.comparer = comparer$$17;\n  $this$$2.tree = tree;\n  void null;\n});\nexport function FSharpMap$reflection($gen$$120, $gen$$121) {\n  return class_type(\"Map.FSharpMap\", [$gen$$120, $gen$$121], FSharpMap);\n}\nexport function FSharpMap$$$$002Ector$$58ADD115(comparer$$17, tree) {\n  return this instanceof FSharpMap ? FSharpMap.call(this, comparer$$17, tree) : new FSharpMap(comparer$$17, tree);\n}\nexport function FSharpMap$$get_Comparer(__$$4) {\n  return __$$4.comparer;\n}\nexport function FSharpMap$$get_Tree(__$$5) {\n  return __$$5.tree;\n}\nexport function FSharpMap$$Add$$5BDDA1(__$$6, k$$28, v$$24) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$6.comparer, MapTreeModule$$$add(__$$6.comparer, k$$28, v$$24, __$$6.tree));\n}\nexport function FSharpMap$$get_IsEmpty(__$$7) {\n  return MapTreeModule$$$isEmpty(__$$7.tree);\n}\nexport function FSharpMap$$get_Item$$2B595(__$$8, k$$29) {\n  return MapTreeModule$$$find(__$$8.comparer, k$$29, __$$8.tree);\n}\nexport function FSharpMap$$TryGetValue$$5BDDA1(__$$9, k$$30, defValue) {\n  const matchValue$$6 = MapTreeModule$$$tryFind(__$$9.comparer, k$$30, __$$9.tree);\n\n  if (matchValue$$6 == null) {\n    return [false, defValue];\n  } else {\n    const v$$25 = value$$3(matchValue$$6);\n    return [true, v$$25];\n  }\n}\nexport function FSharpMap$$TryPick$$72321DD7(__$$10, f$$17) {\n  return MapTreeModule$$$tryPick(f$$17, __$$10.tree);\n}\nexport function FSharpMap$$Exists$$Z395DDC35(__$$11, f$$18) {\n  return MapTreeModule$$$exists(f$$18, __$$11.tree);\n}\nexport function FSharpMap$$Filter$$Z395DDC35(__$$12, f$$19) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$12.comparer, MapTreeModule$$$filter(__$$12.comparer, f$$19, __$$12.tree));\n}\nexport function FSharpMap$$ForAll$$Z395DDC35(__$$13, f$$20) {\n  return MapTreeModule$$$forall(f$$20, __$$13.tree);\n}\nexport function FSharpMap$$Fold(__$$14, f$$21, acc$$11) {\n  return MapTreeModule$$$foldBack(f$$21, __$$14.tree, acc$$11);\n}\nexport function FSharpMap$$FoldSection(__$$15, lo$$2, hi$$2, f$$22, acc$$12) {\n  return MapTreeModule$$$foldSection(__$$15.comparer, lo$$2, hi$$2, f$$22, __$$15.tree, acc$$12);\n}\nexport function FSharpMap$$Iterate$$1DCFB91D(__$$16, f$$23) {\n  MapTreeModule$$$iter(f$$23, __$$16.tree);\n}\nexport function FSharpMap$$MapRange$$6DC7247(__$$17, f$$24) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$17.comparer, MapTreeModule$$$map(f$$24, __$$17.tree));\n}\nexport function FSharpMap$$Map$$Z6F6B671C(__$$18, f$$25) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$18.comparer, MapTreeModule$$$mapi(f$$25, __$$18.tree));\n}\nexport function FSharpMap$$Partition$$Z395DDC35(__$$19, f$$26) {\n  const patternInput$$4 = MapTreeModule$$$partition(__$$19.comparer, f$$26, __$$19.tree);\n  return [FSharpMap$$$$002Ector$$58ADD115(__$$19.comparer, patternInput$$4[0]), FSharpMap$$$$002Ector$$58ADD115(__$$19.comparer, patternInput$$4[1])];\n}\nexport function FSharpMap$$get_Count(__$$20) {\n  return MapTreeModule$$$size(__$$20.tree);\n}\nexport function FSharpMap$$ContainsKey$$2B595(__$$21, k$$31) {\n  return MapTreeModule$$$mem(__$$21.comparer, k$$31, __$$21.tree);\n}\nexport function FSharpMap$$Remove$$2B595(__$$22, k$$32) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$22.comparer, MapTreeModule$$$remove(__$$22.comparer, k$$32, __$$22.tree));\n}\nexport function FSharpMap$$TryFind$$2B595(__$$23, k$$33) {\n  return MapTreeModule$$$tryFind(__$$23.comparer, k$$33, __$$23.tree);\n}\nexport function FSharpMap$$ToList(__$$24) {\n  return MapTreeModule$$$toList(__$$24.tree);\n}\n\nFSharpMap.prototype.toString = function () {\n  const this$ = this;\n  let str;\n  let strings;\n  strings = map$$2(function toStr(kv) {\n    return format(\"({0}, {1})\", kv[0], kv[1]);\n  }, this$);\n  str = join(\"; \", strings);\n  return \"map [\" + str + \"]\";\n};\n\nFSharpMap.prototype.GetHashCode = function () {\n  const this$$$1 = this;\n\n  const combineHash = function combineHash(x$$16, y$$3) {\n    return (x$$16 << 1) + y$$3 + 631;\n  };\n\n  let res$$3 = 0;\n  const e$$1 = MapTreeModule$$$mkIEnumerator(FSharpMap$$get_Tree(this$$$1));\n\n  while (e$$1.MoveNext()) {\n    const patternInput$$5 = e$$1.Current;\n    const activePatternResult3682 = patternInput$$5;\n    res$$3 = combineHash(res$$3, structuralHash(activePatternResult3682[0]));\n    res$$3 = combineHash(res$$3, structuralHash(activePatternResult3682[1]));\n  }\n\n  return Math.abs(res$$3) | 0;\n};\n\nFSharpMap.prototype.Equals = function (that) {\n  const this$$$2 = this;\n  return this$$$2.CompareTo(that) === 0;\n};\n\nFSharpMap.prototype[Symbol.iterator] = function () {\n  const __$$25 = this;\n  return toIterator(MapTreeModule$$$mkIEnumerator(__$$25.tree));\n};\n\nFSharpMap.prototype.CompareTo = function (obj) {\n  const m$$22 = this;\n  let res$$4 = 0;\n  let finished = false;\n  const e1 = MapTreeModule$$$mkIEnumerator(FSharpMap$$get_Tree(m$$22));\n\n  try {\n    const e2 = MapTreeModule$$$mkIEnumerator(FSharpMap$$get_Tree(obj));\n\n    try {\n      while (!finished ? res$$4 === 0 : false) {\n        const matchValue$$7 = [e1.MoveNext(), e2.MoveNext()];\n\n        if (matchValue$$7[0]) {\n          if (matchValue$$7[1]) {\n            const kvp1 = e1.Current;\n            const kvp2 = e2.Current;\n            const c$$10 = m$$22.comparer.Compare(kvp1[0], kvp2[0]) | 0;\n            res$$4 = c$$10 !== 0 ? c$$10 : compare(kvp1[1], kvp2[1]);\n          } else {\n            res$$4 = 1;\n          }\n        } else if (matchValue$$7[1]) {\n          res$$4 = -1;\n        } else {\n          finished = true;\n        }\n      }\n\n      return res$$4 | 0;\n    } finally {\n      if (isDisposable(e2)) {\n        e2.Dispose();\n      } else {\n        void null;\n      }\n    }\n  } finally {\n    if (isDisposable(e1)) {\n      e1.Dispose();\n    } else {\n      void null;\n    }\n  }\n};\n\nObject.defineProperty(FSharpMap.prototype, \"size\", {\n  \"get\": function () {\n    const this$$$3 = this;\n    return FSharpMap$$get_Count(this$$$3) | 0;\n  }\n});\n\nFSharpMap.prototype.clear = function () {\n  throw new Error(\"Map cannot be mutated\");\n};\n\nFSharpMap.prototype.delete = function (_arg1$$1) {\n  throw new Error(\"Map cannot be mutated\");\n};\n\nFSharpMap.prototype.entries = function () {\n  const this$$$4 = this;\n  return MapTreeModule$$$toSeq(FSharpMap$$get_Tree(this$$$4));\n};\n\nFSharpMap.prototype.get = function (k$$34) {\n  const this$$$5 = this;\n  return FSharpMap$$get_Item$$2B595(this$$$5, k$$34);\n};\n\nFSharpMap.prototype.has = function (k$$35) {\n  const this$$$6 = this;\n  return FSharpMap$$ContainsKey$$2B595(this$$$6, k$$35);\n};\n\nFSharpMap.prototype.keys = function () {\n  const this$$$7 = this;\n  const source$$1 = MapTreeModule$$$toSeq(FSharpMap$$get_Tree(this$$$7));\n  return map$$2(function mapping(kv$$1) {\n    return kv$$1[0];\n  }, source$$1);\n};\n\nFSharpMap.prototype.set = function (k$$36, v$$26) {\n  throw new Error(\"Map cannot be mutated\");\n};\n\nFSharpMap.prototype.values = function () {\n  const this$$$8 = this;\n  const source$$2 = MapTreeModule$$$toSeq(FSharpMap$$get_Tree(this$$$8));\n  return map$$2(function mapping$$1(kv$$2) {\n    return kv$$2[1];\n  }, source$$2);\n};\n\nexport function isEmpty(m$$23) {\n  return FSharpMap$$get_IsEmpty(m$$23);\n}\nexport function add(k$$37, v$$27, m$$24) {\n  return FSharpMap$$Add$$5BDDA1(m$$24, k$$37, v$$27);\n}\nexport function find(k$$38, m$$25) {\n  return FSharpMap$$get_Item$$2B595(m$$25, k$$38);\n}\nexport function tryFind(k$$39, m$$26) {\n  return FSharpMap$$TryFind$$2B595(m$$26, k$$39);\n}\nexport function remove(k$$40, m$$27) {\n  return FSharpMap$$Remove$$2B595(m$$27, k$$40);\n}\nexport function containsKey(k$$41, m$$28) {\n  return FSharpMap$$ContainsKey$$2B595(m$$28, k$$41);\n}\nexport function iterate(f$$27, m$$29) {\n  FSharpMap$$Iterate$$1DCFB91D(m$$29, f$$27);\n}\nexport function tryPick(f$$28, m$$30) {\n  return FSharpMap$$TryPick$$72321DD7(m$$30, f$$28);\n}\nexport function pick(f$$29, m$$31) {\n  const matchValue$$8 = tryPick(f$$29, m$$31);\n\n  if (matchValue$$8 != null) {\n    const res$$5 = value$$3(matchValue$$8);\n    return res$$5;\n  } else {\n    throw new Error(\"key not found\");\n  }\n}\nexport function exists(f$$30, m$$32) {\n  return FSharpMap$$Exists$$Z395DDC35(m$$32, f$$30);\n}\nexport function filter(f$$31, m$$33) {\n  return FSharpMap$$Filter$$Z395DDC35(m$$33, f$$31);\n}\nexport function partition(f$$32, m$$34) {\n  return FSharpMap$$Partition$$Z395DDC35(m$$34, f$$32);\n}\nexport function forAll(f$$33, m$$35) {\n  return FSharpMap$$ForAll$$Z395DDC35(m$$35, f$$33);\n}\nexport function mapRange(f$$34, m$$36) {\n  return FSharpMap$$MapRange$$6DC7247(m$$36, f$$34);\n}\nexport function map(f$$35, m$$37) {\n  return FSharpMap$$Map$$Z6F6B671C(m$$37, f$$35);\n}\nexport function fold(f$$36, z, m$$38) {\n  return MapTreeModule$$$fold(f$$36, z, FSharpMap$$get_Tree(m$$38));\n}\nexport function foldBack(f$$37, m$$39, z$$1) {\n  return MapTreeModule$$$foldBack(f$$37, FSharpMap$$get_Tree(m$$39), z$$1);\n}\nexport function toSeq(m$$40) {\n  return MapTreeModule$$$toSeq(FSharpMap$$get_Tree(m$$40));\n}\nexport function findKey(f$$38, m$$41) {\n  let _arg1$$2;\n\n  const m$$42 = FSharpMap$$get_Tree(m$$41);\n  _arg1$$2 = MapTreeModule$$$tryPick(function f$$39(k$$42, v$$28) {\n    if (f$$38(k$$42, v$$28)) {\n      return some(k$$42);\n    } else {\n      return undefined;\n    }\n  }, m$$42);\n\n  if (_arg1$$2 == null) {\n    throw new Error(\"Key not found\");\n  } else {\n    const k$$43 = value$$3(_arg1$$2);\n    return k$$43;\n  }\n}\nexport function tryFindKey(f$$40, m$$43) {\n  const m$$44 = FSharpMap$$get_Tree(m$$43);\n  return MapTreeModule$$$tryPick(function f$$41(k$$44, v$$29) {\n    if (f$$40(k$$44, v$$29)) {\n      return some(k$$44);\n    } else {\n      return undefined;\n    }\n  }, m$$44);\n}\nexport function ofList(l$$22, comparer$$18) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$18, MapTreeModule$$$ofList(comparer$$18, l$$22));\n}\nexport function ofSeq(l$$23, comparer$$19) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$19, MapTreeModule$$$ofSeq(comparer$$19, l$$23));\n}\nexport function ofArray(array, comparer$$20) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$20, MapTreeModule$$$ofArray(comparer$$20, array));\n}\nexport function toList(m$$45) {\n  return FSharpMap$$ToList(m$$45);\n}\nexport function toArray(m$$46) {\n  let res$$6;\n  const len = FSharpMap$$get_Count(m$$46) | 0;\n  res$$6 = new Array(len);\n  MapTreeModule$$$copyToArray(FSharpMap$$get_Tree(m$$46), res$$6, 0);\n  return res$$6;\n}\nexport function empty(comparer$$21) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$21, new MapTree$00602(0, \"MapEmpty\"));\n}\nexport function createMutable(source$$3, comparer$$22) {\n  const map$$1 = MutableMap$002400602$0024$0024$0024$0024002Ector$0024$00246623D9B3(source$$3, comparer$$22);\n  return map$$1;\n}\nexport function groupBy(projection, xs, comparer$$23) {\n  const dict = createMutable(empty$$1(), comparer$$23);\n  iterate$$1(function (v$$30) {\n    const key = projection(v$$30);\n\n    if (dict.has(key)) {\n      void dict.get(key).push(v$$30);\n    } else {\n      const value = dict.set(key, [v$$30]);\n      void value;\n    }\n  }, xs);\n  return map$$2(function mapping$$2(kv$$3) {\n    return [kv$$3[0], kv$$3[1]];\n  }, dict);\n}\nexport function countBy(projection$$1, xs$$1, comparer$$24) {\n  const dict$$1 = createMutable(empty$$1(), comparer$$24);\n  iterate$$1(function (value$$1) {\n    const key$$1 = projection$$1(value$$1);\n    const value$$2 = dict$$1.has(key$$1) ? dict$$1.set(key$$1, dict$$1.get(key$$1) + 1) : dict$$1.set(key$$1, 1);\n    void value$$2;\n  }, xs$$1);\n  return map$$2(function mapping$$3(kv$$4) {\n    return [kv$$4[0], kv$$4[1]];\n  }, dict$$1);\n}\nexport function count(m$$47) {\n  return FSharpMap$$get_Count(m$$47);\n}","import { declare, FSharpRef } from \"./Types.js\";\nimport { iterateIndexed, toIterator, getEnumerator, delay, collect, map, sumBy, iterate } from \"./Seq.js\";\nimport { class_type } from \"./Reflection.js\";\nimport { getItemFromDict, tryGetValue } from \"./Util.js\";\nimport { some } from \"./Option.js\";\nexport const MutableSet$00601 = declare(function Fable_Collections_MutableSet(items, comparer) {\n  const $this$$1 = this;\n  const this$ = new FSharpRef(null);\n  $this$$1.comparer = comparer;\n  this$.contents = $this$$1;\n  $this$$1.hashMap = new Map([]);\n  $this$$1[\"init@21-2\"] = 1;\n  iterate(function (item) {\n    const value = MutableSet$00601$$Add$$2B595(this$.contents, item);\n    void value;\n  }, items);\n  void null;\n});\nexport function MutableSet$00601$reflection($gen$$4) {\n  return class_type(\"Fable.Collections.MutableSet`1\", [$gen$$4], MutableSet$00601);\n}\nexport function MutableSet$00601$$$$002Ector$$Z6150332D(items, comparer) {\n  return this instanceof MutableSet$00601 ? MutableSet$00601.call(this, items, comparer) : new MutableSet$00601(items, comparer);\n}\n\nfunction MutableSet$00601$$TryFindIndex$$2B595(this$$$1, k) {\n  const h = this$$$1.comparer.GetHashCode(k) | 0;\n  const matchValue = tryGetValue(this$$$1.hashMap, h, null);\n\n  if (matchValue[0]) {\n    return [true, h, matchValue[1].findIndex(function (v) {\n      return this$$$1.comparer.Equals(k, v);\n    })];\n  } else {\n    return [false, h, -1];\n  }\n}\n\nfunction MutableSet$00601$$TryFind$$2B595(this$$$2, k$$1) {\n  const matchValue$$1 = MutableSet$00601$$TryFindIndex$$2B595(this$$$2, k$$1);\n  var $target$$9;\n\n  if (matchValue$$1[0]) {\n    if (matchValue$$1[2] > -1) {\n      $target$$9 = 0;\n    } else {\n      $target$$9 = 1;\n    }\n  } else {\n    $target$$9 = 1;\n  }\n\n  switch ($target$$9) {\n    case 0:\n      {\n        return some(getItemFromDict(this$$$2.hashMap, matchValue$$1[1])[matchValue$$1[2]]);\n      }\n\n    case 1:\n      {\n        return undefined;\n      }\n  }\n}\n\nexport function MutableSet$00601$$get_Comparer(this$$$3) {\n  return this$$$3.comparer;\n}\nexport function MutableSet$00601$$Clear(this$$$4) {\n  this$$$4.hashMap.clear();\n}\nexport function MutableSet$00601$$get_Count(this$$$5) {\n  const source = this$$$5.hashMap.values();\n  return sumBy(function projection(pairs) {\n    return pairs.length;\n  }, source, {\n    GetZero() {\n      return 0;\n    },\n\n    Add($x$$2, $y$$3) {\n      return $x$$2 + $y$$3;\n    }\n\n  }) | 0;\n}\nexport function MutableSet$00601$$Add$$2B595(this$$$6, k$$2) {\n  const matchValue$$2 = MutableSet$00601$$TryFindIndex$$2B595(this$$$6, k$$2);\n  var $target$$16;\n\n  if (matchValue$$2[0]) {\n    if (matchValue$$2[2] > -1) {\n      $target$$16 = 0;\n    } else {\n      $target$$16 = 1;\n    }\n  } else {\n    $target$$16 = 1;\n  }\n\n  switch ($target$$16) {\n    case 0:\n      {\n        return false;\n      }\n\n    case 1:\n      {\n        if (matchValue$$2[0]) {\n          const value$$1 = void getItemFromDict(this$$$6.hashMap, matchValue$$2[1]).push(k$$2);\n          void null;\n          return true;\n        } else {\n          this$$$6.hashMap.set(matchValue$$2[1], [k$$2]);\n          return true;\n        }\n      }\n  }\n}\nexport function MutableSet$00601$$Contains$$2B595(this$$$7, k$$3) {\n  const matchValue$$3 = MutableSet$00601$$TryFindIndex$$2B595(this$$$7, k$$3);\n  var $target$$19;\n\n  if (matchValue$$3[0]) {\n    if (matchValue$$3[2] > -1) {\n      $target$$19 = 0;\n    } else {\n      $target$$19 = 1;\n    }\n  } else {\n    $target$$19 = 1;\n  }\n\n  switch ($target$$19) {\n    case 0:\n      {\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\nexport function MutableSet$00601$$Remove$$2B595(this$$$8, k$$4) {\n  const matchValue$$4 = MutableSet$00601$$TryFindIndex$$2B595(this$$$8, k$$4);\n  var $target$$22;\n\n  if (matchValue$$4[0]) {\n    if (matchValue$$4[2] > -1) {\n      $target$$22 = 0;\n    } else {\n      $target$$22 = 1;\n    }\n  } else {\n    $target$$22 = 1;\n  }\n\n  switch ($target$$22) {\n    case 0:\n      {\n        getItemFromDict(this$$$8.hashMap, matchValue$$4[1]).splice(matchValue$$4[2], 1);\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\n\nMutableSet$00601.prototype[Symbol.iterator] = function () {\n  var elems;\n  const this$$$9 = this;\n  return toIterator((elems = delay(function () {\n    return collect(function (values$$1) {\n      return map(function (value$$2) {\n        return value$$2;\n      }, values$$1);\n    }, this$$$9.hashMap.values());\n  }), getEnumerator(elems)));\n};\n\nMutableSet$00601.prototype.Add = function (item$$1) {\n  const this$$$10 = this;\n  const value$$3 = MutableSet$00601$$Add$$2B595(this$$$10, item$$1);\n  void value$$3;\n};\n\nMutableSet$00601.prototype.Clear = function () {\n  const this$$$11 = this;\n  MutableSet$00601$$Clear(this$$$11);\n};\n\nMutableSet$00601.prototype.Contains = function (item$$2) {\n  const this$$$12 = this;\n  return MutableSet$00601$$Contains$$2B595(this$$$12, item$$2);\n};\n\nMutableSet$00601.prototype.CopyTo = function (array, arrayIndex) {\n  const this$$$13 = this;\n  iterateIndexed(function action(i$$8, e) {\n    array[arrayIndex + i$$8] = e;\n  }, this$$$13);\n};\n\nObject.defineProperty(MutableSet$00601.prototype, \"Count\", {\n  \"get\": function () {\n    const this$$$14 = this;\n    return MutableSet$00601$$get_Count(this$$$14) | 0;\n  }\n});\nObject.defineProperty(MutableSet$00601.prototype, \"IsReadOnly\", {\n  \"get\": function () {\n    return false;\n  }\n});\n\nMutableSet$00601.prototype.Remove = function (item$$3) {\n  const this$$$16 = this;\n  return MutableSet$00601$$Remove$$2B595(this$$$16, item$$3);\n};\n\nObject.defineProperty(MutableSet$00601.prototype, \"size\", {\n  \"get\": function () {\n    const this$$$17 = this;\n    return MutableSet$00601$$get_Count(this$$$17) | 0;\n  }\n});\n\nMutableSet$00601.prototype.add = function (k$$5) {\n  const this$$$18 = this;\n  const value$$4 = MutableSet$00601$$Add$$2B595(this$$$18, k$$5);\n  void value$$4;\n  return this$$$18;\n};\n\nMutableSet$00601.prototype.add_ = function (k$$6) {\n  const this$$$19 = this;\n  return MutableSet$00601$$Add$$2B595(this$$$19, k$$6);\n};\n\nMutableSet$00601.prototype.clear = function () {\n  const this$$$20 = this;\n  MutableSet$00601$$Clear(this$$$20);\n};\n\nMutableSet$00601.prototype.delete = function (k$$7) {\n  const this$$$21 = this;\n  return MutableSet$00601$$Remove$$2B595(this$$$21, k$$7);\n};\n\nMutableSet$00601.prototype.has = function (k$$8) {\n  const this$$$22 = this;\n  return MutableSet$00601$$Contains$$2B595(this$$$22, k$$8);\n};\n\nMutableSet$00601.prototype.keys = function () {\n  const this$$$23 = this;\n  return map(function mapping(x) {\n    return x;\n  }, this$$$23);\n};\n\nMutableSet$00601.prototype.values = function () {\n  const this$$$24 = this;\n  return map(function mapping$$1(x$$1) {\n    return x$$1;\n  }, this$$$24);\n};\n\nMutableSet$00601.prototype.entries = function () {\n  const this$$$25 = this;\n  return map(function mapping$$2(v$$1) {\n    return [v$$1, v$$1];\n  }, this$$$25);\n};","import { List, Record, declare, Union } from \"./Types.js\";\nimport { class_type, record_type, bool_type, list_type, union_type, int32_type } from \"./Reflection.js\";\nimport { value as value$$2, some, Choice } from \"./Option.js\";\nimport { iterate as iterate$$1, delay, collect, singleton as singleton$$1, empty as empty$$1, fold as fold$$1, toIterator, map as map$$1, reduce, getEnumerator, unfold } from \"./Seq.js\";\nimport { structuralHash, isDisposable } from \"./Util.js\";\nimport { join } from \"./String.js\";\nimport { MutableSet$00601$$Add$$2B595 as MutableSet$002400601$0024$0024Add$0024$00242B595, MutableSet$00601$$$$002Ector$$Z6150332D as MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D } from \"./MutableSet\";\nexport const SetTree$00601 = declare(function Set_SetTree(tag, name, ...fields) {\n  this.tag = tag | 0;\n  this.name = name;\n  this.fields = fields;\n}, Union);\nexport function SetTree$00601$reflection($gen$$3) {\n  return union_type(\"Set.SetTree`1\", [$gen$$3], SetTree$00601, () => [\"SetEmpty\", [\"SetNode\", [[\"Item1\", $gen$$3], [\"Item2\", SetTree$00601$reflection($gen$$3)], [\"Item3\", SetTree$00601$reflection($gen$$3)], [\"Item4\", int32_type]]], [\"SetOne\", [[\"Item\", $gen$$3]]]]);\n}\nexport function SetTreeModule$$$countAux($s$$4, $acc$$5) {\n  SetTreeModule$$$countAux: while (true) {\n    const s = $s$$4,\n          acc = $acc$$5;\n\n    switch (s.tag) {\n      case 2:\n        {\n          return acc + 1 | 0;\n        }\n\n      case 0:\n        {\n          return acc | 0;\n        }\n\n      default:\n        {\n          $s$$4 = s.fields[1];\n          $acc$$5 = SetTreeModule$$$countAux(s.fields[2], acc + 1);\n          continue SetTreeModule$$$countAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$count(s$$1) {\n  return SetTreeModule$$$countAux(s$$1, 0);\n}\nexport function SetTreeModule$$$SetOne(n) {\n  return new SetTree$00601(2, \"SetOne\", n);\n}\nexport function SetTreeModule$$$SetNode(x, l$$1, r$$1, h) {\n  return new SetTree$00601(1, \"SetNode\", x, l$$1, r$$1, h);\n}\nexport function SetTreeModule$$$height(t) {\n  switch (t.tag) {\n    case 2:\n      {\n        return 1;\n      }\n\n    case 1:\n      {\n        return t.fields[3] | 0;\n      }\n\n    default:\n      {\n        return 0;\n      }\n  }\n}\nexport const SetTreeModule$$$tolerance = 2;\nexport function SetTreeModule$$$mk(l$$2, k, r$$2) {\n  var $target$$16;\n\n  if (l$$2.tag === 0) {\n    if (r$$2.tag === 0) {\n      $target$$16 = 0;\n    } else {\n      $target$$16 = 1;\n    }\n  } else {\n    $target$$16 = 1;\n  }\n\n  switch ($target$$16) {\n    case 0:\n      {\n        return SetTreeModule$$$SetOne(k);\n      }\n\n    case 1:\n      {\n        const hl = SetTreeModule$$$height(l$$2) | 0;\n        const hr = SetTreeModule$$$height(r$$2) | 0;\n        const m = (hl < hr ? hr : hl) | 0;\n        return SetTreeModule$$$SetNode(k, l$$2, r$$2, m + 1);\n      }\n  }\n}\nexport function SetTreeModule$$$rebalance(t1, k$$1, t2) {\n  const t1h = SetTreeModule$$$height(t1) | 0;\n  const t2h = SetTreeModule$$$height(t2) | 0;\n\n  if (t2h > t1h + SetTreeModule$$$tolerance) {\n    if (t2.tag === 1) {\n      if (SetTreeModule$$$height(t2.fields[1]) > t1h + 1) {\n        if (t2.fields[1].tag === 1) {\n          return SetTreeModule$$$mk(SetTreeModule$$$mk(t1, k$$1, t2.fields[1].fields[1]), t2.fields[1].fields[0], SetTreeModule$$$mk(t2.fields[1].fields[2], t2.fields[0], t2.fields[2]));\n        } else {\n          throw new Error(\"rebalance\");\n        }\n      } else {\n        return SetTreeModule$$$mk(SetTreeModule$$$mk(t1, k$$1, t2.fields[1]), t2.fields[0], t2.fields[2]);\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else if (t1h > t2h + SetTreeModule$$$tolerance) {\n    if (t1.tag === 1) {\n      if (SetTreeModule$$$height(t1.fields[2]) > t2h + 1) {\n        if (t1.fields[2].tag === 1) {\n          return SetTreeModule$$$mk(SetTreeModule$$$mk(t1.fields[1], t1.fields[0], t1.fields[2].fields[1]), t1.fields[2].fields[0], SetTreeModule$$$mk(t1.fields[2].fields[2], k$$1, t2));\n        } else {\n          throw new Error(\"rebalance\");\n        }\n      } else {\n        return SetTreeModule$$$mk(t1.fields[1], t1.fields[0], SetTreeModule$$$mk(t1.fields[2], k$$1, t2));\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else {\n    return SetTreeModule$$$mk(t1, k$$1, t2);\n  }\n}\nexport function SetTreeModule$$$add(comparer, k$$2, t$$1) {\n  switch (t$$1.tag) {\n    case 2:\n      {\n        const c$$1 = comparer.Compare(k$$2, t$$1.fields[0]) | 0;\n\n        if (c$$1 < 0) {\n          return SetTreeModule$$$SetNode(k$$2, new SetTree$00601(0, \"SetEmpty\"), t$$1, 2);\n        } else if (c$$1 === 0) {\n          return t$$1;\n        } else {\n          return SetTreeModule$$$SetNode(k$$2, t$$1, new SetTree$00601(0, \"SetEmpty\"), 2);\n        }\n      }\n\n    case 0:\n      {\n        return SetTreeModule$$$SetOne(k$$2);\n      }\n\n    default:\n      {\n        const c = comparer.Compare(k$$2, t$$1.fields[0]) | 0;\n\n        if (c < 0) {\n          return SetTreeModule$$$rebalance(SetTreeModule$$$add(comparer, k$$2, t$$1.fields[1]), t$$1.fields[0], t$$1.fields[2]);\n        } else if (c === 0) {\n          return t$$1;\n        } else {\n          return SetTreeModule$$$rebalance(t$$1.fields[1], t$$1.fields[0], SetTreeModule$$$add(comparer, k$$2, t$$1.fields[2]));\n        }\n      }\n  }\n}\nexport function SetTreeModule$$$balance(comparer$$1, t1$$1, k$$3, t2$$1) {\n  var $target$$27, t2$$2, t1$$2, k1, t2$$3, k2$$2, t1$$3, h1, h2, k1$$1, k2$$3, t11, t12, t21, t22;\n\n  if (t1$$1.tag === 2) {\n    if (t2$$1.tag === 0) {\n      $target$$27 = 1;\n      t1$$2 = t1$$1;\n    } else if (t2$$1.tag === 2) {\n      $target$$27 = 2;\n      k1 = t1$$1.fields[0];\n      t2$$3 = t2$$1;\n    } else {\n      $target$$27 = 2;\n      k1 = t1$$1.fields[0];\n      t2$$3 = t2$$1;\n    }\n  } else if (t1$$1.tag === 1) {\n    if (t2$$1.tag === 2) {\n      $target$$27 = 3;\n      k2$$2 = t2$$1.fields[0];\n      t1$$3 = t1$$1;\n    } else if (t2$$1.tag === 1) {\n      $target$$27 = 4;\n      h1 = t1$$1.fields[3];\n      h2 = t2$$1.fields[3];\n      k1$$1 = t1$$1.fields[0];\n      k2$$3 = t2$$1.fields[0];\n      t11 = t1$$1.fields[1];\n      t12 = t1$$1.fields[2];\n      t21 = t2$$1.fields[1];\n      t22 = t2$$1.fields[2];\n    } else {\n      $target$$27 = 1;\n      t1$$2 = t1$$1;\n    }\n  } else {\n    $target$$27 = 0;\n    t2$$2 = t2$$1;\n  }\n\n  switch ($target$$27) {\n    case 0:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, t2$$2);\n      }\n\n    case 1:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, t1$$2);\n      }\n\n    case 2:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, SetTreeModule$$$add(comparer$$1, k1, t2$$3));\n      }\n\n    case 3:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, SetTreeModule$$$add(comparer$$1, k2$$2, t1$$3));\n      }\n\n    case 4:\n      {\n        if (h1 + SetTreeModule$$$tolerance < h2) {\n          return SetTreeModule$$$rebalance(SetTreeModule$$$balance(comparer$$1, t1$$1, k$$3, t21), k2$$3, t22);\n        } else if (h2 + SetTreeModule$$$tolerance < h1) {\n          return SetTreeModule$$$rebalance(t11, k1$$1, SetTreeModule$$$balance(comparer$$1, t12, k$$3, t2$$1));\n        } else {\n          return SetTreeModule$$$mk(t1$$1, k$$3, t2$$1);\n        }\n      }\n  }\n}\nexport function SetTreeModule$$$split(comparer$$2, pivot, t$$2) {\n  switch (t$$2.tag) {\n    case 2:\n      {\n        const c$$3 = comparer$$2.Compare(t$$2.fields[0], pivot) | 0;\n\n        if (c$$3 < 0) {\n          return [t$$2, false, new SetTree$00601(0, \"SetEmpty\")];\n        } else if (c$$3 === 0) {\n          return [new SetTree$00601(0, \"SetEmpty\"), true, new SetTree$00601(0, \"SetEmpty\")];\n        } else {\n          return [new SetTree$00601(0, \"SetEmpty\"), false, t$$2];\n        }\n      }\n\n    case 0:\n      {\n        return [new SetTree$00601(0, \"SetEmpty\"), false, new SetTree$00601(0, \"SetEmpty\")];\n      }\n\n    default:\n      {\n        const c$$2 = comparer$$2.Compare(pivot, t$$2.fields[0]) | 0;\n\n        if (c$$2 < 0) {\n          const patternInput = SetTreeModule$$$split(comparer$$2, pivot, t$$2.fields[1]);\n          return [patternInput[0], patternInput[1], SetTreeModule$$$balance(comparer$$2, patternInput[2], t$$2.fields[0], t$$2.fields[2])];\n        } else if (c$$2 === 0) {\n          return [t$$2.fields[1], true, t$$2.fields[2]];\n        } else {\n          const patternInput$$1 = SetTreeModule$$$split(comparer$$2, pivot, t$$2.fields[2]);\n          return [SetTreeModule$$$balance(comparer$$2, t$$2.fields[1], t$$2.fields[0], patternInput$$1[0]), patternInput$$1[1], patternInput$$1[2]];\n        }\n      }\n  }\n}\nexport function SetTreeModule$$$spliceOutSuccessor(t$$3) {\n  switch (t$$3.tag) {\n    case 2:\n      {\n        return [t$$3.fields[0], new SetTree$00601(0, \"SetEmpty\")];\n      }\n\n    case 1:\n      {\n        if (t$$3.fields[1].tag === 0) {\n          return [t$$3.fields[0], t$$3.fields[2]];\n        } else {\n          const patternInput$$2 = SetTreeModule$$$spliceOutSuccessor(t$$3.fields[1]);\n          return [patternInput$$2[0], SetTreeModule$$$mk(patternInput$$2[1], t$$3.fields[0], t$$3.fields[2])];\n        }\n      }\n\n    default:\n      {\n        throw new Error(\"internal error: Set.spliceOutSuccessor\");\n      }\n  }\n}\nexport function SetTreeModule$$$remove(comparer$$3, k$$4, t$$4) {\n  switch (t$$4.tag) {\n    case 2:\n      {\n        const c$$4 = comparer$$3.Compare(k$$4, t$$4.fields[0]) | 0;\n\n        if (c$$4 === 0) {\n          return new SetTree$00601(0, \"SetEmpty\");\n        } else {\n          return t$$4;\n        }\n      }\n\n    case 1:\n      {\n        const c$$5 = comparer$$3.Compare(k$$4, t$$4.fields[0]) | 0;\n\n        if (c$$5 < 0) {\n          return SetTreeModule$$$rebalance(SetTreeModule$$$remove(comparer$$3, k$$4, t$$4.fields[1]), t$$4.fields[0], t$$4.fields[2]);\n        } else if (c$$5 === 0) {\n          if (t$$4.fields[1].tag === 0) {\n            return t$$4.fields[2];\n          } else if (t$$4.fields[2].tag === 0) {\n            return t$$4.fields[1];\n          } else {\n            const patternInput$$3 = SetTreeModule$$$spliceOutSuccessor(t$$4.fields[2]);\n            return SetTreeModule$$$mk(t$$4.fields[1], patternInput$$3[0], patternInput$$3[1]);\n          }\n        } else {\n          return SetTreeModule$$$rebalance(t$$4.fields[1], t$$4.fields[0], SetTreeModule$$$remove(comparer$$3, k$$4, t$$4.fields[2]));\n        }\n      }\n\n    default:\n      {\n        return t$$4;\n      }\n  }\n}\nexport function SetTreeModule$$$mem($comparer$$4$$35, $k$$5$$36, $t$$5$$37) {\n  SetTreeModule$$$mem: while (true) {\n    const comparer$$4 = $comparer$$4$$35,\n          k$$5 = $k$$5$$36,\n          t$$5 = $t$$5$$37;\n\n    switch (t$$5.tag) {\n      case 2:\n        {\n          return comparer$$4.Compare(k$$5, t$$5.fields[0]) === 0;\n        }\n\n      case 0:\n        {\n          return false;\n        }\n\n      default:\n        {\n          const c$$6 = comparer$$4.Compare(k$$5, t$$5.fields[0]) | 0;\n\n          if (c$$6 < 0) {\n            $comparer$$4$$35 = comparer$$4;\n            $k$$5$$36 = k$$5;\n            $t$$5$$37 = t$$5.fields[1];\n            continue SetTreeModule$$$mem;\n          } else if (c$$6 === 0) {\n            return true;\n          } else {\n            $comparer$$4$$35 = comparer$$4;\n            $k$$5$$36 = k$$5;\n            $t$$5$$37 = t$$5.fields[2];\n            continue SetTreeModule$$$mem;\n          }\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$iter($f$$38, $t$$6$$39) {\n  SetTreeModule$$$iter: while (true) {\n    const f = $f$$38,\n          t$$6 = $t$$6$$39;\n\n    switch (t$$6.tag) {\n      case 2:\n        {\n          f(t$$6.fields[0]);\n          break;\n        }\n\n      case 0:\n        {\n          void null;\n          break;\n        }\n\n      default:\n        {\n          SetTreeModule$$$iter(f, t$$6.fields[1]);\n          f(t$$6.fields[0]);\n          $f$$38 = f;\n          $t$$6$$39 = t$$6.fields[2];\n          continue SetTreeModule$$$iter;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$foldBack($f$$1$$40, $m$$1$$41, $x$$1$$42) {\n  SetTreeModule$$$foldBack: while (true) {\n    const f$$1 = $f$$1$$40,\n          m$$1 = $m$$1$$41,\n          x$$1 = $x$$1$$42;\n\n    switch (m$$1.tag) {\n      case 2:\n        {\n          return f$$1(m$$1.fields[0], x$$1);\n        }\n\n      case 0:\n        {\n          return x$$1;\n        }\n\n      default:\n        {\n          $f$$1$$40 = f$$1;\n          $m$$1$$41 = m$$1.fields[1];\n          $x$$1$$42 = f$$1(m$$1.fields[0], SetTreeModule$$$foldBack(f$$1, m$$1.fields[2], x$$1));\n          continue SetTreeModule$$$foldBack;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$fold($f$$2$$43, $x$$2$$44, $m$$2$$45) {\n  SetTreeModule$$$fold: while (true) {\n    const f$$2 = $f$$2$$43,\n          x$$2 = $x$$2$$44,\n          m$$2 = $m$$2$$45;\n\n    switch (m$$2.tag) {\n      case 2:\n        {\n          return f$$2(x$$2, m$$2.fields[0]);\n        }\n\n      case 0:\n        {\n          return x$$2;\n        }\n\n      default:\n        {\n          const x$$3 = SetTreeModule$$$fold(f$$2, x$$2, m$$2.fields[1]);\n          const x$$4 = f$$2(x$$3, m$$2.fields[0]);\n          $f$$2$$43 = f$$2;\n          $x$$2$$44 = x$$4;\n          $m$$2$$45 = m$$2.fields[2];\n          continue SetTreeModule$$$fold;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$forall($f$$3$$46, $m$$3$$47) {\n  SetTreeModule$$$forall: while (true) {\n    const f$$3 = $f$$3$$46,\n          m$$3 = $m$$3$$47;\n\n    switch (m$$3.tag) {\n      case 2:\n        {\n          return f$$3(m$$3.fields[0]);\n        }\n\n      case 0:\n        {\n          return true;\n        }\n\n      default:\n        {\n          if (f$$3(m$$3.fields[0]) ? SetTreeModule$$$forall(f$$3, m$$3.fields[1]) : false) {\n            $f$$3$$46 = f$$3;\n            $m$$3$$47 = m$$3.fields[2];\n            continue SetTreeModule$$$forall;\n          } else {\n            return false;\n          }\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$exists($f$$4$$48, $m$$4$$49) {\n  SetTreeModule$$$exists: while (true) {\n    const f$$4 = $f$$4$$48,\n          m$$4 = $m$$4$$49;\n\n    switch (m$$4.tag) {\n      case 2:\n        {\n          return f$$4(m$$4.fields[0]);\n        }\n\n      case 0:\n        {\n          return false;\n        }\n\n      default:\n        {\n          if (f$$4(m$$4.fields[0]) ? true : SetTreeModule$$$exists(f$$4, m$$4.fields[1])) {\n            return true;\n          } else {\n            $f$$4$$48 = f$$4;\n            $m$$4$$49 = m$$4.fields[2];\n            continue SetTreeModule$$$exists;\n          }\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$isEmpty(m$$5) {\n  if (m$$5.tag === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function SetTreeModule$$$subset(comparer$$5, a, b) {\n  return SetTreeModule$$$forall(function (x$$5) {\n    return SetTreeModule$$$mem(comparer$$5, x$$5, b);\n  }, a);\n}\nexport function SetTreeModule$$$psubset(comparer$$6, a$$1, b$$1) {\n  if (SetTreeModule$$$forall(function (x$$6) {\n    return SetTreeModule$$$mem(comparer$$6, x$$6, b$$1);\n  }, a$$1)) {\n    return SetTreeModule$$$exists(function (x$$7) {\n      return !SetTreeModule$$$mem(comparer$$6, x$$7, a$$1);\n    }, b$$1);\n  } else {\n    return false;\n  }\n}\nexport function SetTreeModule$$$filterAux($comparer$$7$$57, $f$$5$$58, $s$$2$$59, $acc$$1$$60) {\n  SetTreeModule$$$filterAux: while (true) {\n    const comparer$$7 = $comparer$$7$$57,\n          f$$5 = $f$$5$$58,\n          s$$2 = $s$$2$$59,\n          acc$$1 = $acc$$1$$60;\n\n    switch (s$$2.tag) {\n      case 2:\n        {\n          if (f$$5(s$$2.fields[0])) {\n            return SetTreeModule$$$add(comparer$$7, s$$2.fields[0], acc$$1);\n          } else {\n            return acc$$1;\n          }\n        }\n\n      case 0:\n        {\n          return acc$$1;\n        }\n\n      default:\n        {\n          const acc$$2 = f$$5(s$$2.fields[0]) ? SetTreeModule$$$add(comparer$$7, s$$2.fields[0], acc$$1) : acc$$1;\n          $comparer$$7$$57 = comparer$$7;\n          $f$$5$$58 = f$$5;\n          $s$$2$$59 = s$$2.fields[1];\n          $acc$$1$$60 = SetTreeModule$$$filterAux(comparer$$7, f$$5, s$$2.fields[2], acc$$2);\n          continue SetTreeModule$$$filterAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$filter(comparer$$8, f$$6, s$$3) {\n  return SetTreeModule$$$filterAux(comparer$$8, f$$6, s$$3, new SetTree$00601(0, \"SetEmpty\"));\n}\nexport function SetTreeModule$$$diffAux($comparer$$9$$64, $m$$6$$65, $acc$$3$$66) {\n  SetTreeModule$$$diffAux: while (true) {\n    const comparer$$9 = $comparer$$9$$64,\n          m$$6 = $m$$6$$65,\n          acc$$3 = $acc$$3$$66;\n\n    switch (m$$6.tag) {\n      case 2:\n        {\n          return SetTreeModule$$$remove(comparer$$9, m$$6.fields[0], acc$$3);\n        }\n\n      case 0:\n        {\n          return acc$$3;\n        }\n\n      default:\n        {\n          $comparer$$9$$64 = comparer$$9;\n          $m$$6$$65 = m$$6.fields[1];\n          $acc$$3$$66 = SetTreeModule$$$diffAux(comparer$$9, m$$6.fields[2], SetTreeModule$$$remove(comparer$$9, m$$6.fields[0], acc$$3));\n          continue SetTreeModule$$$diffAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$diff(comparer$$10, a$$2, b$$2) {\n  return SetTreeModule$$$diffAux(comparer$$10, b$$2, a$$2);\n}\nexport function SetTreeModule$$$union(comparer$$11, t1$$4, t2$$4) {\n  var $target$$73, h1$$1, h2$$1, k1$$4, k2$$16, t11$$2, t12$$2, t21$$1, t22$$1, t$$7, t$$8, k1$$5, t2$$5, k2$$17, t1$$5;\n\n  if (t1$$4.tag === 0) {\n    $target$$73 = 1;\n    t$$7 = t2$$4;\n  } else if (t1$$4.tag === 2) {\n    if (t2$$4.tag === 0) {\n      $target$$73 = 2;\n      t$$8 = t1$$4;\n    } else if (t2$$4.tag === 2) {\n      $target$$73 = 3;\n      k1$$5 = t1$$4.fields[0];\n      t2$$5 = t2$$4;\n    } else {\n      $target$$73 = 3;\n      k1$$5 = t1$$4.fields[0];\n      t2$$5 = t2$$4;\n    }\n  } else if (t2$$4.tag === 0) {\n    $target$$73 = 2;\n    t$$8 = t1$$4;\n  } else if (t2$$4.tag === 2) {\n    $target$$73 = 4;\n    k2$$17 = t2$$4.fields[0];\n    t1$$5 = t1$$4;\n  } else {\n    $target$$73 = 0;\n    h1$$1 = t1$$4.fields[3];\n    h2$$1 = t2$$4.fields[3];\n    k1$$4 = t1$$4.fields[0];\n    k2$$16 = t2$$4.fields[0];\n    t11$$2 = t1$$4.fields[1];\n    t12$$2 = t1$$4.fields[2];\n    t21$$1 = t2$$4.fields[1];\n    t22$$1 = t2$$4.fields[2];\n  }\n\n  switch ($target$$73) {\n    case 0:\n      {\n        if (h1$$1 > h2$$1) {\n          const patternInput$$4 = SetTreeModule$$$split(comparer$$11, k1$$4, t2$$4);\n          return SetTreeModule$$$balance(comparer$$11, SetTreeModule$$$union(comparer$$11, t11$$2, patternInput$$4[0]), k1$$4, SetTreeModule$$$union(comparer$$11, t12$$2, patternInput$$4[2]));\n        } else {\n          const patternInput$$5 = SetTreeModule$$$split(comparer$$11, k2$$16, t1$$4);\n          return SetTreeModule$$$balance(comparer$$11, SetTreeModule$$$union(comparer$$11, t21$$1, patternInput$$5[0]), k2$$16, SetTreeModule$$$union(comparer$$11, t22$$1, patternInput$$5[2]));\n        }\n      }\n\n    case 1:\n      {\n        return t$$7;\n      }\n\n    case 2:\n      {\n        return t$$8;\n      }\n\n    case 3:\n      {\n        return SetTreeModule$$$add(comparer$$11, k1$$5, t2$$5);\n      }\n\n    case 4:\n      {\n        return SetTreeModule$$$add(comparer$$11, k2$$17, t1$$5);\n      }\n  }\n}\nexport function SetTreeModule$$$intersectionAux($comparer$$12$$74, $b$$3$$75, $m$$7$$76, $acc$$4$$77) {\n  SetTreeModule$$$intersectionAux: while (true) {\n    const comparer$$12 = $comparer$$12$$74,\n          b$$3 = $b$$3$$75,\n          m$$7 = $m$$7$$76,\n          acc$$4 = $acc$$4$$77;\n\n    switch (m$$7.tag) {\n      case 2:\n        {\n          if (SetTreeModule$$$mem(comparer$$12, m$$7.fields[0], b$$3)) {\n            return SetTreeModule$$$add(comparer$$12, m$$7.fields[0], acc$$4);\n          } else {\n            return acc$$4;\n          }\n        }\n\n      case 0:\n        {\n          return acc$$4;\n        }\n\n      default:\n        {\n          const acc$$5 = SetTreeModule$$$intersectionAux(comparer$$12, b$$3, m$$7.fields[2], acc$$4);\n          const acc$$6 = SetTreeModule$$$mem(comparer$$12, m$$7.fields[0], b$$3) ? SetTreeModule$$$add(comparer$$12, m$$7.fields[0], acc$$5) : acc$$5;\n          $comparer$$12$$74 = comparer$$12;\n          $b$$3$$75 = b$$3;\n          $m$$7$$76 = m$$7.fields[1];\n          $acc$$4$$77 = acc$$6;\n          continue SetTreeModule$$$intersectionAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$intersection(comparer$$13, a$$3, b$$4) {\n  return SetTreeModule$$$intersectionAux(comparer$$13, b$$4, a$$3, new SetTree$00601(0, \"SetEmpty\"));\n}\nexport function SetTreeModule$$$partition1(comparer$$14, f$$7, k$$16, acc1, acc2) {\n  if (f$$7(k$$16)) {\n    return [SetTreeModule$$$add(comparer$$14, k$$16, acc1), acc2];\n  } else {\n    return [acc1, SetTreeModule$$$add(comparer$$14, k$$16, acc2)];\n  }\n}\nexport function SetTreeModule$$$partitionAux($comparer$$15$$86, $f$$8$$87, $s$$4$$88, $acc_0$$89, $acc_1$$90) {\n  SetTreeModule$$$partitionAux: while (true) {\n    const comparer$$15 = $comparer$$15$$86,\n          f$$8 = $f$$8$$87,\n          s$$4 = $s$$4$$88,\n          acc_0 = $acc_0$$89,\n          acc_1 = $acc_1$$90;\n\n    switch (s$$4.tag) {\n      case 2:\n        {\n          return SetTreeModule$$$partition1(comparer$$15, f$$8, s$$4.fields[0], acc_0, acc_1);\n        }\n\n      case 0:\n        {\n          return [acc_0, acc_1];\n        }\n\n      default:\n        {\n          const acc$$8 = SetTreeModule$$$partitionAux(comparer$$15, f$$8, s$$4.fields[2], acc_0, acc_1);\n          const acc$$9 = SetTreeModule$$$partition1(comparer$$15, f$$8, s$$4.fields[0], acc$$8[0], acc$$8[1]);\n          $comparer$$15$$86 = comparer$$15;\n          $f$$8$$87 = f$$8;\n          $s$$4$$88 = s$$4.fields[1];\n          $acc_0$$89 = acc$$9[0];\n          $acc_1$$90 = acc$$9[1];\n          continue SetTreeModule$$$partitionAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$partition(comparer$$16, f$$9, s$$5) {\n  const seed = [new SetTree$00601(0, \"SetEmpty\"), new SetTree$00601(0, \"SetEmpty\")];\n  return SetTreeModule$$$partitionAux(comparer$$16, f$$9, s$$5, seed[0], seed[1]);\n}\nexport function SetTreeModule$$$$007CMatchSetNode$007CMatchSetEmpty$007C(s$$6) {\n  switch (s$$6.tag) {\n    case 2:\n      {\n        return new Choice(0, \"Choice1Of2\", [s$$6.fields[0], new SetTree$00601(0, \"SetEmpty\"), new SetTree$00601(0, \"SetEmpty\")]);\n      }\n\n    case 0:\n      {\n        return new Choice(1, \"Choice2Of2\", void null);\n      }\n\n    default:\n      {\n        return new Choice(0, \"Choice1Of2\", [s$$6.fields[0], s$$6.fields[1], s$$6.fields[2]]);\n      }\n  }\n}\nexport function SetTreeModule$$$minimumElementAux($s$$7$$95, $n$$1$$96) {\n  SetTreeModule$$$minimumElementAux: while (true) {\n    const s$$7 = $s$$7$$95,\n          n$$1 = $n$$1$$96;\n\n    switch (s$$7.tag) {\n      case 2:\n        {\n          return s$$7.fields[0];\n        }\n\n      case 0:\n        {\n          return n$$1;\n        }\n\n      default:\n        {\n          $s$$7$$95 = s$$7.fields[1];\n          $n$$1$$96 = s$$7.fields[0];\n          continue SetTreeModule$$$minimumElementAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$minimumElementOpt(s$$8) {\n  switch (s$$8.tag) {\n    case 2:\n      {\n        return some(s$$8.fields[0]);\n      }\n\n    case 0:\n      {\n        return undefined;\n      }\n\n    default:\n      {\n        return some(SetTreeModule$$$minimumElementAux(s$$8.fields[1], s$$8.fields[0]));\n      }\n  }\n}\nexport function SetTreeModule$$$maximumElementAux($s$$9$$98, $n$$2$$99) {\n  SetTreeModule$$$maximumElementAux: while (true) {\n    const s$$9 = $s$$9$$98,\n          n$$2 = $n$$2$$99;\n\n    switch (s$$9.tag) {\n      case 2:\n        {\n          return s$$9.fields[0];\n        }\n\n      case 0:\n        {\n          return n$$2;\n        }\n\n      default:\n        {\n          $s$$9$$98 = s$$9.fields[2];\n          $n$$2$$99 = s$$9.fields[0];\n          continue SetTreeModule$$$maximumElementAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$maximumElementOpt(s$$10) {\n  switch (s$$10.tag) {\n    case 2:\n      {\n        return some(s$$10.fields[0]);\n      }\n\n    case 0:\n      {\n        return undefined;\n      }\n\n    default:\n      {\n        return some(SetTreeModule$$$maximumElementAux(s$$10.fields[2], s$$10.fields[0]));\n      }\n  }\n}\nexport function SetTreeModule$$$minimumElement(s$$11) {\n  const matchValue$$4 = SetTreeModule$$$minimumElementOpt(s$$11);\n\n  if (matchValue$$4 == null) {\n    throw new Error(\"Set contains no elements\");\n  } else {\n    const k$$27 = value$$2(matchValue$$4);\n    return k$$27;\n  }\n}\nexport function SetTreeModule$$$maximumElement(s$$12) {\n  const matchValue$$5 = SetTreeModule$$$maximumElementOpt(s$$12);\n\n  if (matchValue$$5 == null) {\n    throw new Error(\"Set contains no elements\");\n  } else {\n    const k$$28 = value$$2(matchValue$$5);\n    return k$$28;\n  }\n}\nexport const SetTreeModule$002ESetIterator$00601 = declare(function Set_SetTreeModule_SetIterator(stack, started) {\n  this.stack = stack;\n  this.started = started;\n}, Record);\nexport function SetTreeModule$002ESetIterator$00601$reflection($gen$$103) {\n  return record_type(\"Set.SetTreeModule.SetIterator`1\", [$gen$$103], SetTreeModule$002ESetIterator$00601, () => [[\"stack\", list_type(SetTree$00601$reflection($gen$$103))], [\"started\", bool_type]]);\n}\nexport function SetTreeModule$$$collapseLHS($stack$$104) {\n  SetTreeModule$$$collapseLHS: while (true) {\n    const stack = $stack$$104;\n\n    if (stack.tail != null) {\n      if (stack.head.tag === 2) {\n        return stack;\n      } else if (stack.head.tag === 1) {\n        $stack$$104 = new List(stack.head.fields[1], new List(SetTreeModule$$$SetOne(stack.head.fields[0]), new List(stack.head.fields[2], stack.tail)));\n        continue SetTreeModule$$$collapseLHS;\n      } else {\n        $stack$$104 = stack.tail;\n        continue SetTreeModule$$$collapseLHS;\n      }\n    } else {\n      return new List();\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$mkIterator(s$$13) {\n  return new SetTreeModule$002ESetIterator$00601(SetTreeModule$$$collapseLHS(new List(s$$13, new List())), false);\n}\nexport function SetTreeModule$$$notStarted() {\n  throw new Error(\"Enumeration not started\");\n}\nexport function SetTreeModule$$$alreadyFinished() {\n  throw new Error(\"Enumeration already started\");\n}\nexport function SetTreeModule$$$current(i) {\n  if (i.started) {\n    const matchValue$$6 = i.stack;\n\n    if (matchValue$$6.tail == null) {\n      return SetTreeModule$$$alreadyFinished();\n    } else if (matchValue$$6.head.tag === 2) {\n      return matchValue$$6.head.fields[0];\n    } else {\n      throw new Error(\"Please report error: Set iterator, unexpected stack for current\");\n    }\n  } else {\n    return SetTreeModule$$$notStarted();\n  }\n}\nexport function SetTreeModule$$$moveNext(i$$1) {\n  if (i$$1.started) {\n    const matchValue$$7 = i$$1.stack;\n\n    if (matchValue$$7.tail == null) {\n      return false;\n    } else if (matchValue$$7.head.tag === 2) {\n      i$$1.stack = SetTreeModule$$$collapseLHS(matchValue$$7.tail);\n      return !(i$$1.stack.tail == null);\n    } else {\n      throw new Error(\"Please report error: Set iterator, unexpected stack for moveNext\");\n    }\n  } else {\n    i$$1.started = true;\n    return !(i$$1.stack.tail == null);\n  }\n}\nexport const SetTreeModule$002EmkIEnumerator$00601 = declare(function Set_SetTreeModule_mkIEnumerator(s$$14) {\n  const $this$$1 = this;\n  $this$$1.s = s$$14;\n  $this$$1.i = SetTreeModule$$$mkIterator($this$$1.s);\n  void null;\n});\nexport function SetTreeModule$002EmkIEnumerator$00601$reflection($gen$$108) {\n  return class_type(\"Set.SetTreeModule.mkIEnumerator`1\", [$gen$$108], SetTreeModule$002EmkIEnumerator$00601);\n}\nexport function SetTreeModule$002EmkIEnumerator$00601$$$$002Ector$$Z5B395D56(s$$14) {\n  return this instanceof SetTreeModule$002EmkIEnumerator$00601 ? SetTreeModule$002EmkIEnumerator$00601.call(this, s$$14) : new SetTreeModule$002EmkIEnumerator$00601(s$$14);\n}\nObject.defineProperty(SetTreeModule$002EmkIEnumerator$00601.prototype, \"Current\", {\n  \"get\": function () {\n    const __ = this;\n    return SetTreeModule$$$current(__.i);\n  }\n});\n\nSetTreeModule$002EmkIEnumerator$00601.prototype.MoveNext = function () {\n  const __$$1 = this;\n  return SetTreeModule$$$moveNext(__$$1.i);\n};\n\nSetTreeModule$002EmkIEnumerator$00601.prototype.Reset = function () {\n  const __$$2 = this;\n  __$$2.i = SetTreeModule$$$mkIterator(__$$2.s);\n};\n\nSetTreeModule$002EmkIEnumerator$00601.prototype.Dispose = function () {\n  void null;\n};\n\nexport function SetTreeModule$$$mkIEnumerator(s$$15) {\n  return SetTreeModule$002EmkIEnumerator$00601$$$$002Ector$$Z5B395D56(s$$15);\n}\nexport function SetTreeModule$$$toSeq(s$$16) {\n  const en = SetTreeModule$$$mkIEnumerator(s$$16);\n  return unfold(function generator(en$$1) {\n    if (en$$1.MoveNext()) {\n      return [en$$1.Current, en$$1];\n    } else {\n      return undefined;\n    }\n  }, en);\n}\nexport function SetTreeModule$$$compareStacks($comparer$$17$$112, $l1$$113, $l2$$114) {\n  SetTreeModule$$$compareStacks: while (true) {\n    const comparer$$17 = $comparer$$17$$112,\n          l1 = $l1$$113,\n          l2 = $l2$$114;\n    var $target$$115, t1$$6, t2$$6, n1k, n2k, t1$$7, t2$$7, n1k$$1, n2k$$1, n2r, t1$$8, t2$$8, emp, n1k$$2, n1r, n2k$$2, t1$$9, t2$$9, n1k$$3, n1r$$1, n2k$$3, n2r$$1, t1$$10, t2$$10, n1k$$4, t1$$11, n1k$$5, n1l, n1r$$2, t1$$12, n2k$$4, t2$$11, n2k$$5, n2l, n2r$$2, t2$$12;\n\n    if (l1.tail != null) {\n      if (l2.tail != null) {\n        if (l2.head.tag === 2) {\n          if (l1.head.tag === 2) {\n            $target$$115 = 4;\n            n1k = l1.head.fields[0];\n            n2k = l2.head.fields[0];\n            t1$$7 = l1.tail;\n            t2$$7 = l2.tail;\n          } else if (l1.head.tag === 1) {\n            if (l1.head.fields[1].tag === 0) {\n              $target$$115 = 6;\n              emp = l1.head.fields[1];\n              n1k$$2 = l1.head.fields[0];\n              n1r = l1.head.fields[2];\n              n2k$$2 = l2.head.fields[0];\n              t1$$9 = l1.tail;\n              t2$$9 = l2.tail;\n            } else {\n              $target$$115 = 9;\n              n1k$$5 = l1.head.fields[0];\n              n1l = l1.head.fields[1];\n              n1r$$2 = l1.head.fields[2];\n              t1$$12 = l1.tail;\n            }\n          } else {\n            $target$$115 = 10;\n            n2k$$4 = l2.head.fields[0];\n            t2$$11 = l2.tail;\n          }\n        } else if (l2.head.tag === 1) {\n          if (l2.head.fields[1].tag === 0) {\n            if (l1.head.tag === 2) {\n              $target$$115 = 5;\n              n1k$$1 = l1.head.fields[0];\n              n2k$$1 = l2.head.fields[0];\n              n2r = l2.head.fields[2];\n              t1$$8 = l1.tail;\n              t2$$8 = l2.tail;\n            } else if (l1.head.tag === 1) {\n              if (l1.head.fields[1].tag === 0) {\n                $target$$115 = 7;\n                n1k$$3 = l1.head.fields[0];\n                n1r$$1 = l1.head.fields[2];\n                n2k$$3 = l2.head.fields[0];\n                n2r$$1 = l2.head.fields[2];\n                t1$$10 = l1.tail;\n                t2$$10 = l2.tail;\n              } else {\n                $target$$115 = 9;\n                n1k$$5 = l1.head.fields[0];\n                n1l = l1.head.fields[1];\n                n1r$$2 = l1.head.fields[2];\n                t1$$12 = l1.tail;\n              }\n            } else {\n              $target$$115 = 11;\n              n2k$$5 = l2.head.fields[0];\n              n2l = l2.head.fields[1];\n              n2r$$2 = l2.head.fields[2];\n              t2$$12 = l2.tail;\n            }\n          } else if (l1.head.tag === 2) {\n            $target$$115 = 8;\n            n1k$$4 = l1.head.fields[0];\n            t1$$11 = l1.tail;\n          } else if (l1.head.tag === 1) {\n            $target$$115 = 9;\n            n1k$$5 = l1.head.fields[0];\n            n1l = l1.head.fields[1];\n            n1r$$2 = l1.head.fields[2];\n            t1$$12 = l1.tail;\n          } else {\n            $target$$115 = 11;\n            n2k$$5 = l2.head.fields[0];\n            n2l = l2.head.fields[1];\n            n2r$$2 = l2.head.fields[2];\n            t2$$12 = l2.tail;\n          }\n        } else if (l1.head.tag === 2) {\n          $target$$115 = 8;\n          n1k$$4 = l1.head.fields[0];\n          t1$$11 = l1.tail;\n        } else if (l1.head.tag === 1) {\n          $target$$115 = 9;\n          n1k$$5 = l1.head.fields[0];\n          n1l = l1.head.fields[1];\n          n1r$$2 = l1.head.fields[2];\n          t1$$12 = l1.tail;\n        } else {\n          $target$$115 = 3;\n          t1$$6 = l1.tail;\n          t2$$6 = l2.tail;\n        }\n      } else {\n        $target$$115 = 2;\n      }\n    } else if (l2.tail != null) {\n      $target$$115 = 1;\n    } else {\n      $target$$115 = 0;\n    }\n\n    switch ($target$$115) {\n      case 0:\n        {\n          return 0;\n        }\n\n      case 1:\n        {\n          return -1 | 0;\n        }\n\n      case 2:\n        {\n          return 1;\n        }\n\n      case 3:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = t1$$6;\n          $l2$$114 = t2$$6;\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 4:\n        {\n          const c$$7 = comparer$$17.Compare(n1k, n2k) | 0;\n\n          if (c$$7 !== 0) {\n            return c$$7 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = t1$$7;\n            $l2$$114 = t2$$7;\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 5:\n        {\n          const c$$8 = comparer$$17.Compare(n1k$$1, n2k$$1) | 0;\n\n          if (c$$8 !== 0) {\n            return c$$8 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = new List(new SetTree$00601(0, \"SetEmpty\"), t1$$8);\n            $l2$$114 = new List(n2r, t2$$8);\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 6:\n        {\n          const c$$9 = comparer$$17.Compare(n1k$$2, n2k$$2) | 0;\n\n          if (c$$9 !== 0) {\n            return c$$9 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = new List(n1r, t1$$9);\n            $l2$$114 = new List(emp, t2$$9);\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 7:\n        {\n          const c$$10 = comparer$$17.Compare(n1k$$3, n2k$$3) | 0;\n\n          if (c$$10 !== 0) {\n            return c$$10 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = new List(n1r$$1, t1$$10);\n            $l2$$114 = new List(n2r$$1, t2$$10);\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 8:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = new List(new SetTree$00601(0, \"SetEmpty\"), new List(SetTreeModule$$$SetOne(n1k$$4), t1$$11));\n          $l2$$114 = l2;\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 9:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = new List(n1l, new List(SetTreeModule$$$SetNode(n1k$$5, new SetTree$00601(0, \"SetEmpty\"), n1r$$2, 0), t1$$12));\n          $l2$$114 = l2;\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 10:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = l1;\n          $l2$$114 = new List(new SetTree$00601(0, \"SetEmpty\"), new List(SetTreeModule$$$SetOne(n2k$$4), t2$$11));\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 11:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = l1;\n          $l2$$114 = new List(n2l, new List(SetTreeModule$$$SetNode(n2k$$5, new SetTree$00601(0, \"SetEmpty\"), n2r$$2, 0), t2$$12));\n          continue SetTreeModule$$$compareStacks;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$compare(comparer$$18, s1, s2) {\n  if (s1.tag === 0) {\n    if (s2.tag === 0) {\n      return 0;\n    } else {\n      return -1 | 0;\n    }\n  } else if (s2.tag === 0) {\n    return 1;\n  } else {\n    return SetTreeModule$$$compareStacks(comparer$$18, new List(s1, new List()), new List(s2, new List())) | 0;\n  }\n}\nexport function SetTreeModule$$$choose(s$$17) {\n  return SetTreeModule$$$minimumElement(s$$17);\n}\nexport function SetTreeModule$$$loop($m$$8$$120, $acc$$10$$121) {\n  SetTreeModule$$$loop: while (true) {\n    const m$$8 = $m$$8$$120,\n          acc$$10 = $acc$$10$$121;\n\n    switch (m$$8.tag) {\n      case 2:\n        {\n          return new List(m$$8.fields[0], acc$$10);\n        }\n\n      case 0:\n        {\n          return acc$$10;\n        }\n\n      default:\n        {\n          $m$$8$$120 = m$$8.fields[1];\n          $acc$$10$$121 = new List(m$$8.fields[0], SetTreeModule$$$loop(m$$8.fields[2], acc$$10));\n          continue SetTreeModule$$$loop;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$toList(s$$18) {\n  return SetTreeModule$$$loop(s$$18, new List());\n}\nexport function SetTreeModule$$$copyToArray(s$$19, arr, i$$2) {\n  let j = i$$2 | 0;\n  SetTreeModule$$$iter(function (x$$8) {\n    arr[j] = x$$8;\n    j = j + 1;\n  }, s$$19);\n}\nexport function SetTreeModule$$$mkFromEnumerator($comparer$$19$$126, $acc$$11$$127, $e$$128) {\n  SetTreeModule$$$mkFromEnumerator: while (true) {\n    const comparer$$19 = $comparer$$19$$126,\n          acc$$11 = $acc$$11$$127,\n          e = $e$$128;\n\n    if (e.MoveNext()) {\n      $comparer$$19$$126 = comparer$$19;\n      $acc$$11$$127 = SetTreeModule$$$add(comparer$$19, e.Current, acc$$11);\n      $e$$128 = e;\n      continue SetTreeModule$$$mkFromEnumerator;\n    } else {\n      return acc$$11;\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$ofSeq(comparer$$20, c$$11) {\n  const ie = getEnumerator(c$$11);\n\n  try {\n    return SetTreeModule$$$mkFromEnumerator(comparer$$20, new SetTree$00601(0, \"SetEmpty\"), ie);\n  } finally {\n    if (isDisposable(ie)) {\n      ie.Dispose();\n    } else {\n      void null;\n    }\n  }\n}\nexport function SetTreeModule$$$ofArray(comparer$$21, arr$$1) {\n  let acc$$12 = new SetTree$00601(0, \"SetEmpty\");\n\n  for (let i$$3 = 0; i$$3 <= arr$$1.length - 1; i$$3++) {\n    acc$$12 = SetTreeModule$$$add(comparer$$21, arr$$1[i$$3], acc$$12);\n  }\n\n  return acc$$12;\n}\nexport const FSharpSet = declare(function Set_Set(comparer$$22, tree) {\n  const $this$$2 = this;\n  $this$$2.comparer = comparer$$22;\n  $this$$2.tree = tree;\n  void null;\n});\nexport function FSharpSet$reflection($gen$$133) {\n  return class_type(\"Set.FSharpSet\", [$gen$$133], FSharpSet);\n}\nexport function FSharpSet$$$$002Ector$$2528C5CB(comparer$$22, tree) {\n  return this instanceof FSharpSet ? FSharpSet.call(this, comparer$$22, tree) : new FSharpSet(comparer$$22, tree);\n}\nexport function FSharpSet$$get_Comparer(__$$4) {\n  return __$$4.comparer;\n}\nexport function FSharpSet$$get_Tree(__$$5) {\n  return __$$5.tree;\n}\nexport function FSharpSet$$Add$$2B595(s$$20, x$$9) {\n  return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$20), SetTreeModule$$$add(FSharpSet$$get_Comparer(s$$20), x$$9, FSharpSet$$get_Tree(s$$20)));\n}\nexport function FSharpSet$$Remove$$2B595(s$$21, x$$10) {\n  return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$21), SetTreeModule$$$remove(FSharpSet$$get_Comparer(s$$21), x$$10, FSharpSet$$get_Tree(s$$21)));\n}\nexport function FSharpSet$$get_Count(s$$22) {\n  return SetTreeModule$$$count(FSharpSet$$get_Tree(s$$22));\n}\nexport function FSharpSet$$Contains$$2B595(s$$23, x$$11) {\n  return SetTreeModule$$$mem(FSharpSet$$get_Comparer(s$$23), x$$11, FSharpSet$$get_Tree(s$$23));\n}\nexport function FSharpSet$$Iterate$$5028453F(s$$24, x$$12) {\n  SetTreeModule$$$iter(x$$12, FSharpSet$$get_Tree(s$$24));\n}\nexport function FSharpSet$$Fold(s$$25, f$$10, z) {\n  return SetTreeModule$$$fold(function (x$$13, z$$1) {\n    return f$$10(z$$1, x$$13);\n  }, z, FSharpSet$$get_Tree(s$$25));\n}\nexport function FSharpSet$$get_IsEmpty(s$$26) {\n  return SetTreeModule$$$isEmpty(FSharpSet$$get_Tree(s$$26));\n}\nexport function FSharpSet$$Partition$$Z1D55A0D7(s$$27, f$$11) {\n  const matchValue$$10 = FSharpSet$$get_Tree(s$$27);\n\n  if (matchValue$$10.tag === 0) {\n    return [s$$27, s$$27];\n  } else {\n    const patternInput$$6 = SetTreeModule$$$partition(FSharpSet$$get_Comparer(s$$27), f$$11, FSharpSet$$get_Tree(s$$27));\n    return [FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$27), patternInput$$6[0]), FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$27), patternInput$$6[1])];\n  }\n}\nexport function FSharpSet$$Filter$$Z1D55A0D7(s$$28, f$$12) {\n  const matchValue$$11 = FSharpSet$$get_Tree(s$$28);\n\n  if (matchValue$$11.tag === 0) {\n    return s$$28;\n  } else {\n    return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$28), SetTreeModule$$$filter(FSharpSet$$get_Comparer(s$$28), f$$12, FSharpSet$$get_Tree(s$$28)));\n  }\n}\nexport function FSharpSet$$Map$$7597B8F7(s$$29, f$$13, comparer$$23) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$23, SetTreeModule$$$fold(function (acc$$13, k$$33) {\n    return SetTreeModule$$$add(comparer$$23, f$$13(k$$33), acc$$13);\n  }, new SetTree$00601(0, \"SetEmpty\"), FSharpSet$$get_Tree(s$$29)));\n}\nexport function FSharpSet$$Exists$$Z1D55A0D7(s$$30, f$$14) {\n  return SetTreeModule$$$exists(f$$14, FSharpSet$$get_Tree(s$$30));\n}\nexport function FSharpSet$$ForAll$$Z1D55A0D7(s$$31, f$$15) {\n  return SetTreeModule$$$forall(f$$15, FSharpSet$$get_Tree(s$$31));\n}\nexport function FSharpSet$$$op_Subtraction(a$$4, b$$5) {\n  const matchValue$$12 = FSharpSet$$get_Tree(a$$4);\n\n  if (matchValue$$12.tag === 0) {\n    return a$$4;\n  } else {\n    const matchValue$$13 = FSharpSet$$get_Tree(b$$5);\n\n    if (matchValue$$13.tag === 0) {\n      return a$$4;\n    } else {\n      return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(a$$4), SetTreeModule$$$diff(FSharpSet$$get_Comparer(a$$4), FSharpSet$$get_Tree(a$$4), FSharpSet$$get_Tree(b$$5)));\n    }\n  }\n}\nexport function FSharpSet$$$op_Addition(a$$5, b$$6) {\n  const matchValue$$14 = FSharpSet$$get_Tree(b$$6);\n\n  if (matchValue$$14.tag === 0) {\n    return a$$5;\n  } else {\n    const matchValue$$15 = FSharpSet$$get_Tree(a$$5);\n\n    if (matchValue$$15.tag === 0) {\n      return b$$6;\n    } else {\n      return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(a$$5), SetTreeModule$$$union(FSharpSet$$get_Comparer(a$$5), FSharpSet$$get_Tree(a$$5), FSharpSet$$get_Tree(b$$6)));\n    }\n  }\n}\nexport function FSharpSet$$$Intersection$$Z3BE9BFE0(a$$6, b$$7) {\n  const matchValue$$16 = FSharpSet$$get_Tree(b$$7);\n\n  if (matchValue$$16.tag === 0) {\n    return b$$7;\n  } else {\n    const matchValue$$17 = FSharpSet$$get_Tree(a$$6);\n\n    if (matchValue$$17.tag === 0) {\n      return a$$6;\n    } else {\n      return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(a$$6), SetTreeModule$$$intersection(FSharpSet$$get_Comparer(a$$6), FSharpSet$$get_Tree(a$$6), FSharpSet$$get_Tree(b$$7)));\n    }\n  }\n}\nexport function FSharpSet$$$IntersectionMany$$Z15B59630(sets) {\n  return reduce(FSharpSet$$$Intersection$$Z3BE9BFE0, sets);\n}\nexport function FSharpSet$$$Equality$$Z3BE9BFE0(a$$7, b$$8) {\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(a$$7), FSharpSet$$get_Tree(a$$7), FSharpSet$$get_Tree(b$$8)) === 0;\n}\nexport function FSharpSet$$$Compare$$Z3BE9BFE0(a$$8, b$$9) {\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(a$$8), FSharpSet$$get_Tree(a$$8), FSharpSet$$get_Tree(b$$9));\n}\nexport function FSharpSet$$get_Choose(x$$14) {\n  return SetTreeModule$$$choose(FSharpSet$$get_Tree(x$$14));\n}\nexport function FSharpSet$$get_MinimumElement(x$$15) {\n  return SetTreeModule$$$minimumElement(FSharpSet$$get_Tree(x$$15));\n}\nexport function FSharpSet$$get_MaximumElement(x$$16) {\n  return SetTreeModule$$$maximumElement(FSharpSet$$get_Tree(x$$16));\n}\nexport function FSharpSet$$IsSubsetOf$$6A20B1FF(x$$17, y) {\n  return SetTreeModule$$$subset(FSharpSet$$get_Comparer(x$$17), FSharpSet$$get_Tree(x$$17), FSharpSet$$get_Tree(y));\n}\nexport function FSharpSet$$IsSupersetOf$$6A20B1FF(x$$18, y$$1) {\n  return SetTreeModule$$$subset(FSharpSet$$get_Comparer(x$$18), FSharpSet$$get_Tree(y$$1), FSharpSet$$get_Tree(x$$18));\n}\nexport function FSharpSet$$IsProperSubsetOf$$6A20B1FF(x$$19, y$$2) {\n  return SetTreeModule$$$psubset(FSharpSet$$get_Comparer(x$$19), FSharpSet$$get_Tree(x$$19), FSharpSet$$get_Tree(y$$2));\n}\nexport function FSharpSet$$IsProperSupersetOf$$6A20B1FF(x$$20, y$$3) {\n  return SetTreeModule$$$psubset(FSharpSet$$get_Comparer(x$$20), FSharpSet$$get_Tree(y$$3), FSharpSet$$get_Tree(x$$20));\n}\n\nFSharpSet.prototype.toString = function () {\n  var strings;\n  const this$ = this;\n  return \"set [\" + (strings = map$$1(function (x$$21) {\n    let copyOfStruct = x$$21;\n    return String(copyOfStruct);\n  }, this$), (join(\"; \", strings))) + \"]\";\n};\n\nFSharpSet.prototype.GetHashCode = function () {\n  const this$$$1 = this;\n  let res = 0;\n  const e$$1 = SetTreeModule$$$mkIEnumerator(FSharpSet$$get_Tree(this$$$1));\n\n  while (e$$1.MoveNext()) {\n    const x$$22 = res | 0;\n    const y$$4 = structuralHash(e$$1.Current) | 0;\n    res = (x$$22 << 1) + y$$4 + 631;\n  }\n\n  return Math.abs(res) | 0;\n};\n\nFSharpSet.prototype.Equals = function (that) {\n  const this$$$2 = this;\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(this$$$2), FSharpSet$$get_Tree(this$$$2), FSharpSet$$get_Tree(that)) === 0;\n};\n\nFSharpSet.prototype.CompareTo = function (that$$1) {\n  const this$$$3 = this;\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(this$$$3), FSharpSet$$get_Tree(this$$$3), FSharpSet$$get_Tree(that$$1)) | 0;\n};\n\nFSharpSet.prototype[Symbol.iterator] = function () {\n  const s$$32 = this;\n  return toIterator(SetTreeModule$$$mkIEnumerator(FSharpSet$$get_Tree(s$$32)));\n};\n\nexport function isEmpty(s$$33) {\n  return FSharpSet$$get_IsEmpty(s$$33);\n}\nexport function contains(x$$23, s$$34) {\n  return FSharpSet$$Contains$$2B595(s$$34, x$$23);\n}\nexport function add(x$$24, s$$35) {\n  return FSharpSet$$Add$$2B595(s$$35, x$$24);\n}\nexport function singleton(x$$25, comparer$$24) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$24, new SetTree$00601(2, \"SetOne\", x$$25));\n}\nexport function remove(x$$26, s$$36) {\n  return FSharpSet$$Remove$$2B595(s$$36, x$$26);\n}\nexport function union(s1$$2, s2$$2) {\n  return FSharpSet$$$op_Addition(s1$$2, s2$$2);\n}\nexport function unionMany(sets$$1, comparer$$25) {\n  return fold$$1(FSharpSet$$$op_Addition, FSharpSet$$$$002Ector$$2528C5CB(comparer$$25, new SetTree$00601(0, \"SetEmpty\")), sets$$1);\n}\nexport function intersect(s1$$3, s2$$3) {\n  return FSharpSet$$$Intersection$$Z3BE9BFE0(s1$$3, s2$$3);\n}\nexport function intersectMany(sets$$2) {\n  return FSharpSet$$$IntersectionMany$$Z15B59630(sets$$2);\n}\nexport function iterate(f$$16, s$$37) {\n  FSharpSet$$Iterate$$5028453F(s$$37, f$$16);\n}\nexport function empty(comparer$$26) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$26, new SetTree$00601(0, \"SetEmpty\"));\n}\nexport function forAll(f$$17, s$$38) {\n  return FSharpSet$$ForAll$$Z1D55A0D7(s$$38, f$$17);\n}\nexport function exists(f$$18, s$$39) {\n  return FSharpSet$$Exists$$Z1D55A0D7(s$$39, f$$18);\n}\nexport function filter(f$$19, s$$40) {\n  return FSharpSet$$Filter$$Z1D55A0D7(s$$40, f$$19);\n}\nexport function partition(f$$20, s$$41) {\n  return FSharpSet$$Partition$$Z1D55A0D7(s$$41, f$$20);\n}\nexport function fold(f$$21, z$$2, s$$42) {\n  return SetTreeModule$$$fold(f$$21, z$$2, FSharpSet$$get_Tree(s$$42));\n}\nexport function foldBack(f$$22, s$$43, z$$3) {\n  return SetTreeModule$$$foldBack(f$$22, FSharpSet$$get_Tree(s$$43), z$$3);\n}\nexport function map(f$$23, s$$44, comparer$$27) {\n  return FSharpSet$$Map$$7597B8F7(s$$44, f$$23, comparer$$27);\n}\nexport function count(s$$45) {\n  return FSharpSet$$get_Count(s$$45);\n}\nexport function minimumElement(s$$46) {\n  return FSharpSet$$get_MinimumElement(s$$46);\n}\nexport function maximumElement(s$$47) {\n  return FSharpSet$$get_MaximumElement(s$$47);\n}\nexport function ofList(li, comparer$$28) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$28, SetTreeModule$$$ofSeq(comparer$$28, li));\n}\nexport function ofArray(arr$$2, comparer$$29) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$29, SetTreeModule$$$ofArray(comparer$$29, arr$$2));\n}\nexport function toList(s$$48) {\n  return SetTreeModule$$$toList(FSharpSet$$get_Tree(s$$48));\n}\nexport function toArray(s$$49, cons) {\n  const n$$3 = count(s$$49) | 0;\n  const res$$1 = new cons(n$$3);\n  SetTreeModule$$$copyToArray(FSharpSet$$get_Tree(s$$49), res$$1, 0);\n  return res$$1;\n}\nexport function toSeq(s$$50) {\n  return SetTreeModule$$$toSeq(FSharpSet$$get_Tree(s$$50));\n}\nexport function ofSeq(elements, comparer$$30) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$30, SetTreeModule$$$ofSeq(comparer$$30, elements));\n}\nexport function difference(x$$28, y$$6) {\n  return FSharpSet$$$op_Subtraction(x$$28, y$$6);\n}\nexport function isSubset(x$$29, y$$7) {\n  return FSharpSet$$IsSubsetOf$$6A20B1FF(x$$29, y$$7);\n}\nexport function isSuperset(x$$30, y$$8) {\n  return FSharpSet$$IsSupersetOf$$6A20B1FF(x$$30, y$$8);\n}\nexport function isProperSubset(x$$31, y$$9) {\n  return FSharpSet$$IsProperSubsetOf$$6A20B1FF(x$$31, y$$9);\n}\nexport function isProperSuperset(x$$32, y$$10) {\n  return FSharpSet$$IsProperSupersetOf$$6A20B1FF(x$$32, y$$10);\n}\nexport function minElement(s$$51) {\n  return FSharpSet$$get_MinimumElement(s$$51);\n}\nexport function maxElement(s$$52) {\n  return FSharpSet$$get_MaximumElement(s$$52);\n}\nexport function createMutable(source, comparer$$31) {\n  const set = MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D(source, comparer$$31);\n  return set;\n}\nexport function distinct(xs, comparer$$32) {\n  return delay(function () {\n    const set$$1 = MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D(empty$$1(), comparer$$32);\n    return collect(function (x$$33) {\n      return MutableSet$002400601$0024$0024Add$0024$00242B595(set$$1, x$$33) ? singleton$$1(x$$33) : empty$$1();\n    }, xs);\n  });\n}\nexport function distinctBy(projection, xs$$1, comparer$$33) {\n  return delay(function () {\n    const set$$2 = MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D(empty$$1(), comparer$$33);\n    return collect(function (x$$34) {\n      return MutableSet$002400601$0024$0024Add$0024$00242B595(set$$2, projection(x$$34)) ? singleton$$1(x$$34) : empty$$1();\n    }, xs$$1);\n  });\n}\nexport function unionWith(s1$$4, s2$$4) {\n  return fold$$1(function folder(acc$$14, x$$35) {\n    return acc$$14.add(x$$35);\n  }, s1$$4, s2$$4);\n}\nexport function intersectWith(s1$$5, s2$$5, comparer$$34) {\n  const s2$$6 = ofSeq(s2$$5, comparer$$34);\n  iterate$$1(function (x$$36) {\n    if (!FSharpSet$$Contains$$2B595(s2$$6, x$$36)) {\n      const value = s1$$5.delete(x$$36);\n      void value;\n    } else {\n      void null;\n    }\n  }, s1$$5);\n}\nexport function exceptWith(s1$$6, s2$$7) {\n  iterate$$1(function (x$$37) {\n    const value$$1 = s1$$6.delete(x$$37);\n    void value$$1;\n  }, s2$$7);\n}\nexport function isSubsetOf(s1$$7, s2$$8, comparer$$35) {\n  return isSubset(ofSeq(s1$$7, comparer$$35), ofSeq(s2$$8, comparer$$35));\n}\nexport function isSupersetOf(s1$$8, s2$$9, comparer$$36) {\n  return isSuperset(ofSeq(s1$$8, comparer$$36), ofSeq(s2$$9, comparer$$36));\n}\nexport function isProperSubsetOf(s1$$9, s2$$10, comparer$$37) {\n  return isProperSubset(ofSeq(s1$$9, comparer$$37), ofSeq(s2$$10, comparer$$37));\n}\nexport function isProperSupersetOf(s1$$10, s2$$11, comparer$$38) {\n  return isProperSuperset(ofSeq(s1$$10, comparer$$38), ofSeq(s2$$11, comparer$$38));\n}","import { defaultArg, value as value$$15, some } from \"./Option.js\";\nimport { min as min$$1, compare, addToDict, addToSet, getItemFromDict, tryGetValue, max as max$$1, comparePrimitives } from \"./Util.js\";\nimport { createMutable } from \"./Map.js\";\nimport { createMutable as createMutable$$1 } from \"./Set.js\";\nimport { List } from \"./Types.js\";\nimport { iterate as iterate$$1 } from \"./Seq.js\";\nconst indexNotFoundMsg = \"An index satisfying the predicate was not found in the collection.\";\nexport function append(array1, array2, cons) {\n  if (ArrayBuffer.isView(array1)) {\n    const len1 = array1.length | 0;\n    const len2 = array2.length | 0;\n    const newArray = new cons(len1 + len2);\n\n    for (let i = 0; i <= len1 - 1; i++) {\n      newArray[i] = array1[i];\n    }\n\n    for (let i$$1 = 0; i$$1 <= len2 - 1; i$$1++) {\n      newArray[i$$1 + len1] = array2[i$$1];\n    }\n\n    return newArray;\n  } else {\n    return array1.concat(array2);\n  }\n}\nexport function filter(predicate, array) {\n  return array.filter(predicate);\n}\nexport function fill(target, targetIndex, count, value) {\n  target.fill(value, targetIndex, targetIndex + count);\n  return target;\n}\nexport function getSubArray(array$$3, start$$1, count$$2) {\n  return array$$3.slice(start$$1, start$$1 + count$$2);\n}\nexport function last(array$$5) {\n  if (array$$5.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  } else {\n    void null;\n  }\n\n  return array$$5[array$$5.length - 1];\n}\nexport function tryLast(array$$6) {\n  if (array$$6.length === 0) {\n    return undefined;\n  } else {\n    return some(array$$6[array$$6.length - 1]);\n  }\n}\nexport function mapIndexed(f, source, cons$$1) {\n  if (ArrayBuffer.isView(source)) {\n    const len = source.length | 0;\n    const target$$1 = new cons$$1(len);\n\n    for (let i$$2 = 0; i$$2 <= len - 1; i$$2++) {\n      target$$1[i$$2] = f(i$$2, source[i$$2]);\n    }\n\n    return target$$1;\n  } else {\n    return source.map(function (delegateArg0, delegateArg1) {\n      return f(delegateArg1, delegateArg0);\n    });\n  }\n}\nexport function map(f$$1, source$$1, cons$$2) {\n  if (ArrayBuffer.isView(source$$1)) {\n    const len$$1 = source$$1.length | 0;\n    const target$$2 = new cons$$2(len$$1);\n\n    for (let i$$4 = 0; i$$4 <= len$$1 - 1; i$$4++) {\n      target$$2[i$$4] = f$$1(source$$1[i$$4]);\n    }\n\n    return target$$2;\n  } else {\n    return source$$1.map(function mapping$$1(x$$1) {\n      return f$$1(x$$1);\n    });\n  }\n}\nexport function mapIndexed2(f$$2, source1, source2, cons$$3) {\n  if (source1.length !== source2.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  const result = new cons$$3(source1.length);\n\n  for (let i$$5 = 0; i$$5 <= source1.length - 1; i$$5++) {\n    result[i$$5] = f$$2(i$$5, source1[i$$5], source2[i$$5]);\n  }\n\n  return result;\n}\nexport function map2(f$$3, source1$$1, source2$$1, cons$$4) {\n  if (source1$$1.length !== source2$$1.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  const result$$1 = new cons$$4(source1$$1.length);\n\n  for (let i$$6 = 0; i$$6 <= source1$$1.length - 1; i$$6++) {\n    result$$1[i$$6] = f$$3(source1$$1[i$$6], source2$$1[i$$6]);\n  }\n\n  return result$$1;\n}\nexport function mapIndexed3(f$$4, source1$$2, source2$$2, source3, cons$$5) {\n  if (source1$$2.length !== source2$$2.length ? true : source2$$2.length !== source3.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  const result$$2 = new cons$$5(source1$$2.length);\n\n  for (let i$$7 = 0; i$$7 <= source1$$2.length - 1; i$$7++) {\n    result$$2[i$$7] = f$$4(i$$7, source1$$2[i$$7], source2$$2[i$$7], source3[i$$7]);\n  }\n\n  return result$$2;\n}\nexport function map3(f$$5, source1$$3, source2$$3, source3$$1, cons$$6) {\n  if (source1$$3.length !== source2$$3.length ? true : source2$$3.length !== source3$$1.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  const result$$3 = new cons$$6(source1$$3.length);\n\n  for (let i$$8 = 0; i$$8 <= source1$$3.length - 1; i$$8++) {\n    result$$3[i$$8] = f$$5(source1$$3[i$$8], source2$$3[i$$8], source3$$1[i$$8]);\n  }\n\n  return result$$3;\n}\nexport function mapFold(mapping$$2, state, array$$9, cons$$7) {\n  const matchValue = array$$9.length | 0;\n\n  if (matchValue === 0) {\n    return [[], state];\n  } else {\n    let acc = state;\n    const res = new cons$$7(matchValue);\n\n    for (let i$$9 = 0; i$$9 <= array$$9.length - 1; i$$9++) {\n      const patternInput = mapping$$2(acc, array$$9[i$$9]);\n      res[i$$9] = patternInput[0];\n      acc = patternInput[1];\n    }\n\n    return [res, acc];\n  }\n}\nexport function mapFoldBack(mapping$$3, array$$10, state$$1, cons$$8) {\n  const matchValue$$1 = array$$10.length | 0;\n\n  if (matchValue$$1 === 0) {\n    return [[], state$$1];\n  } else {\n    let acc$$1 = state$$1;\n    const res$$1 = new cons$$8(matchValue$$1);\n\n    for (let i$$10 = array$$10.length - 1; i$$10 >= 0; i$$10--) {\n      const patternInput$$1 = mapping$$3(array$$10[i$$10], acc$$1);\n      res$$1[i$$10] = patternInput$$1[0];\n      acc$$1 = patternInput$$1[1];\n    }\n\n    return [res$$1, acc$$1];\n  }\n}\nexport function indexed(source$$2) {\n  const len$$4 = source$$2.length | 0;\n  const target$$3 = new Array(len$$4);\n\n  for (let i$$11 = 0; i$$11 <= len$$4 - 1; i$$11++) {\n    target$$3[i$$11] = [i$$11, source$$2[i$$11]];\n  }\n\n  return target$$3;\n}\nexport function truncate(count$$4, array$$11) {\n  const count$$5 = max$$1(comparePrimitives, 0, count$$4) | 0;\n  return array$$11.slice(0, 0 + count$$5);\n}\nexport function concat(arrays, cons$$9) {\n  var arr$$4;\n  const arrays$$1 = Array.isArray(arrays) ? arrays : Array.from(arrays);\n  const matchValue$$2 = arrays$$1.length | 0;\n\n  switch (matchValue$$2) {\n    case 0:\n      {\n        return new cons$$9(0);\n      }\n\n    case 1:\n      {\n        return arrays$$1[0];\n      }\n\n    default:\n      {\n        if (arr$$4 = arrays$$1[0], ArrayBuffer.isView(arr$$4)) {\n          let totalIdx = 0;\n          let totalLength = 0;\n\n          for (let idx = 0; idx <= arrays$$1.length - 1; idx++) {\n            const arr$$5 = arrays$$1[idx];\n            totalLength = totalLength + arr$$5.length;\n          }\n\n          const result$$4 = new cons$$9(totalLength);\n\n          for (let idx$$1 = 0; idx$$1 <= arrays$$1.length - 1; idx$$1++) {\n            const arr$$6 = arrays$$1[idx$$1];\n\n            for (let j = 0; j <= arr$$6.length - 1; j++) {\n              result$$4[totalIdx] = arr$$6[j];\n              totalIdx = totalIdx + 1;\n            }\n          }\n\n          return result$$4;\n        } else {\n          return arrays$$1[0].concat(...arrays$$1.slice(1));\n        }\n      }\n  }\n}\nexport function collect(mapping$$4, array$$14, cons$$10) {\n  const mapped = map(mapping$$4, array$$14, Array);\n  return concat(mapped, cons$$10);\n}\nexport function countBy(projection, array$$15, eq) {\n  const dict = createMutable([], eq);\n  const keys = [];\n\n  for (let idx$$2 = 0; idx$$2 <= array$$15.length - 1; idx$$2++) {\n    const value$$2 = array$$15[idx$$2];\n    const key = projection(value$$2);\n    const matchValue$$3 = tryGetValue(dict, key, 0);\n\n    if (matchValue$$3[0]) {\n      dict.set(key, matchValue$$3[1] + 1);\n    } else {\n      dict.set(key, 1);\n      const value$$3 = keys.push(key);\n      void value$$3;\n    }\n  }\n\n  const result$$5 = map(function (key$$1) {\n    return [key$$1, getItemFromDict(dict, key$$1)];\n  }, keys, Array);\n  return result$$5;\n}\nexport function distinctBy(projection$$1, array$$17, eq$$1) {\n  const hashSet = createMutable$$1([], eq$$1);\n  return filter(function predicate$$2($arg$$3) {\n    const arg00 = projection$$1($arg$$3);\n    return addToSet(arg00, hashSet);\n  }, array$$17);\n}\nexport function distinct(array$$19, eq$$2) {\n  return distinctBy(function (x$$2) {\n    return x$$2;\n  }, array$$19, eq$$2);\n}\nexport function where(predicate$$3, array$$20) {\n  return array$$20.filter(predicate$$3);\n}\nexport function contains(value$$4, array$$22, eq$$3) {\n  const loop = function loop($i$$12$$79) {\n    loop: while (true) {\n      const i$$12 = $i$$12$$79;\n\n      if (i$$12 >= array$$22.length) {\n        return false;\n      } else if (eq$$3.Equals(value$$4, array$$22[i$$12])) {\n        return true;\n      } else {\n        $i$$12$$79 = i$$12 + 1;\n        continue loop;\n      }\n\n      break;\n    }\n  };\n\n  return loop(0);\n}\nexport function except(itemsToExclude, array$$23, eq$$4) {\n  if (array$$23.length === 0) {\n    return array$$23;\n  } else {\n    const cached = createMutable$$1(itemsToExclude, eq$$4);\n    return array$$23.filter(function predicate$$5(arg00$$1) {\n      return addToSet(arg00$$1, cached);\n    });\n  }\n}\nexport function groupBy(projection$$2, array$$26, cons$$11, eq$$5) {\n  const dict$$1 = createMutable([], eq$$5);\n  const keys$$1 = [];\n\n  for (let idx$$3 = 0; idx$$3 <= array$$26.length - 1; idx$$3++) {\n    const v = array$$26[idx$$3];\n    const key$$2 = projection$$2(v);\n    const matchValue$$4 = tryGetValue(dict$$1, key$$2, null);\n\n    if (matchValue$$4[0]) {\n      dict$$1.set(key$$2, new List(v, matchValue$$4[1]));\n    } else {\n      addToDict(dict$$1, key$$2, new List(v, new List()));\n      const value$$5 = keys$$1.push(key$$2);\n      void value$$5;\n    }\n  }\n\n  const result$$6 = map(function (key$$3) {\n    var array$$28;\n    return [key$$3, (array$$28 = cons$$11.from(getItemFromDict(dict$$1, key$$3)), (array$$28.reverse()))];\n  }, keys$$1, Array);\n  return result$$6;\n}\nexport function empty(cons$$12) {\n  return new cons$$12(0);\n}\nexport function singleton(value$$6, cons$$14) {\n  const ar = new cons$$14(1);\n  ar[0] = value$$6;\n  return ar;\n}\nexport function initialize(count$$8, initializer, cons$$15) {\n  if (count$$8 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n  } else {\n    void null;\n  }\n\n  const result$$7 = new cons$$15(count$$8);\n\n  for (let i$$13 = 0; i$$13 <= count$$8 - 1; i$$13++) {\n    result$$7[i$$13] = initializer(i$$13);\n  }\n\n  return result$$7;\n}\nexport function pairwise(array$$30) {\n  if (array$$30.length < 2) {\n    return [];\n  } else {\n    const count$$9 = array$$30.length - 1 | 0;\n    const result$$8 = new Array(count$$9);\n\n    for (let i$$14 = 0; i$$14 <= count$$9 - 1; i$$14++) {\n      result$$8[i$$14] = [array$$30[i$$14], array$$30[i$$14 + 1]];\n    }\n\n    return result$$8;\n  }\n}\nexport function replicate(count$$10, initial, cons$$16) {\n  if (count$$10 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n  } else {\n    void null;\n  }\n\n  const result$$9 = new cons$$16(count$$10);\n\n  for (let i$$15 = 0; i$$15 <= result$$9.length - 1; i$$15++) {\n    result$$9[i$$15] = initial;\n  }\n\n  return result$$9;\n}\nexport function copy(array$$31, cons$$17) {\n  return array$$31.slice();\n}\nexport function reverse(array$$33, cons$$18) {\n  const array$$35 = array$$33.slice();\n  return array$$35.reverse();\n}\nexport function scan(folder, state$$2, array$$37, cons$$19) {\n  const res$$2 = new cons$$19(array$$37.length + 1);\n  res$$2[0] = state$$2;\n\n  for (let i$$16 = 0; i$$16 <= array$$37.length - 1; i$$16++) {\n    res$$2[i$$16 + 1] = folder(res$$2[i$$16], array$$37[i$$16]);\n  }\n\n  return res$$2;\n}\nexport function scanBack(folder$$1, array$$38, state$$3, cons$$20) {\n  const res$$3 = new cons$$20(array$$38.length + 1);\n  res$$3[array$$38.length] = state$$3;\n\n  for (let i$$17 = array$$38.length - 1; i$$17 >= 0; i$$17--) {\n    res$$3[i$$17] = folder$$1(array$$38[i$$17], res$$3[i$$17 + 1]);\n  }\n\n  return res$$3;\n}\nexport function skip(count$$11, array$$39, cons$$21) {\n  if (count$$11 > array$$39.length) {\n    throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n  } else {\n    void null;\n  }\n\n  if (count$$11 === array$$39.length) {\n    return new cons$$21(0);\n  } else {\n    const count$$12 = (count$$11 < 0 ? 0 : count$$11) | 0;\n    return array$$39.slice(count$$12);\n  }\n}\nexport function skipWhile(predicate$$7, array$$41, cons$$23) {\n  let count$$14 = 0;\n\n  while (count$$14 < array$$41.length ? predicate$$7(array$$41[count$$14]) : false) {\n    count$$14 = count$$14 + 1;\n  }\n\n  if (count$$14 === array$$41.length) {\n    return new cons$$23(0);\n  } else {\n    const count$$15 = count$$14 | 0;\n    return array$$41.slice(count$$15);\n  }\n}\nexport function take(count$$16, array$$43, cons$$25) {\n  if (count$$16 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n  } else {\n    void null;\n  }\n\n  if (count$$16 > array$$43.length) {\n    throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n  } else {\n    void null;\n  }\n\n  if (count$$16 === 0) {\n    return new cons$$25(0);\n  } else {\n    return array$$43.slice(0, 0 + count$$16);\n  }\n}\nexport function takeWhile(predicate$$8, array$$45, cons$$27) {\n  let count$$18 = 0;\n\n  while (count$$18 < array$$45.length ? predicate$$8(array$$45[count$$18]) : false) {\n    count$$18 = count$$18 + 1;\n  }\n\n  if (count$$18 === 0) {\n    return new cons$$27(0);\n  } else {\n    const count$$19 = count$$18 | 0;\n    return array$$45.slice(0, 0 + count$$19);\n  }\n}\nexport function addInPlace(x$$3, array$$47) {\n  const value$$7 = array$$47.push(x$$3);\n  void value$$7;\n}\nexport function addRangeInPlace(range, array$$49) {\n  iterate$$1(function (x$$4) {\n    const value$$8 = array$$49.push(x$$4);\n    void value$$8;\n  }, range);\n}\nexport function removeInPlace(item$$5, array$$51) {\n  const i$$18 = array$$51.indexOf(item$$5);\n\n  if (i$$18 > -1) {\n    const value$$9 = array$$51.splice(i$$18, 1);\n    void value$$9;\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function removeAllInPlace(predicate$$9, array$$54) {\n  const countRemoveAll = function countRemoveAll(count$$20) {\n    const i$$19 = array$$54.findIndex(predicate$$9);\n\n    if (i$$19 > -1) {\n      const value$$10 = array$$54.splice(i$$19, 1);\n      void value$$10;\n      return countRemoveAll(count$$20) + 1 | 0;\n    } else {\n      return count$$20 | 0;\n    }\n  };\n\n  return countRemoveAll(0) | 0;\n}\nexport function copyTo(source$$3, sourceIndex, target$$4, targetIndex$$1, count$$21) {\n  const diff = targetIndex$$1 - sourceIndex | 0;\n\n  for (let i$$20 = sourceIndex; i$$20 <= sourceIndex + count$$21 - 1; i$$20++) {\n    target$$4[i$$20 + diff] = source$$3[i$$20];\n  }\n}\nexport function partition(f$$6, source$$4, cons$$29) {\n  const len$$7 = source$$4.length | 0;\n  const res1 = new cons$$29(len$$7);\n  const res2 = new cons$$29(len$$7);\n  let iTrue = 0;\n  let iFalse = 0;\n\n  for (let i$$21 = 0; i$$21 <= len$$7 - 1; i$$21++) {\n    if (f$$6(source$$4[i$$21])) {\n      res1[iTrue] = source$$4[i$$21];\n      iTrue = iTrue + 1;\n    } else {\n      res2[iFalse] = source$$4[i$$21];\n      iFalse = iFalse + 1;\n    }\n  }\n\n  return [(truncate(iTrue, res1)), (truncate(iFalse, res2))];\n}\nexport function find(predicate$$11, array$$59) {\n  const matchValue$$5 = array$$59.find(predicate$$11);\n\n  if (matchValue$$5 == null) {\n    throw new Error(indexNotFoundMsg);\n  } else {\n    const res$$4 = value$$15(matchValue$$5);\n    return res$$4;\n  }\n}\nexport function tryFind(predicate$$13, array$$61) {\n  return array$$61.find(predicate$$13);\n}\nexport function findIndex(predicate$$15, array$$63) {\n  const matchValue$$6 = array$$63.findIndex(predicate$$15);\n\n  if (matchValue$$6 > -1) {\n    return matchValue$$6 | 0;\n  } else {\n    throw new Error(indexNotFoundMsg);\n  }\n}\nexport function tryFindIndex(predicate$$17, array$$65) {\n  const matchValue$$7 = array$$65.findIndex(predicate$$17);\n\n  if (matchValue$$7 > -1) {\n    return matchValue$$7;\n  } else {\n    return undefined;\n  }\n}\nexport function pick(chooser, array$$67) {\n  const loop$$1 = function loop$$1($i$$22$$149) {\n    loop$$1: while (true) {\n      const i$$22 = $i$$22$$149;\n\n      if (i$$22 >= array$$67.length) {\n        throw new Error(indexNotFoundMsg);\n      } else {\n        const matchValue$$8 = chooser(array$$67[i$$22]);\n\n        if (matchValue$$8 != null) {\n          const res$$5 = value$$15(matchValue$$8);\n          return res$$5;\n        } else {\n          $i$$22$$149 = i$$22 + 1;\n          continue loop$$1;\n        }\n      }\n\n      break;\n    }\n  };\n\n  return loop$$1(0);\n}\nexport function tryPick(chooser$$1, array$$68) {\n  const loop$$2 = function loop$$2($i$$23$$152) {\n    loop$$2: while (true) {\n      const i$$23 = $i$$23$$152;\n\n      if (i$$23 >= array$$68.length) {\n        return undefined;\n      } else {\n        const matchValue$$9 = chooser$$1(array$$68[i$$23]);\n\n        if (matchValue$$9 == null) {\n          $i$$23$$152 = i$$23 + 1;\n          continue loop$$2;\n        } else {\n          return matchValue$$9;\n        }\n      }\n\n      break;\n    }\n  };\n\n  return loop$$2(0);\n}\nexport function findBack(predicate$$19, array$$69) {\n  const loop$$3 = function loop$$3($i$$24$$155) {\n    loop$$3: while (true) {\n      const i$$24 = $i$$24$$155;\n\n      if (i$$24 < 0) {\n        throw new Error(indexNotFoundMsg);\n      } else if (predicate$$19(array$$69[i$$24])) {\n        return array$$69[i$$24];\n      } else {\n        $i$$24$$155 = i$$24 - 1;\n        continue loop$$3;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$3(array$$69.length - 1);\n}\nexport function tryFindBack(predicate$$20, array$$70) {\n  const loop$$4 = function loop$$4($i$$25$$158) {\n    loop$$4: while (true) {\n      const i$$25 = $i$$25$$158;\n\n      if (i$$25 < 0) {\n        return undefined;\n      } else if (predicate$$20(array$$70[i$$25])) {\n        return some(array$$70[i$$25]);\n      } else {\n        $i$$25$$158 = i$$25 - 1;\n        continue loop$$4;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$4(array$$70.length - 1);\n}\nexport function findLastIndex(predicate$$21, array$$71) {\n  const loop$$5 = function loop$$5($i$$26$$161) {\n    loop$$5: while (true) {\n      const i$$26 = $i$$26$$161;\n\n      if (i$$26 < 0) {\n        return -1 | 0;\n      } else if (predicate$$21(array$$71[i$$26])) {\n        return i$$26 | 0;\n      } else {\n        $i$$26$$161 = i$$26 - 1;\n        continue loop$$5;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$5(array$$71.length - 1) | 0;\n}\nexport function findIndexBack(predicate$$22, array$$72) {\n  const loop$$6 = function loop$$6($i$$27$$164) {\n    loop$$6: while (true) {\n      const i$$27 = $i$$27$$164;\n\n      if (i$$27 < 0) {\n        throw new Error(indexNotFoundMsg);\n      } else if (predicate$$22(array$$72[i$$27])) {\n        return i$$27 | 0;\n      } else {\n        $i$$27$$164 = i$$27 - 1;\n        continue loop$$6;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$6(array$$72.length - 1) | 0;\n}\nexport function tryFindIndexBack(predicate$$23, array$$73) {\n  const loop$$7 = function loop$$7($i$$28$$167) {\n    loop$$7: while (true) {\n      const i$$28 = $i$$28$$167;\n\n      if (i$$28 < 0) {\n        return undefined;\n      } else if (predicate$$23(array$$73[i$$28])) {\n        return i$$28;\n      } else {\n        $i$$28$$167 = i$$28 - 1;\n        continue loop$$7;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$7(array$$73.length - 1);\n}\nexport function choose(chooser$$2, array$$74, cons$$30) {\n  const arr$$7 = array$$74.filter(function f$$7(x$$5) {\n    const option = chooser$$2(x$$5);\n    return option != null;\n  });\n  return map(function g(x$$6) {\n    const option$$1 = chooser$$2(x$$6);\n    return value$$15(option$$1);\n  }, arr$$7, cons$$30);\n}\nexport function foldIndexed(folder$$2, state$$4, array$$76) {\n  return array$$76.reduce(function (delegateArg0$$1, delegateArg1$$1, delegateArg2) {\n    return folder$$2(delegateArg2, delegateArg0$$1, delegateArg1$$1);\n  }, state$$4);\n}\nexport function fold(folder$$4, state$$6, array$$78) {\n  return array$$78.reduce(function (delegateArg0$$2, delegateArg1$$2) {\n    return folder$$4(delegateArg0$$2, delegateArg1$$2);\n  }, state$$6);\n}\nexport function iterate(action, array$$80) {\n  for (let i$$30 = 0; i$$30 <= array$$80.length - 1; i$$30++) {\n    action(array$$80[i$$30]);\n  }\n}\nexport function iterateIndexed(action$$1, array$$81) {\n  for (let i$$31 = 0; i$$31 <= array$$81.length - 1; i$$31++) {\n    action$$1(i$$31, array$$81[i$$31]);\n  }\n}\nexport function iterate2(action$$2, array1$$2, array2$$2) {\n  if (array1$$2.length !== array2$$2.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  for (let i$$32 = 0; i$$32 <= array1$$2.length - 1; i$$32++) {\n    action$$2(array1$$2[i$$32], array2$$2[i$$32]);\n  }\n}\nexport function iterateIndexed2(action$$3, array1$$3, array2$$3) {\n  if (array1$$3.length !== array2$$3.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  for (let i$$33 = 0; i$$33 <= array1$$3.length - 1; i$$33++) {\n    action$$3(i$$33, array1$$3[i$$33], array2$$3[i$$33]);\n  }\n}\nexport function isEmpty(array$$82) {\n  return array$$82.length === 0;\n}\nexport function forAll(predicate$$25, array$$83) {\n  return array$$83.every(predicate$$25);\n}\nexport function permute(f$$8, array$$85) {\n  const size = array$$85.length | 0;\n  const res$$7 = array$$85.slice();\n  const checkFlags = new Int32Array(size);\n  iterateIndexed(function (i$$34, x$$9) {\n    const j$$1 = f$$8(i$$34) | 0;\n\n    if (j$$1 < 0 ? true : j$$1 >= size) {\n      throw new Error(\"Not a valid permutation\");\n    } else {\n      void null;\n    }\n\n    res$$7[j$$1] = x$$9;\n    checkFlags[j$$1] = 1;\n  }, array$$85);\n  let isValid;\n  isValid = checkFlags.every(function predicate$$27(y) {\n    return 1 === y;\n  });\n\n  if (!isValid) {\n    throw new Error(\"Not a valid permutation\");\n  } else {\n    void null;\n  }\n\n  return res$$7;\n}\nexport function setSlice(target$$5, lower, upper, source$$5) {\n  const lower$$1 = defaultArg(lower, 0) | 0;\n  const upper$$1 = defaultArg(upper, 0) | 0;\n  const length = (upper$$1 > 0 ? upper$$1 : target$$5.length - 1) - lower$$1 | 0;\n\n  for (let i$$35 = 0; i$$35 <= length; i$$35++) {\n    target$$5[i$$35 + lower$$1] = source$$5[i$$35];\n  }\n}\nexport function sortInPlaceBy(projection$$3, xs, comparer) {\n  xs.sort(function (x$$11, y$$1) {\n    return comparer.Compare(projection$$3(x$$11), projection$$3(y$$1));\n  });\n}\nexport function sortInPlace(xs$$1, comparer$$1) {\n  xs$$1.sort(function (x$$12, y$$2) {\n    return comparer$$1.Compare(x$$12, y$$2);\n  });\n}\nexport function sort(xs$$2, comparer$$2) {\n  const xs$$3 = xs$$2.slice();\n  xs$$3.sort(function comparer$$3(x$$13, y$$3) {\n    return comparer$$2.Compare(x$$13, y$$3);\n  });\n  return xs$$3;\n}\nexport function sortBy(projection$$4, xs$$4, comparer$$4) {\n  const xs$$5 = xs$$4.slice();\n  xs$$5.sort(function comparer$$5(x$$14, y$$4) {\n    return comparer$$4.Compare(projection$$4(x$$14), projection$$4(y$$4));\n  });\n  return xs$$5;\n}\nexport function sortDescending(xs$$6, comparer$$6) {\n  const xs$$7 = xs$$6.slice();\n  xs$$7.sort(function comparer$$7(x$$15, y$$5) {\n    return comparer$$6.Compare(x$$15, y$$5) * -1;\n  });\n  return xs$$7;\n}\nexport function sortByDescending(projection$$5, xs$$8, comparer$$8) {\n  const xs$$9 = xs$$8.slice();\n  xs$$9.sort(function comparer$$9(x$$16, y$$6) {\n    return comparer$$8.Compare(projection$$5(x$$16), projection$$5(y$$6)) * -1;\n  });\n  return xs$$9;\n}\nexport function sortWith(comparer$$10, xs$$10) {\n  const xs$$11 = xs$$10.slice();\n  xs$$11.sort(comparer$$10);\n  return xs$$11;\n}\nexport function unfold(generator, state$$8) {\n  const res$$8 = [];\n\n  const loop$$8 = function loop$$8($state$$9$$226) {\n    loop$$8: while (true) {\n      const state$$9 = $state$$9$$226;\n      const matchValue$$10 = generator(state$$9);\n\n      if (matchValue$$10 != null) {\n        const x$$17 = matchValue$$10[0];\n        const s$$2 = matchValue$$10[1];\n        const value$$11 = res$$8.push(x$$17);\n        void value$$11;\n        $state$$9$$226 = s$$2;\n        continue loop$$8;\n      } else {\n        void null;\n      }\n\n      break;\n    }\n  };\n\n  loop$$8(state$$8);\n  return res$$8;\n}\nexport function unzip(array$$95) {\n  const len$$8 = array$$95.length | 0;\n  const res1$$1 = new Array(len$$8);\n  const res2$$1 = new Array(len$$8);\n  iterateIndexed(function (i$$36, tupledArg) {\n    res1$$1[i$$36] = tupledArg[0];\n    res2$$1[i$$36] = tupledArg[1];\n  }, array$$95);\n  return [res1$$1, res2$$1];\n}\nexport function unzip3(array$$96) {\n  const len$$11 = array$$96.length | 0;\n  const res1$$2 = new Array(len$$11);\n  const res2$$2 = new Array(len$$11);\n  const res3 = new Array(len$$11);\n  iterateIndexed(function (i$$37, tupledArg$$1) {\n    res1$$2[i$$37] = tupledArg$$1[0];\n    res2$$2[i$$37] = tupledArg$$1[1];\n    res3[i$$37] = tupledArg$$1[2];\n  }, array$$96);\n  return [res1$$2, res2$$2, res3];\n}\nexport function zip(array1$$4, array2$$4) {\n  if (array1$$4.length !== array2$$4.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  let result$$10;\n  const len$$15 = array1$$4.length | 0;\n  result$$10 = new Array(len$$15);\n\n  for (let i$$38 = 0; i$$38 <= array1$$4.length - 1; i$$38++) {\n    result$$10[i$$38] = [array1$$4[i$$38], array2$$4[i$$38]];\n  }\n\n  return result$$10;\n}\nexport function zip3(array1$$5, array2$$5, array3) {\n  if (array1$$5.length !== array2$$5.length ? true : array2$$5.length !== array3.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  let result$$11;\n  const len$$16 = array1$$5.length | 0;\n  result$$11 = new Array(len$$16);\n\n  for (let i$$39 = 0; i$$39 <= array1$$5.length - 1; i$$39++) {\n    result$$11[i$$39] = [array1$$5[i$$39], array2$$5[i$$39], array3[i$$39]];\n  }\n\n  return result$$11;\n}\nexport function chunkBySize(chunkSize, array$$97) {\n  if (chunkSize < 1) {\n    throw new Error(\"The input must be positive.\\\\nParameter name: size\");\n  } else {\n    void null;\n  }\n\n  if (array$$97.length === 0) {\n    return [[]];\n  } else {\n    const result$$12 = [];\n\n    for (let x$$18 = 0; x$$18 <= ~~Math.ceil(array$$97.length / chunkSize) - 1; x$$18++) {\n      const start$$8 = x$$18 * chunkSize | 0;\n      const slice = array$$97.slice(start$$8, start$$8 + chunkSize);\n      const value$$12 = result$$12.push(slice);\n      void value$$12;\n    }\n\n    return result$$12;\n  }\n}\nexport function splitAt(index$$4, array$$100) {\n  if (index$$4 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: index\");\n  } else {\n    void null;\n  }\n\n  if (index$$4 > array$$100.length) {\n    throw new Error(\"The input sequence has an insufficient number of elements.\\\\nParameter name: index\");\n  } else {\n    void null;\n  }\n\n  return [array$$100.slice(0, 0 + index$$4), array$$100.slice(index$$4)];\n}\nexport function compareWith(comparer$$12, array1$$6, array2$$6) {\n  if (array1$$6 == null) {\n    if (array2$$6 == null) {\n      return 0;\n    } else {\n      return -1 | 0;\n    }\n  } else if (array2$$6 == null) {\n    return 1;\n  } else {\n    let i$$40 = 0;\n    let result$$13 = 0;\n    const length1 = array1$$6.length | 0;\n    const length2 = array2$$6.length | 0;\n\n    if (length1 > length2) {\n      return 1;\n    } else if (length1 < length2) {\n      return -1 | 0;\n    } else {\n      while (i$$40 < length1 ? result$$13 === 0 : false) {\n        result$$13 = comparer$$12(array1$$6[i$$40], array2$$6[i$$40]);\n        i$$40 = i$$40 + 1;\n      }\n\n      return result$$13 | 0;\n    }\n  }\n}\nexport function equalsWith(comparer$$13, array1$$7, array2$$7) {\n  return compareWith(compare, array1$$7, array2$$7) === 0;\n}\nexport function exactlyOne(array$$103) {\n  if (array$$103.length === 1) {\n    return array$$103[0];\n  } else if (array$$103.length === 0) {\n    throw new Error(\"The input sequence was empty\\\\nParameter name: array\");\n  } else {\n    throw new Error(\"Input array too long\\\\nParameter name: array\");\n  }\n}\nexport function head(array$$104) {\n  if (array$$104.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  } else {\n    return array$$104[0];\n  }\n}\nexport function tryHead(array$$105) {\n  if (array$$105.length === 0) {\n    return undefined;\n  } else {\n    return some(array$$105[0]);\n  }\n}\nexport function tail(array$$106) {\n  if (array$$106.length === 0) {\n    throw new Error(\"Not enough elements\\\\nParameter name: array\");\n  } else {\n    void null;\n  }\n\n  return array$$106.slice(1);\n}\nexport function item(index$$5, array$$108) {\n  return array$$108[index$$5];\n}\nexport function tryItem(index$$6, array$$109) {\n  if (index$$6 < 0 ? true : index$$6 >= array$$109.length) {\n    return undefined;\n  } else {\n    return some(array$$109[index$$6]);\n  }\n}\nexport function foldBackIndexed(folder$$6, array$$110, state$$10) {\n  return array$$110.reduceRight(function (delegateArg0$$3, delegateArg1$$3, delegateArg2$$1) {\n    return folder$$6(delegateArg2$$1, delegateArg1$$3, delegateArg0$$3);\n  }, state$$10);\n}\nexport function foldBack(folder$$8, array$$112, state$$12) {\n  return array$$112.reduceRight(function (delegateArg0$$4, delegateArg1$$4) {\n    return folder$$8(delegateArg1$$4, delegateArg0$$4);\n  }, state$$12);\n}\nexport function foldIndexed2(folder$$10, state$$14, array1$$8, array2$$8) {\n  let acc$$6 = state$$14;\n\n  if (array1$$8.length !== array2$$8.length) {\n    throw new Error(\"Arrays have different lengths\");\n  } else {\n    void null;\n  }\n\n  for (let i$$42 = 0; i$$42 <= array1$$8.length - 1; i$$42++) {\n    acc$$6 = folder$$10(i$$42, acc$$6, array1$$8[i$$42], array2$$8[i$$42]);\n  }\n\n  return acc$$6;\n}\nexport function fold2(folder$$11, state$$15, array1$$9, array2$$9) {\n  return foldIndexed2(function (_arg1, acc$$7, x$$21, y$$7) {\n    return folder$$11(acc$$7, x$$21, y$$7);\n  }, state$$15, array1$$9, array2$$9);\n}\nexport function foldBackIndexed2(folder$$12, array1$$10, array2$$10, state$$16) {\n  let acc$$8 = state$$16;\n\n  if (array1$$10.length !== array2$$10.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  const size$$1 = array1$$10.length | 0;\n\n  for (let i$$43 = 1; i$$43 <= size$$1; i$$43++) {\n    acc$$8 = folder$$12(i$$43 - 1, array1$$10[size$$1 - i$$43], array2$$10[size$$1 - i$$43], acc$$8);\n  }\n\n  return acc$$8;\n}\nexport function foldBack2(f$$9, array1$$11, array2$$11, state$$17) {\n  return foldBackIndexed2(function (_arg1$$1, x$$22, y$$8, acc$$9) {\n    return f$$9(x$$22, y$$8, acc$$9);\n  }, array1$$11, array2$$11, state$$17);\n}\nexport function reduce(reduction, array$$114) {\n  if (array$$114.length === 0) {\n    throw new Error(\"The input array was empty\");\n  } else {\n    void null;\n  }\n\n  return array$$114.reduce(reduction);\n}\nexport function reduceBack(reduction$$2, array$$116) {\n  if (array$$116.length === 0) {\n    throw new Error(\"The input array was empty\");\n  } else {\n    void null;\n  }\n\n  return array$$116.reduceRight(reduction$$2);\n}\nexport function forAll2(predicate$$29, array1$$12, array2$$12) {\n  return fold2(function (acc$$10, x$$23, y$$9) {\n    return acc$$10 ? predicate$$29(x$$23, y$$9) : false;\n  }, true, array1$$12, array2$$12);\n}\nexport function existsOffset($predicate$$30$$281, $array$$118$$282, $index$$7$$283) {\n  existsOffset: while (true) {\n    const predicate$$30 = $predicate$$30$$281,\n          array$$118 = $array$$118$$282,\n          index$$7 = $index$$7$$283;\n\n    if (index$$7 === array$$118.length) {\n      return false;\n    } else if (predicate$$30(array$$118[index$$7])) {\n      return true;\n    } else {\n      $predicate$$30$$281 = predicate$$30;\n      $array$$118$$282 = array$$118;\n      $index$$7$$283 = index$$7 + 1;\n      continue existsOffset;\n    }\n\n    break;\n  }\n}\nexport function exists(predicate$$31, array$$119) {\n  return existsOffset(predicate$$31, array$$119, 0);\n}\nexport function existsOffset2($predicate$$32$$286, $array1$$13$$287, $array2$$13$$288, $index$$8$$289) {\n  existsOffset2: while (true) {\n    const predicate$$32 = $predicate$$32$$286,\n          array1$$13 = $array1$$13$$287,\n          array2$$13 = $array2$$13$$288,\n          index$$8 = $index$$8$$289;\n\n    if (index$$8 === array1$$13.length) {\n      return false;\n    } else if (predicate$$32(array1$$13[index$$8], array2$$13[index$$8])) {\n      return true;\n    } else {\n      $predicate$$32$$286 = predicate$$32;\n      $array1$$13$$287 = array1$$13;\n      $array2$$13$$288 = array2$$13;\n      $index$$8$$289 = index$$8 + 1;\n      continue existsOffset2;\n    }\n\n    break;\n  }\n}\nexport function exists2(predicate$$33, array1$$14, array2$$14) {\n  if (array1$$14.length !== array2$$14.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  return existsOffset2(predicate$$33, array1$$14, array2$$14, 0);\n}\nexport function sum(array$$120, adder) {\n  let acc$$11 = adder.GetZero();\n\n  for (let i$$44 = 0; i$$44 <= array$$120.length - 1; i$$44++) {\n    acc$$11 = adder.Add(acc$$11, array$$120[i$$44]);\n  }\n\n  return acc$$11;\n}\nexport function sumBy(projection$$6, array$$121, adder$$1) {\n  let acc$$12 = adder$$1.GetZero();\n\n  for (let i$$45 = 0; i$$45 <= array$$121.length - 1; i$$45++) {\n    acc$$12 = adder$$1.Add(acc$$12, projection$$6(array$$121[i$$45]));\n  }\n\n  return acc$$12;\n}\nexport function maxBy(projection$$7, xs$$12, comparer$$14) {\n  return reduce(function (x$$24, y$$10) {\n    return comparer$$14.Compare(projection$$7(y$$10), projection$$7(x$$24)) > 0 ? y$$10 : x$$24;\n  }, xs$$12);\n}\nexport function max(xs$$13, comparer$$15) {\n  return reduce(function (x$$25, y$$11) {\n    return comparer$$15.Compare(y$$11, x$$25) > 0 ? y$$11 : x$$25;\n  }, xs$$13);\n}\nexport function minBy(projection$$8, xs$$14, comparer$$16) {\n  return reduce(function (x$$26, y$$12) {\n    return comparer$$16.Compare(projection$$8(y$$12), projection$$8(x$$26)) > 0 ? x$$26 : y$$12;\n  }, xs$$14);\n}\nexport function min(xs$$15, comparer$$17) {\n  return reduce(function (x$$27, y$$13) {\n    return comparer$$17.Compare(y$$13, x$$27) > 0 ? x$$27 : y$$13;\n  }, xs$$15);\n}\nexport function average(array$$122, averager) {\n  if (array$$122.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  } else {\n    void null;\n  }\n\n  let total = averager.GetZero();\n\n  for (let i$$46 = 0; i$$46 <= array$$122.length - 1; i$$46++) {\n    total = averager.Add(total, array$$122[i$$46]);\n  }\n\n  return averager.DivideByInt(total, array$$122.length);\n}\nexport function averageBy(projection$$9, array$$123, averager$$1) {\n  if (array$$123.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  } else {\n    void null;\n  }\n\n  let total$$1 = averager$$1.GetZero();\n\n  for (let i$$47 = 0; i$$47 <= array$$123.length - 1; i$$47++) {\n    total$$1 = averager$$1.Add(total$$1, projection$$9(array$$123[i$$47]));\n  }\n\n  return averager$$1.DivideByInt(total$$1, array$$123.length);\n}\nexport function ofSeq(source$$6, cons$$31) {\n  return cons$$31.from(source$$6);\n}\nexport function ofList(source$$7, cons$$32) {\n  return cons$$32.from(source$$7);\n}\nexport function toList(source$$8) {\n  const len$$17 = source$$8.length | 0;\n  let target$$6 = new List();\n\n  for (let i$$48 = len$$17 - 1; i$$48 >= 0; i$$48--) {\n    target$$6 = new List(source$$8[i$$48], target$$6);\n  }\n\n  return target$$6;\n}\nexport function windowed(windowSize, source$$9) {\n  if (windowSize <= 0) {\n    throw new Error(\"windowSize must be positive\");\n  } else {\n    void null;\n  }\n\n  let res$$9;\n  const len$$18 = max$$1(comparePrimitives, 0, source$$9.length - windowSize) | 0;\n  res$$9 = new Array(len$$18);\n\n  for (let i$$49 = windowSize; i$$49 <= source$$9.length; i$$49++) {\n    res$$9[i$$49 - windowSize] = source$$9.slice(i$$49 - windowSize, i$$49 - 1 + 1);\n  }\n\n  return res$$9;\n}\nexport function splitInto(chunks, array$$124) {\n  if (chunks < 1) {\n    throw new Error(\"The input must be positive.\\\\nParameter name: chunks\");\n  } else {\n    void null;\n  }\n\n  if (array$$124.length === 0) {\n    return [[]];\n  } else {\n    const result$$14 = [];\n    const chunks$$1 = min$$1(comparePrimitives, chunks, array$$124.length) | 0;\n    const minChunkSize = ~~(array$$124.length / chunks$$1) | 0;\n    const chunksWithExtraItem = array$$124.length % chunks$$1 | 0;\n\n    for (let i$$50 = 0; i$$50 <= chunks$$1 - 1; i$$50++) {\n      const chunkSize$$1 = (i$$50 < chunksWithExtraItem ? minChunkSize + 1 : minChunkSize) | 0;\n      const start$$11 = i$$50 * minChunkSize + min$$1(comparePrimitives, chunksWithExtraItem, i$$50) | 0;\n      const slice$$1 = array$$124.slice(start$$11, start$$11 + chunkSize$$1);\n      const value$$13 = result$$14.push(slice$$1);\n      void value$$13;\n    }\n\n    return result$$14;\n  }\n}\nexport function transpose(arrays$$2, cons$$33) {\n  var value$$14;\n  const arrays$$3 = Array.isArray(arrays$$2) ? arrays$$2 : Array.from(arrays$$2);\n  const len$$20 = arrays$$3.length | 0;\n\n  if (len$$20 === 0) {\n    return new Array(0);\n  } else {\n    const lenInner = arrays$$3[0].length | 0;\n\n    if (value$$14 = (forAll(function predicate$$34(a) {\n      return a.length === lenInner;\n    }, arrays$$3)), (!value$$14)) {\n      throw new Error(\"Arrays had different lengths\");\n    } else {\n      void null;\n    }\n\n    const result$$15 = new Array(lenInner);\n\n    for (let i$$51 = 0; i$$51 <= lenInner - 1; i$$51++) {\n      result$$15[i$$51] = new cons$$33(len$$20);\n\n      for (let j$$2 = 0; j$$2 <= len$$20 - 1; j$$2++) {\n        result$$15[i$$51][j$$2] = arrays$$3[j$$2][i$$51];\n      }\n    }\n\n    return result$$15;\n  }\n}","import { defaultArg, value as value$$1, some } from \"./Option.js\";\nimport { List } from \"./Types.js\";\nimport { transpose as transpose$$1, pairwise as pairwise$$1, collect as collect$$1, scanBack as scanBack$$1, scan as scan$$1, foldBack2 as foldBack2$$1, fold2 as fold2$$1, fold as fold$$1, map as map$$1 } from \"./Seq.js\";\nimport { getItemFromDict, addToDict, tryGetValue, addToSet, count } from \"./Util.js\";\nimport { ofList } from \"./Array.js\";\nimport { splitInto as splitInto$$1, chunkBySize as chunkBySize$$1, permute as permute$$1, findIndexBack as findIndexBack$$1, tryFindIndexBack as tryFindIndexBack$$1 } from \"./Array\";\nimport { createMutable } from \"./Set.js\";\nimport { createMutable as createMutable$$1 } from \"./Map.js\";\nexport function head(_arg1) {\n  if (_arg1.tail != null) {\n    return _arg1.head;\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function tryHead(_arg1$$1) {\n  if (_arg1$$1.tail != null) {\n    return some(_arg1$$1.head);\n  } else {\n    return undefined;\n  }\n}\nexport function tail(_arg1$$2) {\n  if (_arg1$$2.tail != null) {\n    return _arg1$$2.tail;\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function last($_arg1$$3$$5) {\n  last: while (true) {\n    const _arg1$$3 = $_arg1$$3$$5;\n\n    if (_arg1$$3.tail != null) {\n      if (_arg1$$3.tail.tail == null) {\n        return _arg1$$3.head;\n      } else {\n        $_arg1$$3$$5 = _arg1$$3.tail;\n        continue last;\n      }\n    } else {\n      throw new Error(\"List was empty\");\n    }\n\n    break;\n  }\n}\nexport function tryLast($_arg1$$4$$6) {\n  tryLast: while (true) {\n    const _arg1$$4 = $_arg1$$4$$6;\n\n    if (_arg1$$4.tail != null) {\n      if (_arg1$$4.tail.tail == null) {\n        return some(_arg1$$4.head);\n      } else {\n        $_arg1$$4$$6 = _arg1$$4.tail;\n        continue tryLast;\n      }\n    } else {\n      return undefined;\n    }\n\n    break;\n  }\n}\nexport function compareWith(comparer, xs$$3, ys) {\n  if (xs$$3 === ys) {\n    return 0;\n  } else {\n    const loop = function loop($xs$$4$$10, $ys$$1$$11) {\n      loop: while (true) {\n        const xs$$4 = $xs$$4$$10,\n              ys$$1 = $ys$$1$$11;\n\n        if (xs$$4.tail != null) {\n          if (ys$$1.tail != null) {\n            const matchValue$$1 = comparer(xs$$4.head, ys$$1.head) | 0;\n\n            if (matchValue$$1 === 0) {\n              $xs$$4$$10 = xs$$4.tail;\n              $ys$$1$$11 = ys$$1.tail;\n              continue loop;\n            } else {\n              return matchValue$$1 | 0;\n            }\n          } else {\n            return 1;\n          }\n        } else if (ys$$1.tail == null) {\n          return 0;\n        } else {\n          return -1 | 0;\n        }\n\n        break;\n      }\n    };\n\n    return loop(xs$$3, ys) | 0;\n  }\n}\nexport function foldIndexedAux($f$$12, $i$$13, $acc$$14, $_arg1$$5$$15) {\n  foldIndexedAux: while (true) {\n    const f = $f$$12,\n          i = $i$$13,\n          acc = $acc$$14,\n          _arg1$$5 = $_arg1$$5$$15;\n\n    if (_arg1$$5.tail != null) {\n      $f$$12 = f;\n      $i$$13 = i + 1;\n      $acc$$14 = f(i, acc, _arg1$$5.head);\n      $_arg1$$5$$15 = _arg1$$5.tail;\n      continue foldIndexedAux;\n    } else {\n      return acc;\n    }\n\n    break;\n  }\n}\nexport function foldIndexed(f$$1, state, xs$$7) {\n  return foldIndexedAux(f$$1, 0, state, xs$$7);\n}\nexport function fold($f$$2$$19, $state$$1$$20, $xs$$8$$21) {\n  fold: while (true) {\n    const f$$2 = $f$$2$$19,\n          state$$1 = $state$$1$$20,\n          xs$$8 = $xs$$8$$21;\n\n    if (xs$$8.tail != null) {\n      $f$$2$$19 = f$$2;\n      $state$$1$$20 = f$$2(state$$1, xs$$8.head);\n      $xs$$8$$21 = xs$$8.tail;\n      continue fold;\n    } else {\n      return state$$1;\n    }\n\n    break;\n  }\n}\nexport function reverse(xs$$9) {\n  return fold(function (acc$$1, x$$6) {\n    return new List(x$$6, acc$$1);\n  }, new List(), xs$$9);\n}\nexport function foldBack(f$$3, xs$$10, state$$2) {\n  return fold(function (acc$$2, x$$7) {\n    return f$$3(x$$7, acc$$2);\n  }, state$$2, reverse(xs$$10));\n}\nexport function toSeq(xs$$11) {\n  return map$$1(function (x$$8) {\n    return x$$8;\n  }, xs$$11);\n}\nexport function ofSeq(xs$$12) {\n  const xs$$13 = fold$$1(function (acc$$3, x$$9) {\n    return new List(x$$9, acc$$3);\n  }, new List(), xs$$12);\n  return reverse(xs$$13);\n}\nexport function concat(lists) {\n  const xs$$15 = fold$$1(function (state$$3, xs$$14) {\n    return fold(function f$$4(acc$$4, x$$10) {\n      return new List(x$$10, acc$$4);\n    }, state$$3, xs$$14);\n  }, new List(), lists);\n  return reverse(xs$$15);\n}\nexport function foldIndexed2Aux($f$$5$$31, $i$$1$$32, $acc$$5$$33, $bs$$34, $cs$$35) {\n  foldIndexed2Aux: while (true) {\n    const f$$5 = $f$$5$$31,\n          i$$1 = $i$$1$$32,\n          acc$$5 = $acc$$5$$33,\n          bs = $bs$$34,\n          cs = $cs$$35;\n    var $target$$36, x$$11, xs$$16, y$$1, ys$$3;\n\n    if (bs.tail != null) {\n      if (cs.tail != null) {\n        $target$$36 = 1;\n        x$$11 = bs.head;\n        xs$$16 = bs.tail;\n        y$$1 = cs.head;\n        ys$$3 = cs.tail;\n      } else {\n        $target$$36 = 2;\n      }\n    } else if (cs.tail == null) {\n      $target$$36 = 0;\n    } else {\n      $target$$36 = 2;\n    }\n\n    switch ($target$$36) {\n      case 0:\n        {\n          return acc$$5;\n        }\n\n      case 1:\n        {\n          $f$$5$$31 = f$$5;\n          $i$$1$$32 = i$$1 + 1;\n          $acc$$5$$33 = f$$5(i$$1, acc$$5, x$$11, y$$1);\n          $bs$$34 = xs$$16;\n          $cs$$35 = ys$$3;\n          continue foldIndexed2Aux;\n        }\n\n      case 2:\n        {\n          throw new Error(\"Lists had different lengths\");\n        }\n    }\n\n    break;\n  }\n}\nexport function foldIndexed2(f$$6, state$$4, xs$$17, ys$$4) {\n  return foldIndexed2Aux(f$$6, 0, state$$4, xs$$17, ys$$4);\n}\nexport function fold2(f$$7, state$$5, xs$$18, ys$$5) {\n  return fold2$$1(f$$7, state$$5, xs$$18, ys$$5);\n}\nexport function foldBack2(f$$8, xs$$19, ys$$6, state$$6) {\n  return foldBack2$$1(f$$8, xs$$19, ys$$6, state$$6);\n}\nexport function unfold(f$$9, state$$7) {\n  const unfoldInner = function unfoldInner($acc$$6$$51, $state$$8$$52) {\n    unfoldInner: while (true) {\n      const acc$$6 = $acc$$6$$51,\n            state$$8 = $state$$8$$52;\n      const matchValue$$3 = f$$9(state$$8);\n\n      if (matchValue$$3 != null) {\n        const x$$12 = matchValue$$3[0];\n        const state$$9 = matchValue$$3[1];\n        $acc$$6$$51 = new List(x$$12, acc$$6);\n        $state$$8$$52 = state$$9;\n        continue unfoldInner;\n      } else {\n        return reverse(acc$$6);\n      }\n\n      break;\n    }\n  };\n\n  return unfoldInner(new List(), state$$7);\n}\nexport function foldIndexed3Aux($f$$10$$53, $i$$2$$54, $acc$$7$$55, $bs$$1$$56, $cs$$1$$57, $ds$$58) {\n  foldIndexed3Aux: while (true) {\n    const f$$10 = $f$$10$$53,\n          i$$2 = $i$$2$$54,\n          acc$$7 = $acc$$7$$55,\n          bs$$1 = $bs$$1$$56,\n          cs$$1 = $cs$$1$$57,\n          ds = $ds$$58;\n    var $target$$59, x$$13, xs$$20, y$$2, ys$$7, z, zs;\n\n    if (bs$$1.tail != null) {\n      if (cs$$1.tail != null) {\n        if (ds.tail != null) {\n          $target$$59 = 1;\n          x$$13 = bs$$1.head;\n          xs$$20 = bs$$1.tail;\n          y$$2 = cs$$1.head;\n          ys$$7 = cs$$1.tail;\n          z = ds.head;\n          zs = ds.tail;\n        } else {\n          $target$$59 = 2;\n        }\n      } else {\n        $target$$59 = 2;\n      }\n    } else if (cs$$1.tail == null) {\n      if (ds.tail == null) {\n        $target$$59 = 0;\n      } else {\n        $target$$59 = 2;\n      }\n    } else {\n      $target$$59 = 2;\n    }\n\n    switch ($target$$59) {\n      case 0:\n        {\n          return acc$$7;\n        }\n\n      case 1:\n        {\n          $f$$10$$53 = f$$10;\n          $i$$2$$54 = i$$2 + 1;\n          $acc$$7$$55 = f$$10(i$$2, acc$$7, x$$13, y$$2, z);\n          $bs$$1$$56 = xs$$20;\n          $cs$$1$$57 = ys$$7;\n          $ds$$58 = zs;\n          continue foldIndexed3Aux;\n        }\n\n      case 2:\n        {\n          throw new Error(\"Lists had different lengths\");\n        }\n    }\n\n    break;\n  }\n}\nexport function foldIndexed3(f$$11, seed, xs$$21, ys$$8, zs$$1) {\n  return foldIndexed3Aux(f$$11, 0, seed, xs$$21, ys$$8, zs$$1);\n}\nexport function fold3(f$$12, state$$10, xs$$22, ys$$9, zs$$2) {\n  return foldIndexed3(function (_arg1$$6, acc$$8, x$$14, y$$3, z$$1) {\n    return f$$12(acc$$8, x$$14, y$$3, z$$1);\n  }, state$$10, xs$$22, ys$$9, zs$$2);\n}\nexport function scan(f$$13, state$$11, xs$$23) {\n  const xs$$24 = scan$$1(f$$13, state$$11, xs$$23);\n  return ofSeq(xs$$24);\n}\nexport function scanBack(f$$14, xs$$25, state$$12) {\n  const xs$$26 = scanBack$$1(f$$14, xs$$25, state$$12);\n  return ofSeq(xs$$26);\n}\nexport function length(xs$$27) {\n  return fold(function (acc$$9, _arg1$$7) {\n    return acc$$9 + 1;\n  }, 0, xs$$27);\n}\nexport function append(xs$$28, ys$$10) {\n  return fold(function (acc$$10, x$$15) {\n    return new List(x$$15, acc$$10);\n  }, ys$$10, reverse(xs$$28));\n}\nexport function collect(f$$15, xs$$29) {\n  const xs$$30 = collect$$1(f$$15, xs$$29);\n  return ofSeq(xs$$30);\n}\nexport function map(f$$16, xs$$31) {\n  const xs$$32 = fold(function (acc$$11, x$$16) {\n    return new List(f$$16(x$$16), acc$$11);\n  }, new List(), xs$$31);\n  return reverse(xs$$32);\n}\nexport function mapIndexed(f$$17, xs$$33) {\n  const xs$$34 = foldIndexed(function (i$$3, acc$$12, x$$17) {\n    return new List(f$$17(i$$3, x$$17), acc$$12);\n  }, new List(), xs$$33);\n  return reverse(xs$$34);\n}\nexport function indexed(xs$$35) {\n  return mapIndexed(function (i$$4, x$$18) {\n    return [i$$4, x$$18];\n  }, xs$$35);\n}\nexport function map2(f$$18, xs$$36, ys$$11) {\n  const xs$$37 = fold2(function (acc$$13, x$$19, y$$4) {\n    return new List(f$$18(x$$19, y$$4), acc$$13);\n  }, new List(), xs$$36, ys$$11);\n  return reverse(xs$$37);\n}\nexport function mapIndexed2(f$$19, xs$$38, ys$$12) {\n  const xs$$39 = foldIndexed2(function (i$$5, acc$$14, x$$20, y$$5) {\n    return new List(f$$19(i$$5, x$$20, y$$5), acc$$14);\n  }, new List(), xs$$38, ys$$12);\n  return reverse(xs$$39);\n}\nexport function map3(f$$20, xs$$40, ys$$13, zs$$3) {\n  const xs$$41 = fold3(function (acc$$15, x$$21, y$$6, z$$2) {\n    return new List(f$$20(x$$21, y$$6, z$$2), acc$$15);\n  }, new List(), xs$$40, ys$$13, zs$$3);\n  return reverse(xs$$41);\n}\nexport function mapIndexed3(f$$21, xs$$42, ys$$14, zs$$4) {\n  const xs$$43 = foldIndexed3(function (i$$6, acc$$16, x$$22, y$$7, z$$3) {\n    return new List(f$$21(i$$6, x$$22, y$$7, z$$3), acc$$16);\n  }, new List(), xs$$42, ys$$14, zs$$4);\n  return reverse(xs$$43);\n}\nexport function mapFold(f$$22, s, xs$$44) {\n  const patternInput$$1 = fold(function foldFn(tupledArg, x$$23) {\n    const patternInput = f$$22(tupledArg[1], x$$23);\n    return [new List(patternInput[0], tupledArg[0]), patternInput[1]];\n  }, [new List(), s], xs$$44);\n  return [reverse(patternInput$$1[0]), patternInput$$1[1]];\n}\nexport function mapFoldBack(f$$23, xs$$45, s$$2) {\n  return mapFold(function (s$$3, v) {\n    return f$$23(v, s$$3);\n  }, s$$2, reverse(xs$$45));\n}\nexport function iterate(f$$24, xs$$46) {\n  fold(function (unitVar0, x$$24) {\n    f$$24(x$$24);\n  }, void null, xs$$46);\n}\nexport function iterate2(f$$25, xs$$47, ys$$15) {\n  fold2(function (unitVar0$$1, x$$25, y$$8) {\n    f$$25(x$$25, y$$8);\n  }, void null, xs$$47, ys$$15);\n}\nexport function iterateIndexed(f$$26, xs$$48) {\n  foldIndexed(function (i$$7, unitVar1, x$$26) {\n    f$$26(i$$7, x$$26);\n  }, void null, xs$$48);\n}\nexport function iterateIndexed2(f$$27, xs$$49, ys$$16) {\n  foldIndexed2(function (i$$8, unitVar1$$1, x$$27, y$$9) {\n    f$$27(i$$8, x$$27, y$$9);\n  }, void null, xs$$49, ys$$16);\n}\nexport function ofArray(xs$$50) {\n  let res$$1 = new List();\n\n  for (let i$$9 = count(xs$$50) - 1; i$$9 >= 0; i$$9--) {\n    res$$1 = new List(xs$$50[i$$9], res$$1);\n  }\n\n  return res$$1;\n}\nexport function empty() {\n  return new List();\n}\nexport function isEmpty(_arg1$$8) {\n  if (_arg1$$8.tail == null) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function tryPickIndexedAux($f$$28$$120, $i$$10$$121, $_arg1$$9$$122) {\n  tryPickIndexedAux: while (true) {\n    const f$$28 = $f$$28$$120,\n          i$$10 = $i$$10$$121,\n          _arg1$$9 = $_arg1$$9$$122;\n\n    if (_arg1$$9.tail != null) {\n      const result = f$$28(i$$10, _arg1$$9.head);\n\n      if (result == null) {\n        $f$$28$$120 = f$$28;\n        $i$$10$$121 = i$$10 + 1;\n        $_arg1$$9$$122 = _arg1$$9.tail;\n        continue tryPickIndexedAux;\n      } else {\n        return result;\n      }\n    } else {\n      return undefined;\n    }\n\n    break;\n  }\n}\nexport function tryPickIndexed(f$$29, xs$$52) {\n  return tryPickIndexedAux(f$$29, 0, xs$$52);\n}\nexport function tryPick(f$$30, xs$$53) {\n  return tryPickIndexed(function (_arg1$$10, x$$29) {\n    return f$$30(x$$29);\n  }, xs$$53);\n}\nexport function pick(f$$31, xs$$54) {\n  const matchValue$$5 = tryPick(f$$31, xs$$54);\n\n  if (matchValue$$5 != null) {\n    const x$$30 = value$$1(matchValue$$5);\n    return x$$30;\n  } else {\n    throw new Error(\"List did not contain any matching elements\");\n  }\n}\nexport function tryFindIndexed(f$$32, xs$$55) {\n  return tryPickIndexed(function (i$$11, x$$31) {\n    return f$$32(i$$11, x$$31) ? some(x$$31) : undefined;\n  }, xs$$55);\n}\nexport function tryFind(f$$33, xs$$56) {\n  return tryPickIndexed(function (_arg1$$11, x$$32) {\n    return f$$33(x$$32) ? some(x$$32) : undefined;\n  }, xs$$56);\n}\nexport function findIndexed(f$$34, xs$$57) {\n  const matchValue$$6 = tryFindIndexed(f$$34, xs$$57);\n\n  if (matchValue$$6 != null) {\n    const x$$33 = value$$1(matchValue$$6);\n    return x$$33;\n  } else {\n    throw new Error(\"List did not contain any matching elements\");\n  }\n}\nexport function find(f$$35, xs$$58) {\n  return findIndexed(function (_arg1$$12, x$$34) {\n    return f$$35(x$$34);\n  }, xs$$58);\n}\nexport function findBack(f$$36, xs$$59) {\n  let xs$$61;\n  xs$$61 = reverse(xs$$59);\n  return find(f$$36, xs$$61);\n}\nexport function tryFindBack(f$$37, xs$$62) {\n  let xs$$64;\n  xs$$64 = reverse(xs$$62);\n  return tryFind(f$$37, xs$$64);\n}\nexport function tryFindIndex(f$$38, xs$$65) {\n  return tryPickIndexed(function (i$$12, x$$35) {\n    return f$$38(x$$35) ? i$$12 : undefined;\n  }, xs$$65);\n}\nexport function tryFindIndexBack(f$$39, xs$$66) {\n  const array = ofList(xs$$66, Array);\n  return tryFindIndexBack$$1(f$$39, array);\n}\nexport function findIndex(f$$40, xs$$67) {\n  const matchValue$$7 = tryFindIndex(f$$40, xs$$67);\n\n  if (matchValue$$7 != null) {\n    const x$$36 = matchValue$$7 | 0;\n    return x$$36 | 0;\n  } else {\n    throw new Error(\"List did not contain any matching elements\");\n  }\n}\nexport function findIndexBack(f$$41, xs$$68) {\n  const array$$1 = ofList(xs$$68, Array);\n  return findIndexBack$$1(f$$41, array$$1) | 0;\n}\nexport function item(n, xs$$69) {\n  return findIndexed(function (i$$13, _arg1$$13) {\n    return n === i$$13;\n  }, xs$$69);\n}\nexport function tryItem(n$$1, xs$$70) {\n  return tryFindIndexed(function (i$$14, _arg1$$14) {\n    return n$$1 === i$$14;\n  }, xs$$70);\n}\nexport function filter(f$$42, xs$$71) {\n  const xs$$72 = fold(function (acc$$17, x$$37) {\n    return f$$42(x$$37) ? new List(x$$37, acc$$17) : acc$$17;\n  }, new List(), xs$$71);\n  return reverse(xs$$72);\n}\nexport function partition(f$$43, xs$$73) {\n  return fold(function (tupledArg$$1, x$$38) {\n    return f$$43(x$$38) ? [new List(x$$38, tupledArg$$1[0]), tupledArg$$1[1]] : [tupledArg$$1[0], new List(x$$38, tupledArg$$1[1])];\n  }, [new List(), new List()], reverse(xs$$73));\n}\nexport function choose(f$$44, xs$$74) {\n  const xs$$75 = fold(function (acc$$18, x$$39) {\n    const matchValue$$8 = f$$44(x$$39);\n\n    if (matchValue$$8 == null) {\n      return acc$$18;\n    } else {\n      const y$$10 = value$$1(matchValue$$8);\n      return new List(y$$10, acc$$18);\n    }\n  }, new List(), xs$$74);\n  return reverse(xs$$75);\n}\nexport function contains(value, list, eq) {\n  const loop$$1 = function loop$$1($xs$$76$$162) {\n    loop$$1: while (true) {\n      const xs$$76 = $xs$$76$$162;\n\n      if (xs$$76.tail != null) {\n        if (eq.Equals(value, xs$$76.head)) {\n          return true;\n        } else {\n          $xs$$76$$162 = xs$$76.tail;\n          continue loop$$1;\n        }\n      } else {\n        return false;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$1(list);\n}\nexport function except(itemsToExclude, array$$2, eq$$1) {\n  if (isEmpty(array$$2)) {\n    return array$$2;\n  } else {\n    const cached = createMutable(itemsToExclude, eq$$1);\n    return filter(function f$$45(arg00) {\n      return addToSet(arg00, cached);\n    }, array$$2);\n  }\n}\nexport function initialize(n$$2, f$$46) {\n  let xs$$78 = new List();\n\n  for (let i$$15 = 0; i$$15 <= n$$2 - 1; i$$15++) {\n    xs$$78 = new List(f$$46(i$$15), xs$$78);\n  }\n\n  return reverse(xs$$78);\n}\nexport function replicate(n$$3, x$$40) {\n  return initialize(n$$3, function (_arg1$$15) {\n    return x$$40;\n  });\n}\nexport function reduce(f$$47, _arg1$$16) {\n  if (_arg1$$16.tail != null) {\n    return fold(f$$47, _arg1$$16.head, _arg1$$16.tail);\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function reduceBack(f$$48, _arg1$$17) {\n  if (_arg1$$17.tail != null) {\n    return foldBack(f$$48, _arg1$$17.tail, _arg1$$17.head);\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function forAll(f$$49, xs$$79) {\n  return fold(function (acc$$19, x$$41) {\n    return acc$$19 ? f$$49(x$$41) : false;\n  }, true, xs$$79);\n}\nexport function forAll2(f$$50, xs$$80, ys$$17) {\n  return fold2(function (acc$$20, x$$42, y$$11) {\n    return acc$$20 ? f$$50(x$$42, y$$11) : false;\n  }, true, xs$$80, ys$$17);\n}\nexport function exists($f$$51$$180, $_arg1$$18$$181) {\n  exists: while (true) {\n    const f$$51 = $f$$51$$180,\n          _arg1$$18 = $_arg1$$18$$181;\n\n    if (_arg1$$18.tail != null) {\n      if (f$$51(_arg1$$18.head)) {\n        return true;\n      } else {\n        $f$$51$$180 = f$$51;\n        $_arg1$$18$$181 = _arg1$$18.tail;\n        continue exists;\n      }\n    } else {\n      return false;\n    }\n\n    break;\n  }\n}\nexport function exists2($f$$52$$182, $bs$$2$$183, $cs$$2$$184) {\n  exists2: while (true) {\n    const f$$52 = $f$$52$$182,\n          bs$$2 = $bs$$2$$183,\n          cs$$2 = $cs$$2$$184;\n    var $target$$185, x$$44, xs$$82, y$$12, ys$$18;\n\n    if (bs$$2.tail != null) {\n      if (cs$$2.tail != null) {\n        $target$$185 = 1;\n        x$$44 = bs$$2.head;\n        xs$$82 = bs$$2.tail;\n        y$$12 = cs$$2.head;\n        ys$$18 = cs$$2.tail;\n      } else {\n        $target$$185 = 2;\n      }\n    } else if (cs$$2.tail == null) {\n      $target$$185 = 0;\n    } else {\n      $target$$185 = 2;\n    }\n\n    switch ($target$$185) {\n      case 0:\n        {\n          return false;\n        }\n\n      case 1:\n        {\n          if (f$$52(x$$44, y$$12)) {\n            return true;\n          } else {\n            $f$$52$$182 = f$$52;\n            $bs$$2$$183 = xs$$82;\n            $cs$$2$$184 = ys$$18;\n            continue exists2;\n          }\n        }\n\n      case 2:\n        {\n          throw new Error(\"Lists had different lengths\");\n        }\n    }\n\n    break;\n  }\n}\nexport function unzip(xs$$83) {\n  return foldBack(function (tupledArg$$2, tupledArg$$3) {\n    return [new List(tupledArg$$2[0], tupledArg$$3[0]), new List(tupledArg$$2[1], tupledArg$$3[1])];\n  }, xs$$83, [new List(), new List()]);\n}\nexport function unzip3(xs$$84) {\n  return foldBack(function (tupledArg$$4, tupledArg$$5) {\n    return [new List(tupledArg$$4[0], tupledArg$$5[0]), new List(tupledArg$$4[1], tupledArg$$5[1]), new List(tupledArg$$4[2], tupledArg$$5[2])];\n  }, xs$$84, [new List(), new List(), new List()]);\n}\nexport function zip(xs$$85, ys$$19) {\n  return map2(function (x$$47, y$$15) {\n    return [x$$47, y$$15];\n  }, xs$$85, ys$$19);\n}\nexport function zip3(xs$$86, ys$$20, zs$$5) {\n  return map3(function (x$$48, y$$16, z$$5) {\n    return [x$$48, y$$16, z$$5];\n  }, xs$$86, ys$$20, zs$$5);\n}\nexport function sort(xs$$87, comparer$$1) {\n  let xs$$89;\n  const xs$$88 = ofList(xs$$87, Array);\n  xs$$88.sort(function comparer$$2(x$$49, y$$17) {\n    return comparer$$1.Compare(x$$49, y$$17);\n  });\n  xs$$89 = xs$$88;\n  return ofArray(xs$$89);\n}\nexport function sortBy(projection, xs$$90, comparer$$3) {\n  let xs$$92;\n  const xs$$91 = ofList(xs$$90, Array);\n  xs$$91.sort(function comparer$$4(x$$50, y$$18) {\n    return comparer$$3.Compare(projection(x$$50), projection(y$$18));\n  });\n  xs$$92 = xs$$91;\n  return ofArray(xs$$92);\n}\nexport function sortDescending(xs$$93, comparer$$5) {\n  let xs$$95;\n  const xs$$94 = ofList(xs$$93, Array);\n  xs$$94.sort(function comparer$$6(x$$51, y$$19) {\n    return comparer$$5.Compare(x$$51, y$$19) * -1;\n  });\n  xs$$95 = xs$$94;\n  return ofArray(xs$$95);\n}\nexport function sortByDescending(projection$$1, xs$$96, comparer$$7) {\n  let xs$$98;\n  const xs$$97 = ofList(xs$$96, Array);\n  xs$$97.sort(function comparer$$8(x$$52, y$$20) {\n    return comparer$$7.Compare(projection$$1(x$$52), projection$$1(y$$20)) * -1;\n  });\n  xs$$98 = xs$$97;\n  return ofArray(xs$$98);\n}\nexport function sortWith(comparer$$9, xs$$99) {\n  let xs$$101;\n  const xs$$100 = ofList(xs$$99, Array);\n  xs$$100.sort(comparer$$9);\n  xs$$101 = xs$$100;\n  return ofArray(xs$$101);\n}\nexport function sum(xs$$102, adder) {\n  return fold(function (acc$$21, x$$53) {\n    return adder.Add(acc$$21, x$$53);\n  }, adder.GetZero(), xs$$102);\n}\nexport function sumBy(f$$53, xs$$103, adder$$1) {\n  return fold(function (acc$$22, x$$54) {\n    return adder$$1.Add(acc$$22, f$$53(x$$54));\n  }, adder$$1.GetZero(), xs$$103);\n}\nexport function maxBy(projection$$2, xs$$104, comparer$$11) {\n  return reduce(function (x$$55, y$$21) {\n    return comparer$$11.Compare(projection$$2(y$$21), projection$$2(x$$55)) > 0 ? y$$21 : x$$55;\n  }, xs$$104);\n}\nexport function max(li, comparer$$12) {\n  return reduce(function (x$$56, y$$22) {\n    return comparer$$12.Compare(y$$22, x$$56) > 0 ? y$$22 : x$$56;\n  }, li);\n}\nexport function minBy(projection$$3, xs$$105, comparer$$13) {\n  return reduce(function (x$$57, y$$23) {\n    return comparer$$13.Compare(projection$$3(y$$23), projection$$3(x$$57)) > 0 ? x$$57 : y$$23;\n  }, xs$$105);\n}\nexport function min(xs$$106, comparer$$14) {\n  return reduce(function (x$$58, y$$24) {\n    return comparer$$14.Compare(y$$24, x$$58) > 0 ? x$$58 : y$$24;\n  }, xs$$106);\n}\nexport function average(xs$$107, averager) {\n  const total = fold(function (acc$$23, x$$59) {\n    return averager.Add(acc$$23, x$$59);\n  }, averager.GetZero(), xs$$107);\n  return averager.DivideByInt(total, length(xs$$107));\n}\nexport function averageBy(f$$54, xs$$108, averager$$1) {\n  const total$$1 = fold(function (acc$$24, x$$60) {\n    return averager$$1.Add(acc$$24, f$$54(x$$60));\n  }, averager$$1.GetZero(), xs$$108);\n  return averager$$1.DivideByInt(total$$1, length(xs$$108));\n}\nexport function permute(f$$55, xs$$109) {\n  let xs$$110;\n  let array$$3;\n  array$$3 = ofList(xs$$109, Array);\n  xs$$110 = permute$$1(f$$55, array$$3);\n  return ofArray(xs$$110);\n}\nexport function chunkBySize(chunkSize, xs$$111) {\n  let xs$$114;\n  let xs$$112;\n  let array$$4;\n  array$$4 = ofList(xs$$111, Array);\n  xs$$112 = chunkBySize$$1(chunkSize, array$$4);\n  xs$$114 = ofArray(xs$$112);\n  return map(function f$$56(xs$$113) {\n    return ofArray(xs$$113);\n  }, xs$$114);\n}\nexport function skip(i$$16, xs$$115) {\n  const skipInner = function skipInner($i$$17$$240, $xs$$116$$241) {\n    skipInner: while (true) {\n      const i$$17 = $i$$17$$240,\n            xs$$116 = $xs$$116$$241;\n\n      if (i$$17 === 0) {\n        return xs$$116;\n      } else if (xs$$116.tail != null) {\n        $i$$17$$240 = i$$17 - 1;\n        $xs$$116$$241 = xs$$116.tail;\n        continue skipInner;\n      } else {\n        throw new Error(\"The input sequence has an insufficient number of elements.\");\n      }\n\n      break;\n    }\n  };\n\n  if (i$$16 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$242, i$$20, xs$$119;\n\n    if (i$$16 === 0) {\n      $target$$242 = 0;\n    } else if (i$$16 === 1) {\n      if (xs$$115.tail != null) {\n        $target$$242 = 1;\n      } else {\n        $target$$242 = 2;\n        i$$20 = i$$16;\n        xs$$119 = xs$$115;\n      }\n    } else {\n      $target$$242 = 2;\n      i$$20 = i$$16;\n      xs$$119 = xs$$115;\n    }\n\n    switch ($target$$242) {\n      case 0:\n        {\n          return xs$$115;\n        }\n\n      case 1:\n        {\n          return xs$$115.tail;\n        }\n\n      case 2:\n        {\n          return skipInner(i$$20, xs$$119);\n        }\n    }\n  }\n}\nexport function skipWhile($predicate$$243, $xs$$120$$244) {\n  skipWhile: while (true) {\n    const predicate = $predicate$$243,\n          xs$$120 = $xs$$120$$244;\n    var $target$$245, h$$4, t$$4;\n\n    if (xs$$120.tail != null) {\n      if (predicate(xs$$120.head)) {\n        $target$$245 = 0;\n        h$$4 = xs$$120.head;\n        t$$4 = xs$$120.tail;\n      } else {\n        $target$$245 = 1;\n      }\n    } else {\n      $target$$245 = 1;\n    }\n\n    switch ($target$$245) {\n      case 0:\n        {\n          $predicate$$243 = predicate;\n          $xs$$120$$244 = t$$4;\n          continue skipWhile;\n        }\n\n      case 1:\n        {\n          return xs$$120;\n        }\n    }\n\n    break;\n  }\n}\nexport function takeSplitAux($error$$246, $i$$21$$247, $acc$$25$$248, $xs$$121$$249) {\n  takeSplitAux: while (true) {\n    const error = $error$$246,\n          i$$21 = $i$$21$$247,\n          acc$$25 = $acc$$25$$248,\n          xs$$121 = $xs$$121$$249;\n\n    if (i$$21 === 0) {\n      return [reverse(acc$$25), xs$$121];\n    } else if (xs$$121.tail != null) {\n      $error$$246 = error;\n      $i$$21$$247 = i$$21 - 1;\n      $acc$$25$$248 = new List(xs$$121.head, acc$$25);\n      $xs$$121$$249 = xs$$121.tail;\n      continue takeSplitAux;\n    } else {\n      if (error) {\n        throw new Error(\"The input sequence has an insufficient number of elements.\");\n      } else {\n        return [reverse(acc$$25), xs$$121];\n      }\n    }\n\n    break;\n  }\n}\nexport function take(i$$22, xs$$123) {\n  if (i$$22 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$252, i$$25, xs$$124;\n\n    if (i$$22 === 0) {\n      $target$$252 = 0;\n    } else if (i$$22 === 1) {\n      if (xs$$123.tail != null) {\n        $target$$252 = 1;\n      } else {\n        $target$$252 = 2;\n        i$$25 = i$$22;\n        xs$$124 = xs$$123;\n      }\n    } else {\n      $target$$252 = 2;\n      i$$25 = i$$22;\n      xs$$124 = xs$$123;\n    }\n\n    switch ($target$$252) {\n      case 0:\n        {\n          return new List();\n        }\n\n      case 1:\n        {\n          return new List(xs$$123.head, new List());\n        }\n\n      case 2:\n        {\n          const tuple = takeSplitAux(true, i$$25, new List(), xs$$124);\n          return tuple[0];\n        }\n    }\n  }\n}\nexport function takeWhile(predicate$$1, xs$$125) {\n  if (xs$$125.tail != null) {\n    if (xs$$125.tail.tail == null) {\n      if (predicate$$1(xs$$125.head)) {\n        return xs$$125;\n      } else {\n        return xs$$125.tail;\n      }\n    } else {\n      if (!predicate$$1(xs$$125.head)) {\n        return new List();\n      } else {\n        return new List(xs$$125.head, takeWhile(predicate$$1, xs$$125.tail));\n      }\n    }\n  } else {\n    return xs$$125;\n  }\n}\nexport function truncate(i$$26, xs$$127) {\n  if (i$$26 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$257, i$$29, xs$$128;\n\n    if (i$$26 === 0) {\n      $target$$257 = 0;\n    } else if (i$$26 === 1) {\n      if (xs$$127.tail != null) {\n        $target$$257 = 1;\n      } else {\n        $target$$257 = 2;\n        i$$29 = i$$26;\n        xs$$128 = xs$$127;\n      }\n    } else {\n      $target$$257 = 2;\n      i$$29 = i$$26;\n      xs$$128 = xs$$127;\n    }\n\n    switch ($target$$257) {\n      case 0:\n        {\n          return new List();\n        }\n\n      case 1:\n        {\n          return new List(xs$$127.head, new List());\n        }\n\n      case 2:\n        {\n          const tuple$$1 = takeSplitAux(false, i$$29, new List(), xs$$128);\n          return tuple$$1[0];\n        }\n    }\n  }\n}\nexport function splitAt(i$$30, xs$$129) {\n  if (i$$30 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$260, i$$33, xs$$131;\n\n    if (i$$30 === 0) {\n      $target$$260 = 0;\n    } else if (i$$30 === 1) {\n      if (xs$$129.tail != null) {\n        $target$$260 = 1;\n      } else {\n        $target$$260 = 2;\n        i$$33 = i$$30;\n        xs$$131 = xs$$129;\n      }\n    } else {\n      $target$$260 = 2;\n      i$$33 = i$$30;\n      xs$$131 = xs$$129;\n    }\n\n    switch ($target$$260) {\n      case 0:\n        {\n          return [new List(), xs$$129];\n        }\n\n      case 1:\n        {\n          return [new List(xs$$129.head, new List()), xs$$129.tail];\n        }\n\n      case 2:\n        {\n          return takeSplitAux(true, i$$33, new List(), xs$$131);\n        }\n    }\n  }\n}\nexport function outOfRange() {\n  throw new Error(\"Index out of range\");\n}\nexport function slice(lower, upper, xs$$132) {\n  const lower$$1 = defaultArg(lower, 0) | 0;\n  const hasUpper = upper != null;\n\n  if (lower$$1 < 0) {\n    return outOfRange();\n  } else if (hasUpper ? upper < lower$$1 : false) {\n    return new List();\n  } else {\n    let lastIndex = -1 | 0;\n    let res$$2;\n    const state$$13 = new List();\n    res$$2 = foldIndexed(function f$$57(i$$34, acc$$26, x$$67) {\n      lastIndex = i$$34;\n\n      if (lower$$1 <= i$$34 ? !hasUpper ? true : i$$34 <= upper : false) {\n        return new List(x$$67, acc$$26);\n      } else {\n        return acc$$26;\n      }\n    }, state$$13, xs$$132);\n\n    if (lower$$1 > lastIndex + 1 ? true : hasUpper ? upper > lastIndex : false) {\n      outOfRange();\n    } else {\n      void null;\n    }\n\n    return reverse(res$$2);\n  }\n}\nexport function distinctBy(projection$$4, xs$$134, eq$$2) {\n  const hashSet = createMutable([], eq$$2);\n  return filter(function f$$58($arg$$1) {\n    const arg00$$1 = projection$$4($arg$$1);\n    return addToSet(arg00$$1, hashSet);\n  }, xs$$134);\n}\nexport function distinct(xs$$136, eq$$3) {\n  return distinctBy(function (x$$68) {\n    return x$$68;\n  }, xs$$136, eq$$3);\n}\nexport function exactlyOne(xs$$137) {\n  if (xs$$137.tail != null) {\n    if (xs$$137.tail.tail != null) {\n      throw new Error(\"Input list too long\\\\nParameter name: list\");\n    } else {\n      return xs$$137.head;\n    }\n  } else {\n    throw new Error(\"The input sequence was empty\\\\nParameter name: list\");\n  }\n}\nexport function groupBy(projection$$5, xs$$139, eq$$4) {\n  const dict = createMutable$$1([], eq$$4);\n  let keys = new List();\n  iterate(function f$$59(v$$2) {\n    const key = projection$$5(v$$2);\n    const matchValue$$16 = tryGetValue(dict, key, null);\n\n    if (matchValue$$16[0]) {\n      dict.set(key, new List(v$$2, matchValue$$16[1]));\n    } else {\n      addToDict(dict, key, new List(v$$2, new List()));\n      keys = new List(key, keys);\n    }\n  }, xs$$139);\n  let result$$1 = new List();\n  const xs$$141 = keys;\n  iterate(function f$$60(key$$1) {\n    result$$1 = new List([key$$1, reverse(getItemFromDict(dict, key$$1))], result$$1);\n  }, xs$$141);\n  return result$$1;\n}\nexport function countBy(projection$$6, xs$$142, eq$$5) {\n  const dict$$1 = createMutable$$1([], eq$$5);\n  let keys$$1 = new List();\n  iterate(function f$$61(v$$3) {\n    const key$$2 = projection$$6(v$$3);\n    const matchValue$$17 = tryGetValue(dict$$1, key$$2, 0);\n\n    if (matchValue$$17[0]) {\n      dict$$1.set(key$$2, matchValue$$17[1] + 1);\n    } else {\n      dict$$1.set(key$$2, 1);\n      keys$$1 = new List(key$$2, keys$$1);\n    }\n  }, xs$$142);\n  let result$$2 = new List();\n  const xs$$144 = keys$$1;\n  iterate(function f$$62(key$$3) {\n    result$$2 = new List([key$$3, getItemFromDict(dict$$1, key$$3)], result$$2);\n  }, xs$$144);\n  return result$$2;\n}\nexport function where(predicate$$2, source) {\n  return filter(predicate$$2, source);\n}\nexport function pairwise(source$$1) {\n  const xs$$145 = pairwise$$1(source$$1);\n  return ofSeq(xs$$145);\n}\nexport function windowed(windowSize, source$$2) {\n  if (windowSize <= 0) {\n    throw new Error(\"windowSize must be positive\");\n  } else {\n    void null;\n  }\n\n  let res$$3 = new List();\n\n  for (let i$$35 = length(source$$2); i$$35 >= windowSize; i$$35--) {\n    res$$3 = new List(slice(i$$35 - windowSize, i$$35 - 1, source$$2), res$$3);\n  }\n\n  return res$$3;\n}\nexport function splitInto(chunks, source$$3) {\n  let xs$$148;\n  let xs$$146;\n  let array$$5;\n  array$$5 = ofList(source$$3, Array);\n  xs$$146 = splitInto$$1(chunks, array$$5);\n  xs$$148 = ofArray(xs$$146);\n  return map(function f$$63(xs$$147) {\n    return ofArray(xs$$147);\n  }, xs$$148);\n}\nexport function transpose(lists$$1) {\n  let xs$$150;\n  let source$$5;\n  source$$5 = transpose$$1(lists$$1);\n  xs$$150 = map$$1(ofSeq, source$$5);\n  return ofSeq(xs$$150);\n}","import { substring, join, format, isNullOrEmpty } from \"./String.js\";\nimport { declare } from \"./Types.js\";\nimport { class_type } from \"./Reflection.js\";\nimport { sumBy } from \"./Seq.js\";\nimport { clear } from \"./Util.js\";\nexport const StringBuilder = declare(function System_Text_StringBuilder(value, capacity) {\n  const $this$$1 = this;\n  $this$$1.buf = [];\n\n  if (!isNullOrEmpty(value)) {\n    void $this$$1.buf.push(value);\n  } else {\n    void null;\n  }\n\n  void null;\n});\nexport function StringBuilder$reflection() {\n  return class_type(\"System.Text.StringBuilder\", undefined, StringBuilder);\n}\nexport function StringBuilder$$$$002Ector$$Z18115A39(value, capacity) {\n  return this instanceof StringBuilder ? StringBuilder.call(this, value, capacity) : new StringBuilder(value, capacity);\n}\nexport function StringBuilder$$$$002Ector$$Z524259A4(capacity$$1) {\n  return StringBuilder$$$$002Ector$$Z18115A39.call(this, \"\", capacity$$1);\n}\nexport function StringBuilder$$$$002Ector$$Z721C83C5(value$$1) {\n  return StringBuilder$$$$002Ector$$Z18115A39.call(this, value$$1, 16);\n}\nexport function StringBuilder$$$$002Ector() {\n  return StringBuilder$$$$002Ector$$Z18115A39.call(this, \"\", 16);\n}\nexport function StringBuilder$$Append$$Z721C83C5(x, s) {\n  void x.buf.push(s);\n  return x;\n}\nexport function StringBuilder$$Append$$244C7CD6(x$$1, c) {\n  void x$$1.buf.push(c);\n  return x$$1;\n}\nexport function StringBuilder$$AppendFormat$$433E080(x$$2, fmt, o) {\n  void x$$2.buf.push(format(fmt, o));\n  return x$$2;\n}\nexport function StringBuilder$$AppendLine(x$$3) {\n  void x$$3.buf.push(\"\\n\");\n  return x$$3;\n}\nexport function StringBuilder$$AppendLine$$Z721C83C5(x$$4, s$$1) {\n  void x$$4.buf.push(s$$1);\n  void x$$4.buf.push(\"\\n\");\n  return x$$4;\n}\n\nStringBuilder.prototype.toString = function () {\n  const __ = this;\n  return join(\"\", __.buf);\n};\n\nexport function StringBuilder$$get_Length(x$$5) {\n  return sumBy(function (str) {\n    return str.length;\n  }, x$$5.buf, {\n    GetZero() {\n      return 0;\n    },\n\n    Add($x$$2, $y$$3) {\n      return $x$$2 + $y$$3;\n    }\n\n  }) | 0;\n}\nexport function StringBuilder$$ToString$$Z37302880(x$$6, firstIndex, length) {\n  const str$$1 = String(x$$6);\n  return substring(str$$1, firstIndex, length);\n}\nexport function StringBuilder$$Clear(x$$7) {\n  clear(x$$7.buf);\n  return x$$7;\n}",null,"\"use strict\";\r\n\r\nexport function Parsimmon(action) {\r\n  if (!(this instanceof Parsimmon)) {\r\n    return new Parsimmon(action);\r\n  }\r\n  this._ = action;\r\n}\r\n\r\nvar _ = Parsimmon.prototype;\r\n\r\nexport function times(n, f) {\r\n  var i = 0;\r\n  for (i; i < n; i++) {\r\n    f(i);\r\n  }\r\n}\r\n\r\nexport function forEach(f, arr) {\r\n  times(arr.length, function(i) {\r\n    f(arr[i], i, arr);\r\n  });\r\n}\r\n\r\nexport function reduce(f, seed, arr) {\r\n  forEach(function(elem, i, arr) {\r\n    seed = f(seed, elem, i, arr);\r\n  }, arr);\r\n  return seed;\r\n}\r\n\r\nexport function map(f, arr) {\r\n  return reduce(\r\n    function(acc, elem, i, a) {\r\n      return acc.concat([f(elem, i, a)]);\r\n    },\r\n    [],\r\n    arr\r\n  );\r\n}\r\n\r\nexport function lshiftBuffer(input) {\r\n  var asTwoBytes = reduce(\r\n    function(a, v, i, b) {\r\n      return a.concat(\r\n        i === b.length - 1\r\n          ? Buffer.from([v, 0]).readUInt16BE(0)\r\n          : b.readUInt16BE(i)\r\n      );\r\n    },\r\n    [],\r\n    input\r\n  );\r\n  return Buffer.from(\r\n    map(function(x) {\r\n      return ((x << 1) & 0xffff) >> 8;\r\n    }, asTwoBytes)\r\n  );\r\n}\r\n\r\nfunction consumeBitsFromBuffer(n, input) {\r\n  var state = { v: 0, buf: input };\r\n  times(n, function() {\r\n    state = {\r\n      v: (state.v << 1) | bitPeekBuffer(state.buf),\r\n      buf: lshiftBuffer(state.buf)\r\n    };\r\n  });\r\n  return state;\r\n}\r\n\r\nfunction bitPeekBuffer(input) {\r\n  return input[0] >> 7;\r\n}\r\n\r\nexport function sum(numArr) {\r\n  return reduce(\r\n    function(x, y) {\r\n      return x + y;\r\n    },\r\n    0,\r\n    numArr\r\n  );\r\n}\r\n\r\nexport function find(pred, arr) {\r\n  return reduce(\r\n    function(found, elem) {\r\n      return found || (pred(elem) ? elem : found);\r\n    },\r\n    null,\r\n    arr\r\n  );\r\n}\r\n\r\nfunction bufferExists() {\r\n  return typeof Buffer !== \"undefined\";\r\n}\r\n\r\nfunction ensureBuffer() {\r\n  if (!bufferExists()) {\r\n    throw new Error(\r\n      \"Buffer global does not exist; please consider using https://github.com/feross/buffer if you are running Parsimmon in a browser.\"\r\n    );\r\n  }\r\n}\r\n\r\nfunction bitSeq(alignments) {\r\n  ensureBuffer();\r\n  var totalBits = sum(alignments);\r\n  if (totalBits % 8 !== 0) {\r\n    throw new Error(\r\n      \"The bits [\" +\r\n        alignments.join(\", \") +\r\n        \"] add up to \" +\r\n        totalBits +\r\n        \" which is not an even number of bytes; the total should be divisible by 8\"\r\n    );\r\n  }\r\n  var bytes = totalBits / 8;\r\n\r\n  var tooBigRange = find(function(x) {\r\n    return x > 48;\r\n  }, alignments);\r\n  if (tooBigRange) {\r\n    throw new Error(\r\n      tooBigRange + \" bit range requested exceeds 48 bit (6 byte) Number max.\"\r\n    );\r\n  }\r\n\r\n  return new Parsimmon(function(input, i) {\r\n    var newPos = bytes + i;\r\n    if (newPos > input.length) {\r\n      return makeFailure(i, bytes.toString() + \" bytes\");\r\n    }\r\n    return makeSuccess(\r\n      newPos,\r\n      reduce(\r\n        function(acc, bits) {\r\n          var state = consumeBitsFromBuffer(bits, acc.buf);\r\n          return {\r\n            coll: acc.coll.concat(state.v),\r\n            buf: state.buf\r\n          };\r\n        },\r\n        { coll: [], buf: input.slice(i, newPos) },\r\n        alignments\r\n      ).coll\r\n    );\r\n  });\r\n}\r\n\r\nfunction bitSeqObj(namedAlignments) {\r\n  ensureBuffer();\r\n  var seenKeys = {};\r\n  var totalKeys = 0;\r\n  var fullAlignments = map(function(item) {\r\n    if (isArray(item)) {\r\n      var pair = item;\r\n      if (pair.length !== 2) {\r\n        throw new Error(\r\n          \"[\" +\r\n            pair.join(\", \") +\r\n            \"] should be length 2, got length \" +\r\n            pair.length\r\n        );\r\n      }\r\n      assertString(pair[0]);\r\n      assertNumber(pair[1]);\r\n      if (Object.prototype.hasOwnProperty.call(seenKeys, pair[0])) {\r\n        throw new Error(\"duplicate key in bitSeqObj: \" + pair[0]);\r\n      }\r\n      seenKeys[pair[0]] = true;\r\n      totalKeys++;\r\n      return pair;\r\n    } else {\r\n      assertNumber(item);\r\n      return [null, item];\r\n    }\r\n  }, namedAlignments);\r\n  if (totalKeys < 1) {\r\n    throw new Error(\r\n      \"bitSeqObj expects at least one named pair, got [\" +\r\n        namedAlignments.join(\", \") +\r\n        \"]\"\r\n    );\r\n  }\r\n  var namesOnly = map(function(pair) {\r\n    return pair[0];\r\n  }, fullAlignments);\r\n  var alignmentsOnly = map(function(pair) {\r\n    return pair[1];\r\n  }, fullAlignments);\r\n\r\n  return bitSeq(alignmentsOnly).map(function(parsed) {\r\n    var namedParsed = map(function(name, i) {\r\n      return [name, parsed[i]];\r\n    }, namesOnly);\r\n\r\n    return reduce(\r\n      function(obj, kv) {\r\n        if (kv[0] !== null) {\r\n          obj[kv[0]] = kv[1];\r\n        }\r\n        return obj;\r\n      },\r\n      {},\r\n      namedParsed\r\n    );\r\n  });\r\n}\r\n\r\nfunction parseBufferFor(other, length) {\r\n  ensureBuffer();\r\n  return new Parsimmon(function(input, i) {\r\n    if (i + length > input.length) {\r\n      return makeFailure(i, length + \" bytes for \" + other);\r\n    }\r\n    return makeSuccess(i + length, input.slice(i, i + length));\r\n  });\r\n}\r\n\r\nfunction parseBuffer(length) {\r\n  return parseBufferFor(\"buffer\", length).map(function(unsafe) {\r\n    return Buffer.from(unsafe);\r\n  });\r\n}\r\n\r\nfunction encodedString(encoding, length) {\r\n  return parseBufferFor(\"string\", length).map(function(buff) {\r\n    return buff.toString(encoding);\r\n  });\r\n}\r\n\r\nfunction isInteger(value) {\r\n  return typeof value === \"number\" && Math.floor(value) === value;\r\n}\r\n\r\nfunction assertValidIntegerByteLengthFor(who, length) {\r\n  if (!isInteger(length) || length < 0 || length > 6) {\r\n    throw new Error(who + \" requires integer length in range [0, 6].\");\r\n  }\r\n}\r\n\r\nfunction uintBE(length) {\r\n  assertValidIntegerByteLengthFor(\"uintBE\", length);\r\n  return parseBufferFor(\"uintBE(\" + length + \")\", length).map(function(buff) {\r\n    return buff.readUIntBE(0, length);\r\n  });\r\n}\r\n\r\nfunction uintLE(length) {\r\n  assertValidIntegerByteLengthFor(\"uintLE\", length);\r\n  return parseBufferFor(\"uintLE(\" + length + \")\", length).map(function(buff) {\r\n    return buff.readUIntLE(0, length);\r\n  });\r\n}\r\n\r\nfunction intBE(length) {\r\n  assertValidIntegerByteLengthFor(\"intBE\", length);\r\n  return parseBufferFor(\"intBE(\" + length + \")\", length).map(function(buff) {\r\n    return buff.readIntBE(0, length);\r\n  });\r\n}\r\n\r\nfunction intLE(length) {\r\n  assertValidIntegerByteLengthFor(\"intLE\", length);\r\n  return parseBufferFor(\"intLE(\" + length + \")\", length).map(function(buff) {\r\n    return buff.readIntLE(0, length);\r\n  });\r\n}\r\n\r\nfunction floatBE() {\r\n  return parseBufferFor(\"floatBE\", 4).map(function(buff) {\r\n    return buff.readFloatBE(0);\r\n  });\r\n}\r\n\r\nfunction floatLE() {\r\n  return parseBufferFor(\"floatLE\", 4).map(function(buff) {\r\n    return buff.readFloatLE(0);\r\n  });\r\n}\r\n\r\nfunction doubleBE() {\r\n  return parseBufferFor(\"doubleBE\", 8).map(function(buff) {\r\n    return buff.readDoubleBE(0);\r\n  });\r\n}\r\n\r\nfunction doubleLE() {\r\n  return parseBufferFor(\"doubleLE\", 8).map(function(buff) {\r\n    return buff.readDoubleLE(0);\r\n  });\r\n}\r\n\r\nfunction toArray(arrLike) {\r\n  return Array.prototype.slice.call(arrLike);\r\n}\r\n// -*- Helpers -*-\r\n\r\nfunction isParser(obj) {\r\n  return obj instanceof Parsimmon;\r\n}\r\n\r\nfunction isArray(x) {\r\n  return {}.toString.call(x) === \"[object Array]\";\r\n}\r\n\r\nfunction isBuffer(x) {\r\n  /* global Buffer */\r\n  return bufferExists() && Buffer.isBuffer(x);\r\n}\r\n\r\nexport function makeSuccess(index, value) {\r\n  return {\r\n    status: true,\r\n    index: index,\r\n    value: value,\r\n    furthest: -1,\r\n    expected: []\r\n  };\r\n}\r\n\r\nexport function makeFailure(index, expected) {\r\n  if (!isArray(expected)) {\r\n    expected = [expected];\r\n  }\r\n  return {\r\n    status: false,\r\n    index: -1,\r\n    value: null,\r\n    furthest: index,\r\n    expected: expected\r\n  };\r\n}\r\n\r\nfunction mergeReplies(result, last) {\r\n  if (!last) {\r\n    return result;\r\n  }\r\n  if (result.furthest > last.furthest) {\r\n    return result;\r\n  }\r\n  var expected =\r\n    result.furthest === last.furthest\r\n      ? union(result.expected, last.expected)\r\n      : last.expected;\r\n  return {\r\n    status: result.status,\r\n    index: result.index,\r\n    value: result.value,\r\n    furthest: last.furthest,\r\n    expected: expected\r\n  };\r\n}\r\n\r\nfunction makeLineColumnIndex(input, i) {\r\n  if (isBuffer(input)) {\r\n    return {\r\n      offset: i,\r\n      line: -1,\r\n      column: -1\r\n    };\r\n  }\r\n  var lines = input.slice(0, i).split(\"\\n\");\r\n  // Note that unlike the character offset, the line and column offsets are\r\n  // 1-based.\r\n  var lineWeAreUpTo = lines.length;\r\n  var columnWeAreUpTo = lines[lines.length - 1].length + 1;\r\n  return {\r\n    offset: i,\r\n    line: lineWeAreUpTo,\r\n    column: columnWeAreUpTo\r\n  };\r\n}\r\n\r\n// Returns the sorted set union of two arrays of strings\r\nfunction union(xs, ys) {\r\n  var obj = {};\r\n  for (var i = 0; i < xs.length; i++) {\r\n    obj[xs[i]] = true;\r\n  }\r\n  for (var j = 0; j < ys.length; j++) {\r\n    obj[ys[j]] = true;\r\n  }\r\n  var keys = [];\r\n  for (var k in obj) {\r\n    if ({}.hasOwnProperty.call(obj, k)) {\r\n      keys.push(k);\r\n    }\r\n  }\r\n  keys.sort();\r\n  return keys;\r\n}\r\n\r\nfunction assertParser(p) {\r\n  if (!isParser(p)) {\r\n    throw new Error(\"not a parser: \" + p);\r\n  }\r\n}\r\n\r\nfunction get(input, i) {\r\n  if (typeof input === \"string\") {\r\n    return input.charAt(i);\r\n  }\r\n  return input[i];\r\n}\r\n\r\n// TODO[ES5]: Switch to Array.isArray eventually.\r\nfunction assertArray(x) {\r\n  if (!isArray(x)) {\r\n    throw new Error(\"not an array: \" + x);\r\n  }\r\n}\r\n\r\nfunction assertNumber(x) {\r\n  if (typeof x !== \"number\") {\r\n    throw new Error(\"not a number: \" + x);\r\n  }\r\n}\r\n\r\nfunction assertRegexp(x) {\r\n  if (!(x instanceof RegExp)) {\r\n    throw new Error(\"not a regexp: \" + x);\r\n  }\r\n  var f = flags(x);\r\n  for (var i = 0; i < f.length; i++) {\r\n    var c = f.charAt(i);\r\n    // Only allow regexp flags [imu] for now, since [g] and [y] specifically\r\n    // mess up Parsimmon. If more non-stateful regexp flags are added in the\r\n    // future, this will need to be revisited.\r\n    if (c !== \"i\" && c !== \"m\" && c !== \"u\") {\r\n      throw new Error('unsupported regexp flag \"' + c + '\": ' + x);\r\n    }\r\n  }\r\n}\r\n\r\nfunction assertFunction(x) {\r\n  if (typeof x !== \"function\") {\r\n    throw new Error(\"not a function: \" + x);\r\n  }\r\n}\r\n\r\nfunction assertString(x) {\r\n  if (typeof x !== \"string\") {\r\n    throw new Error(\"not a string: \" + x);\r\n  }\r\n}\r\n\r\n// -*- Error Formatting -*-\r\n\r\nvar linesBeforeStringError = 2;\r\nvar linesAfterStringError = 3;\r\nvar bytesPerLine = 8;\r\nvar bytesBefore = bytesPerLine * 5;\r\nvar bytesAfter = bytesPerLine * 4;\r\nvar defaultLinePrefix = \"  \";\r\n\r\nexport function repeat(string, amount) {\r\n  return new Array(amount + 1).join(string);\r\n}\r\n\r\nexport function formatExpected(expected) {\r\n  if (expected.length === 1) {\r\n    return \"Expected:\\n\\n\" + expected[0];\r\n  }\r\n  return \"Expected one of the following: \\n\\n\" + expected.join(\", \");\r\n}\r\n\r\nexport function leftPad(str, pad, char) {\r\n  var add = pad - str.length;\r\n  if (add <= 0) {\r\n    return str;\r\n  }\r\n  return repeat(char, add) + str;\r\n}\r\n\r\nfunction toChunks(arr, chunkSize) {\r\n  var length = arr.length;\r\n  var chunks = [];\r\n  var chunkIndex = 0;\r\n\r\n  if (length <= chunkSize) {\r\n    return [arr.slice()];\r\n  }\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    if (!chunks[chunkIndex]) {\r\n      chunks.push([]);\r\n    }\r\n\r\n    chunks[chunkIndex].push(arr[i]);\r\n\r\n    if ((i + 1) % chunkSize === 0) {\r\n      chunkIndex++;\r\n    }\r\n  }\r\n\r\n  return chunks;\r\n}\r\n\r\n// Get a range of indexes including `i`-th element and `before` and `after` amount of elements from `arr`.\r\nexport function rangeFromIndexAndOffsets(i, before, after, length) {\r\n  return {\r\n    // Guard against the negative upper bound for lines included in the output.\r\n    from: i - before > 0 ? i - before : 0,\r\n    to: i + after > length ? length : i + after\r\n  };\r\n}\r\n\r\nexport function byteRangeToRange(byteRange) {\r\n  // Exception for inputs smaller than `bytesPerLine`\r\n  if (byteRange.from === 0 && byteRange.to === 1) {\r\n    return {\r\n      from: byteRange.from,\r\n      to: byteRange.to\r\n    };\r\n  }\r\n\r\n  return {\r\n    from: byteRange.from / bytesPerLine,\r\n    // Round `to`, so we don't get float if the amount of bytes is not divisible by `bytesPerLine`\r\n    to: Math.floor(byteRange.to / bytesPerLine)\r\n  };\r\n}\r\n\r\nexport function formatGot(input, error) {\r\n  var index = error.index;\r\n  var i = index.offset;\r\n\r\n  var verticalMarkerLength = 1;\r\n  var column;\r\n  var lineWithErrorIndex;\r\n  var lines;\r\n  var lineRange;\r\n  var lastLineNumberLabelLength;\r\n\r\n  if (i === input.length) {\r\n    return \"Got the end of the input\";\r\n  }\r\n\r\n  if (isBuffer(input)) {\r\n    var byteLineWithErrorIndex = i - (i % bytesPerLine);\r\n    var columnByteIndex = i - byteLineWithErrorIndex;\r\n    var byteRange = rangeFromIndexAndOffsets(\r\n      byteLineWithErrorIndex,\r\n      bytesBefore,\r\n      bytesAfter + bytesPerLine,\r\n      input.length\r\n    );\r\n    var bytes = input.slice(byteRange.from, byteRange.to);\r\n    var bytesInChunks = toChunks(bytes.toJSON().data, bytesPerLine);\r\n\r\n    var byteLines = map(function(byteRow) {\r\n      return map(function(byteValue) {\r\n        // Prefix byte values with a `0` if they are shorter than 2 characters.\r\n        return leftPad(byteValue.toString(16), 2, \"0\");\r\n      }, byteRow);\r\n    }, bytesInChunks);\r\n\r\n    lineRange = byteRangeToRange(byteRange);\r\n    lineWithErrorIndex = byteLineWithErrorIndex / bytesPerLine;\r\n    column = columnByteIndex * 3;\r\n\r\n    // Account for an extra space.\r\n    if (columnByteIndex >= 4) {\r\n      column += 1;\r\n    }\r\n\r\n    verticalMarkerLength = 2;\r\n    lines = map(function(byteLine) {\r\n      return byteLine.length <= 4\r\n        ? byteLine.join(\" \")\r\n        : byteLine.slice(0, 4).join(\" \") + \"  \" + byteLine.slice(4).join(\" \");\r\n    }, byteLines);\r\n    lastLineNumberLabelLength = (\r\n      (lineRange.to > 0 ? lineRange.to - 1 : lineRange.to) * 8\r\n    ).toString(16).length;\r\n\r\n    if (lastLineNumberLabelLength < 2) {\r\n      lastLineNumberLabelLength = 2;\r\n    }\r\n  } else {\r\n    var inputLines = input.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);\r\n    column = index.column - 1;\r\n    lineWithErrorIndex = index.line - 1;\r\n    lineRange = rangeFromIndexAndOffsets(\r\n      lineWithErrorIndex,\r\n      linesBeforeStringError,\r\n      linesAfterStringError,\r\n      inputLines.length\r\n    );\r\n\r\n    lines = inputLines.slice(lineRange.from, lineRange.to);\r\n    lastLineNumberLabelLength = lineRange.to.toString().length;\r\n  }\r\n\r\n  var lineWithErrorCurrentIndex = lineWithErrorIndex - lineRange.from;\r\n\r\n  if (isBuffer(input)) {\r\n    lastLineNumberLabelLength = (\r\n      (lineRange.to > 0 ? lineRange.to - 1 : lineRange.to) * 8\r\n    ).toString(16).length;\r\n\r\n    if (lastLineNumberLabelLength < 2) {\r\n      lastLineNumberLabelLength = 2;\r\n    }\r\n  }\r\n\r\n  var linesWithLineNumbers = reduce(\r\n    function(acc, lineSource, index) {\r\n      var isLineWithError = index === lineWithErrorCurrentIndex;\r\n      var prefix = isLineWithError ? \"> \" : defaultLinePrefix;\r\n      var lineNumberLabel;\r\n\r\n      if (isBuffer(input)) {\r\n        lineNumberLabel = leftPad(\r\n          ((lineRange.from + index) * 8).toString(16),\r\n          lastLineNumberLabelLength,\r\n          \"0\"\r\n        );\r\n      } else {\r\n        lineNumberLabel = leftPad(\r\n          (lineRange.from + index + 1).toString(),\r\n          lastLineNumberLabelLength,\r\n          \" \"\r\n        );\r\n      }\r\n\r\n      return [].concat(\r\n        acc,\r\n        [prefix + lineNumberLabel + \" | \" + lineSource],\r\n        isLineWithError\r\n          ? [\r\n              defaultLinePrefix +\r\n                repeat(\" \", lastLineNumberLabelLength) +\r\n                \" | \" +\r\n                leftPad(\"\", column, \" \") +\r\n                repeat(\"^\", verticalMarkerLength)\r\n            ]\r\n          : []\r\n      );\r\n    },\r\n    [],\r\n    lines\r\n  );\r\n\r\n  return linesWithLineNumbers.join(\"\\n\");\r\n}\r\n\r\nexport function formatError(input, error) {\r\n  return [\r\n    \"\\n\",\r\n    \"-- PARSING FAILED \" + repeat(\"-\", 50),\r\n    \"\\n\\n\",\r\n    formatGot(input, error),\r\n    \"\\n\\n\",\r\n    formatExpected(error.expected),\r\n    \"\\n\"\r\n  ].join(\"\");\r\n}\r\n\r\nexport function flags(re) {\r\n  var s = \"\" + re;\r\n  return s.slice(s.lastIndexOf(\"/\") + 1);\r\n}\r\n\r\nexport function anchoredRegexp(re) {\r\n  return RegExp(\"^(?:\" + re.source + \")\", flags(re));\r\n}\r\n\r\n// -*- Combinators -*-\r\n\r\nexport function seq() {\r\n  var parsers = [].slice.call(arguments);\r\n  var numParsers = parsers.length;\r\n  for (var j = 0; j < numParsers; j += 1) {\r\n    assertParser(parsers[j]);\r\n  }\r\n  return Parsimmon(function(input, i) {\r\n    var result;\r\n    var accum = new Array(numParsers);\r\n    for (var j = 0; j < numParsers; j += 1) {\r\n      result = mergeReplies(parsers[j]._(input, i), result);\r\n      if (!result.status) {\r\n        return result;\r\n      }\r\n      accum[j] = result.value;\r\n      i = result.index;\r\n    }\r\n    return mergeReplies(makeSuccess(i, accum), result);\r\n  });\r\n}\r\n\r\nexport function seqObj() {\r\n  var seenKeys = {};\r\n  var totalKeys = 0;\r\n  var parsers = toArray(arguments);\r\n  var numParsers = parsers.length;\r\n  for (var j = 0; j < numParsers; j += 1) {\r\n    var p = parsers[j];\r\n    if (isParser(p)) {\r\n      continue;\r\n    }\r\n    if (isArray(p)) {\r\n      var isWellFormed =\r\n        p.length === 2 && typeof p[0] === \"string\" && isParser(p[1]);\r\n      if (isWellFormed) {\r\n        var key = p[0];\r\n        if (Object.prototype.hasOwnProperty.call(seenKeys, key)) {\r\n          throw new Error(\"seqObj: duplicate key \" + key);\r\n        }\r\n        seenKeys[key] = true;\r\n        totalKeys++;\r\n        continue;\r\n      }\r\n    }\r\n    throw new Error(\r\n      \"seqObj arguments must be parsers or [string, parser] array pairs.\"\r\n    );\r\n  }\r\n  if (totalKeys === 0) {\r\n    throw new Error(\"seqObj expects at least one named parser, found zero\");\r\n  }\r\n  return Parsimmon(function(input, i) {\r\n    var result;\r\n    var accum = {};\r\n    for (var j = 0; j < numParsers; j += 1) {\r\n      var name;\r\n      var parser;\r\n      if (isArray(parsers[j])) {\r\n        name = parsers[j][0];\r\n        parser = parsers[j][1];\r\n      } else {\r\n        name = null;\r\n        parser = parsers[j];\r\n      }\r\n      result = mergeReplies(parser._(input, i), result);\r\n      if (!result.status) {\r\n        return result;\r\n      }\r\n      if (name) {\r\n        accum[name] = result.value;\r\n      }\r\n      i = result.index;\r\n    }\r\n    return mergeReplies(makeSuccess(i, accum), result);\r\n  });\r\n}\r\n\r\nexport function seqMap() {\r\n  var args = [].slice.call(arguments);\r\n  if (args.length === 0) {\r\n    throw new Error(\"seqMap needs at least one argument\");\r\n  }\r\n  var mapper = args.pop();\r\n  assertFunction(mapper);\r\n  return seq.apply(null, args).map(function(results) {\r\n    return mapper.apply(null, results);\r\n  });\r\n}\r\n\r\n// TODO[ES5]: Revisit this with Object.keys and .bind.\r\nexport function createLanguage(parsers) {\r\n  var language = {};\r\n  for (var key in parsers) {\r\n    if ({}.hasOwnProperty.call(parsers, key)) {\r\n      (function(key) {\r\n        var func = function() {\r\n          return parsers[key](language);\r\n        };\r\n        language[key] = lazy(func);\r\n      })(key);\r\n    }\r\n  }\r\n  return language;\r\n}\r\n\r\nexport function alt() {\r\n  var parsers = [].slice.call(arguments);\r\n  var numParsers = parsers.length;\r\n  if (numParsers === 0) {\r\n    return fail(\"zero alternates\");\r\n  }\r\n  for (var j = 0; j < numParsers; j += 1) {\r\n    assertParser(parsers[j]);\r\n  }\r\n  return Parsimmon(function(input, i) {\r\n    var result;\r\n    for (var j = 0; j < parsers.length; j += 1) {\r\n      result = mergeReplies(parsers[j]._(input, i), result);\r\n      if (result.status) {\r\n        return result;\r\n      }\r\n    }\r\n    return result;\r\n  });\r\n}\r\n\r\nexport function sepBy(parser, separator) {\r\n  // Argument asserted by sepBy1\r\n  return sepBy1(parser, separator).or(succeed([]));\r\n}\r\n\r\nexport function sepBy1(parser, separator) {\r\n  assertParser(parser);\r\n  assertParser(separator);\r\n  var pairs = separator.then(parser).many();\r\n  return seqMap(parser, pairs, function(r, rs) {\r\n    return [r].concat(rs);\r\n  });\r\n}\r\n\r\n// -*- Core Parsing Methods -*-\r\n\r\n_.parse = function(input) {\r\n  if (typeof input !== \"string\" && !isBuffer(input)) {\r\n    throw new Error(\r\n      \".parse must be called with a string or Buffer as its argument\"\r\n    );\r\n  }\r\n  var result = this.skip(eof)._(input, 0);\r\n  if (result.status) {\r\n    return {\r\n      status: true,\r\n      value: result.value\r\n    };\r\n  }\r\n  return {\r\n    status: false,\r\n    index: makeLineColumnIndex(input, result.furthest),\r\n    expected: result.expected\r\n  };\r\n};\r\n\r\n// -*- Other Methods -*-\r\n\r\n_.tryParse = function(str) {\r\n  var result = this.parse(str);\r\n  if (result.status) {\r\n    return result.value;\r\n  } else {\r\n    var msg = formatError(str, result);\r\n    var err = new Error(msg);\r\n    err.type = \"ParsimmonError\";\r\n    err.result = result;\r\n    throw err;\r\n  }\r\n};\r\n\r\n_.or = function(alternative) {\r\n  return alt(this, alternative);\r\n};\r\n\r\n_.trim = function(parser) {\r\n  return this.wrap(parser, parser);\r\n};\r\n\r\n_.wrap = function(leftParser, rightParser) {\r\n  return seqMap(leftParser, this, rightParser, function(left, middle) {\r\n    return middle;\r\n  });\r\n};\r\n\r\n_.thru = function(wrapper) {\r\n  return wrapper(this);\r\n};\r\n\r\n_.then = function(next) {\r\n  assertParser(next);\r\n  return seq(this, next).map(function(results) {\r\n    return results[1];\r\n  });\r\n};\r\n\r\n_.many = function() {\r\n  var self = this;\r\n\r\n  return Parsimmon(function(input, i) {\r\n    var accum = [];\r\n    var result = undefined;\r\n\r\n    for (;;) {\r\n      result = mergeReplies(self._(input, i), result);\r\n      if (result.status) {\r\n        if (i === result.index) {\r\n          throw new Error(\r\n            \"infinite loop detected in .many() parser --- calling .many() on \" +\r\n              \"a parser which can accept zero characters is usually the cause\"\r\n          );\r\n        }\r\n        i = result.index;\r\n        accum.push(result.value);\r\n      } else {\r\n        return mergeReplies(makeSuccess(i, accum), result);\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n_.tieWith = function(separator) {\r\n  assertString(separator);\r\n  return this.map(function(args) {\r\n    assertArray(args);\r\n    if (args.length) {\r\n      assertString(args[0]);\r\n      var s = args[0];\r\n      for (var i = 1; i < args.length; i++) {\r\n        assertString(args[i]);\r\n        s += separator + args[i];\r\n      }\r\n      return s;\r\n    } else {\r\n      return \"\";\r\n    }\r\n  });\r\n};\r\n\r\n_.tie = function() {\r\n  return this.tieWith(\"\");\r\n};\r\n\r\n_.times = function(min, max) {\r\n  var self = this;\r\n  if (arguments.length < 2) {\r\n    max = min;\r\n  }\r\n  assertNumber(min);\r\n  assertNumber(max);\r\n  return Parsimmon(function(input, i) {\r\n    var accum = [];\r\n    var result = undefined;\r\n    var prevResult = undefined;\r\n    for (var times = 0; times < min; times += 1) {\r\n      result = self._(input, i);\r\n      prevResult = mergeReplies(result, prevResult);\r\n      if (result.status) {\r\n        i = result.index;\r\n        accum.push(result.value);\r\n      } else {\r\n        return prevResult;\r\n      }\r\n    }\r\n    for (; times < max; times += 1) {\r\n      result = self._(input, i);\r\n      prevResult = mergeReplies(result, prevResult);\r\n      if (result.status) {\r\n        i = result.index;\r\n        accum.push(result.value);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return mergeReplies(makeSuccess(i, accum), prevResult);\r\n  });\r\n};\r\n\r\n_.result = function(res) {\r\n  return this.map(function() {\r\n    return res;\r\n  });\r\n};\r\n\r\n_.atMost = function(n) {\r\n  return this.times(0, n);\r\n};\r\n\r\n_.atLeast = function(n) {\r\n  return seqMap(this.times(n), this.many(), function(init, rest) {\r\n    return init.concat(rest);\r\n  });\r\n};\r\n\r\n_.map = function(fn) {\r\n  assertFunction(fn);\r\n  var self = this;\r\n  return Parsimmon(function(input, i) {\r\n    var result = self._(input, i);\r\n    if (!result.status) {\r\n      return result;\r\n    }\r\n    return mergeReplies(makeSuccess(result.index, fn(result.value)), result);\r\n  });\r\n};\r\n\r\n_.contramap = function(fn) {\r\n  assertFunction(fn);\r\n  var self = this;\r\n  return Parsimmon(function(input, i) {\r\n    var result = self.parse(fn(input.slice(i)));\r\n    if (!result.status) {\r\n      return result;\r\n    }\r\n    return makeSuccess(i + input.length, result.value);\r\n  });\r\n};\r\n\r\n_.promap = function(f, g) {\r\n  assertFunction(f);\r\n  assertFunction(g);\r\n  return this.contramap(f).map(g);\r\n};\r\n\r\n_.skip = function(next) {\r\n  return seq(this, next).map(function(results) {\r\n    return results[0];\r\n  });\r\n};\r\n\r\n_.mark = function() {\r\n  return seqMap(index, this, index, function(start, value, end) {\r\n    return {\r\n      start: start,\r\n      value: value,\r\n      end: end\r\n    };\r\n  });\r\n};\r\n\r\n_.node = function(name) {\r\n  return seqMap(index, this, index, function(start, value, end) {\r\n    return {\r\n      name: name,\r\n      value: value,\r\n      start: start,\r\n      end: end\r\n    };\r\n  });\r\n};\r\n\r\n_.sepBy = function(separator) {\r\n  return sepBy(this, separator);\r\n};\r\n\r\n_.sepBy1 = function(separator) {\r\n  return sepBy1(this, separator);\r\n};\r\n\r\n_.lookahead = function(x) {\r\n  return this.skip(lookahead(x));\r\n};\r\n\r\n_.notFollowedBy = function(x) {\r\n  return this.skip(notFollowedBy(x));\r\n};\r\n\r\n_.desc = function(expected) {\r\n  if (!isArray(expected)) {\r\n    expected = [expected];\r\n  }\r\n  var self = this;\r\n  return Parsimmon(function(input, i) {\r\n    var reply = self._(input, i);\r\n    if (!reply.status) {\r\n      reply.expected = expected;\r\n    }\r\n    return reply;\r\n  });\r\n};\r\n\r\n_.fallback = function(result) {\r\n  return this.or(succeed(result));\r\n};\r\n\r\n_.ap = function(other) {\r\n  return seqMap(other, this, function(f, x) {\r\n    return f(x);\r\n  });\r\n};\r\n\r\n_.chain = function(f) {\r\n  var self = this;\r\n  return Parsimmon(function(input, i) {\r\n    var result = self._(input, i);\r\n    if (!result.status) {\r\n      return result;\r\n    }\r\n    var nextParser = f(result.value);\r\n    return mergeReplies(nextParser._(input, result.index), result);\r\n  });\r\n};\r\n\r\n// -*- Constructors -*-\r\n\r\nexport function string(str) {\r\n  assertString(str);\r\n  var expected = \"'\" + str + \"'\";\r\n  return Parsimmon(function(input, i) {\r\n    var j = i + str.length;\r\n    var head = input.slice(i, j);\r\n    if (head === str) {\r\n      return makeSuccess(j, head);\r\n    } else {\r\n      return makeFailure(i, expected);\r\n    }\r\n  });\r\n}\r\n\r\nexport function byte(b) {\r\n  ensureBuffer();\r\n  assertNumber(b);\r\n  if (b > 0xff) {\r\n    throw new Error(\r\n      \"Value specified to byte constructor (\" +\r\n        b +\r\n        \"=0x\" +\r\n        b.toString(16) +\r\n        \") is larger in value than a single byte.\"\r\n    );\r\n  }\r\n  var expected = (b > 0xf ? \"0x\" : \"0x0\") + b.toString(16);\r\n  return Parsimmon(function(input, i) {\r\n    var head = get(input, i);\r\n    if (head === b) {\r\n      return makeSuccess(i + 1, head);\r\n    } else {\r\n      return makeFailure(i, expected);\r\n    }\r\n  });\r\n}\r\n\r\nexport function regexp(re, group) {\r\n  assertRegexp(re);\r\n  if (arguments.length >= 2) {\r\n    assertNumber(group);\r\n  } else {\r\n    group = 0;\r\n  }\r\n  var anchored = anchoredRegexp(re);\r\n  var expected = \"\" + re;\r\n  return Parsimmon(function(input, i) {\r\n    var match = anchored.exec(input.slice(i));\r\n    if (match) {\r\n      if (0 <= group && group <= match.length) {\r\n        var fullMatch = match[0];\r\n        var groupMatch = match[group];\r\n        return makeSuccess(i + fullMatch.length, groupMatch);\r\n      }\r\n      var message =\r\n        \"valid match group (0 to \" + match.length + \") in \" + expected;\r\n      return makeFailure(i, message);\r\n    }\r\n    return makeFailure(i, expected);\r\n  });\r\n}\r\n\r\nexport function succeed(value) {\r\n  return Parsimmon(function(input, i) {\r\n    return makeSuccess(i, value);\r\n  });\r\n}\r\n\r\nexport function fail(expected) {\r\n  return Parsimmon(function(input, i) {\r\n    return makeFailure(i, expected);\r\n  });\r\n}\r\n\r\nexport function lookahead(x) {\r\n  if (isParser(x)) {\r\n    return Parsimmon(function(input, i) {\r\n      var result = x._(input, i);\r\n      result.index = i;\r\n      result.value = \"\";\r\n      return result;\r\n    });\r\n  } else if (typeof x === \"string\") {\r\n    return lookahead(string(x));\r\n  } else if (x instanceof RegExp) {\r\n    return lookahead(regexp(x));\r\n  }\r\n  throw new Error(\"not a string, regexp, or parser: \" + x);\r\n}\r\n\r\nexport function notFollowedBy(parser) {\r\n  assertParser(parser);\r\n  return Parsimmon(function(input, i) {\r\n    var result = parser._(input, i);\r\n    var text = input.slice(i, result.index);\r\n    return result.status\r\n      ? makeFailure(i, 'not \"' + text + '\"')\r\n      : makeSuccess(i, null);\r\n  });\r\n}\r\n\r\nexport function test(predicate) {\r\n  assertFunction(predicate);\r\n  return Parsimmon(function(input, i) {\r\n    var char = get(input, i);\r\n    if (i < input.length && predicate(char)) {\r\n      return makeSuccess(i + 1, char);\r\n    } else {\r\n      return makeFailure(i, \"a character/byte matching \" + predicate);\r\n    }\r\n  });\r\n}\r\n\r\nexport function oneOf(str) {\r\n  var expected = str.split(\"\");\r\n  for (var idx = 0; idx < expected.length; idx++) {\r\n    expected[idx] = \"'\" + expected[idx] + \"'\";\r\n  }\r\n  return test(function(ch) {\r\n    return str.indexOf(ch) >= 0;\r\n  }).desc(expected);\r\n}\r\n\r\nexport function noneOf(str) {\r\n  return test(function(ch) {\r\n    return str.indexOf(ch) < 0;\r\n  }).desc(\"none of '\" + str + \"'\");\r\n}\r\n\r\nexport function custom(parsingFunction) {\r\n  return Parsimmon(parsingFunction(makeSuccess, makeFailure));\r\n}\r\n\r\n// TODO[ES5]: Improve error message using JSON.stringify eventually.\r\nexport function range(begin, end) {\r\n  return test(function(ch) {\r\n    return begin <= ch && ch <= end;\r\n  }).desc(begin + \"-\" + end);\r\n}\r\n\r\nexport function takeWhile(predicate) {\r\n  assertFunction(predicate);\r\n\r\n  return Parsimmon(function(input, i) {\r\n    var j = i;\r\n    while (j < input.length && predicate(get(input, j))) {\r\n      j++;\r\n    }\r\n    return makeSuccess(j, input.slice(i, j));\r\n  });\r\n}\r\n\r\nexport function lazy(desc, f) {\r\n  if (arguments.length < 2) {\r\n    f = desc;\r\n    desc = undefined;\r\n  }\r\n\r\n  var parser = Parsimmon(function(input, i) {\r\n    parser._ = f()._;\r\n    return parser._(input, i);\r\n  });\r\n\r\n  if (desc) {\r\n    return parser.desc(desc);\r\n  } else {\r\n    return parser;\r\n  }\r\n}\r\n\r\n// -*- Fantasy Land Extras -*-\r\n\r\nfunction empty() {\r\n  return fail(\"fantasy-land/empty\");\r\n}\r\n\r\n_.concat = _.or;\r\n_.empty = empty;\r\n_.of = succeed;\r\n_[\"fantasy-land/ap\"] = _.ap;\r\n_[\"fantasy-land/chain\"] = _.chain;\r\n_[\"fantasy-land/concat\"] = _.concat;\r\n_[\"fantasy-land/empty\"] = _.empty;\r\n_[\"fantasy-land/of\"] = _.of;\r\n_[\"fantasy-land/map\"] = _.map;\r\n\r\n// -*- Base Parsers -*-\r\n\r\nexport const index = Parsimmon(function(input, i) {\r\n  return makeSuccess(i, makeLineColumnIndex(input, i));\r\n});\r\n\r\nexport const any = Parsimmon(function(input, i) {\r\n  if (i >= input.length) {\r\n    return makeFailure(i, \"any character/byte\");\r\n  }\r\n  return makeSuccess(i + 1, get(input, i));\r\n});\r\n\r\nexport const all = Parsimmon(function(input, i) {\r\n  return makeSuccess(input.length, input.slice(i));\r\n});\r\n\r\nexport const eof = Parsimmon(function(input, i) {\r\n  if (i < input.length) {\r\n    return makeFailure(i, \"EOF\");\r\n  }\r\n  return makeSuccess(i, null);\r\n});\r\n\r\nexport const digit = regexp(/[0-9]/).desc(\"a digit\");\r\nexport const digits = regexp(/[0-9]*/).desc(\"optional digits\");\r\nexport const letter = regexp(/[a-z]/i).desc(\"a letter\");\r\nexport const letters = regexp(/[a-z]*/i).desc(\"optional letters\");\r\nexport const optWhitespace = regexp(/\\s*/).desc(\"optional whitespace\");\r\nexport const whitespace = regexp(/\\s+/).desc(\"whitespace\");\r\nexport const cr = string(\"\\r\");\r\nexport const lf = string(\"\\n\");\r\nexport const crlf = string(\"\\r\\n\");\r\nexport const newline = alt(crlf, lf, cr).desc(\"newline\");\r\nexport const end = alt(newline, eof);","namespace Fable.Parsimmon\r\n\r\nopen Fable.Core\r\nopen Fable.Core.JsInterop\r\n\r\ntype ParseResult<'t> =\r\n    abstract status : bool\r\n    abstract value : 't\r\n\r\ntype IParserOffSet =\r\n    abstract offset : int\r\n    abstract line : int\r\n    abstract column : int\r\n\r\ntype TokenPosition =\r\n    { offset: int\r\n      line: int\r\n      column: int }\r\n\r\ntype NodeResult<'t> =\r\n    { name: string\r\n      value: 't\r\n      start: TokenPosition\r\n      ``end``: TokenPosition }\r\n\r\ntype IParser<'t> =\r\n    abstract map<'u> : ('t -> 'u) -> IParser<'u>\r\n    abstract parse : string -> ParseResult<'t>\r\n    abstract times : int -> IParser<'t []>\r\n    abstract times : int * int -> IParser<'t []>\r\n    abstract many : unit -> IParser<'t []>\r\n    [<Emit(\"$0.then($1)\")>]\r\n    abstract chain : IParser<'u> -> IParser<'u>\r\n    [<Emit(\"$0.chain($1)\")>]\r\n    abstract bind : ('t -> IParser<'u>) -> IParser<'u>\r\n    abstract skip : IParser<'u> -> IParser<'t>\r\n    abstract sepBy : IParser<'u> -> IParser<'t []>\r\n    abstract fallback : 't -> IParser<'t>\r\n    abstract trim : IParser<'u> -> IParser<'t>\r\n    abstract notFollowedBy : IParser<'u> -> IParser<'t>\r\n    abstract atMost : int -> IParser<'t[]>\r\n    abstract atLeast : int -> IParser<'t[]>\r\n    [<Emit(\"$0.or($1)\")>]\r\n    abstract orTry : IParser<'t> -> IParser<'t>\r\n    abstract sepBy1 : IParser<'u> -> IParser<'t []>\r\n    [<Emit(\"$0.node($1)\")>]\r\n    abstract node : string -> IParser<NodeResult<'t>>\r\n\r\nmodule Parsimmon =\r\n    let parseRaw (input: string) (parser: IParser<'t>) =\r\n        parser.parse input\r\n\r\n    let parse (input: string) (parser: IParser<'t>) =\r\n        parser.parse input\r\n        |> fun result ->\r\n            match result.status with\r\n            | true -> Some result.value\r\n            | false -> None\r\n\r\n    /// A parser that consumes no input and yields an object an object representing the current offset into the parse: it has a 0-based character offset property and 1-based line and column properties\r\n    let index : IParser<IParserOffSet> =\r\n        import \"index\" \"./Parsimmon.js\"\r\n\r\n    /// Returns a new parser which tries parser, and if it fails uses otherParser. Example:\r\n    let orTry (otherParser: IParser<'t>) (parser: IParser<'t>) : IParser<'t> =\r\n        parser.orTry(otherParser)\r\n\r\n    /// Returns a new parser that tries to parse the input exactly `n` times\r\n    let times<'t> (n: int) (parser : IParser<'t>) : IParser<'t[]> =\r\n        parser.times n\r\n\r\n    /// Expects parser at least n times. Yields an array of the results.\r\n    let atLeast (n: int) (parser: IParser<'t>) : IParser<'t[]> =\r\n        parser.atLeast n\r\n\r\n\r\n    /// Expects parser at most n times. Yields an array of the results.\r\n    let atMost (n: int) (parser: IParser<'t>) : IParser<'t[]> =\r\n        parser.atMost n\r\n\r\n    let skip (skipped: IParser<'u>) (keep: IParser<'t>) : IParser<'t> =\r\n        keep.skip skipped\r\n\r\n    let many (parser : IParser<'t>) : IParser<'t[]> =\r\n        parser.many()\r\n\r\n    /// Returns a parser that looks for a match to the regexp and yields the entire text matched. The regexp will always match starting at the current parse location.\r\n    [<Import(\"regexp\", \"./Parsimmon.js\"); Emit(\"$0(new RegExp($1))\")>]\r\n    let regex (pattern: string) : IParser<string> = jsNative\r\n    /// Returns a parser that looks for a match to the regexp and yields the entire text matched. The regexp will always match starting at the current parse location.\r\n    [<Import(\"regexp\", \"./Parsimmon.js\"); Emit(\"$0(new RegExp($1), $2)\")>]\r\n    let regexGroupNumber (pattern: string) (groupNumber: int): IParser<string> = jsNative\r\n    let ofLazy (f: unit -> IParser<'t>) : IParser<'t> =\r\n        import \"lazy\" \"./Parsimmon.js\"\r\n\r\n    /// This is the same as Parsimmon.sepBy, but matches the parser at least once.\r\n    let seperateByAtLeastOne (seperator : IParser<'u>) (parser: IParser<'t>) : IParser<'t[]> =\r\n        parser.sepBy1(seperator)\r\n\r\n    /// Expects parser \"after\" to follow parser \"before\", and yields the result of \"before\".\r\n    let chain  (after: IParser<'u>) (before: IParser<'t>) : IParser<'u> =\r\n        before.chain after\r\n\r\n    /// Returns a new parser which tries parser \"p\", and on success calls the function \"f\" with the result of the parse, which is expected to return another parser, which will be tried next. This allows you to dynamically decide how to continue the parse, which is impossible with the other combinators.\r\n    let bind (f: 't -> IParser<'u>) (p: IParser<'t>) : IParser<'u> =\r\n        p.bind f\r\n\r\n    /// A parser that consumes one letter\r\n    let letter : IParser<string> =\r\n        import \"letter\" \"./Parsimmon.js\"\r\n\r\n    /// Returns a parser that tries `parser` and succeeds if `parser` is able to parse between `min` and `max` times\r\n    let timesBetween (min: int) (max: int) (parser: IParser<'u>) =\r\n        parser.times(min, max)\r\n\r\n    /// A parser that consumes one or more letters\r\n    let letters : IParser<string[]> =\r\n        import \"letters\" \"./Parsimmon.js\"\r\n\r\n    /// A parser that expects to be at the end of the input (zero characters left).\r\n    let endOfFile : IParser<string> =\r\n        import \"eof\" \"./Parsimmon.js\"\r\n\r\n    /// Returns a parser that looks for anything but whatever \"p\" wants to parse, and does not consume it. Yields the same result as \"before\".\r\n    let notFollowedBy (p: IParser<'u>) (before: IParser<'t>) : IParser<'t> =\r\n        before.notFollowedBy p\r\n\r\n    /// Returns a parser that doesn't consume any input, and yields the given value\r\n    let succeed (value: 't) : IParser<'t> =\r\n        import \"succeed\" \"./Parsimmon.js\"\r\n\r\n    /// Parses using parser, but does not consume what it parses. Yields an empty string.\r\n    let lookahead (parser: IParser<'t>) : IParser<string> =\r\n        import \"lookahead\" \"./Parsimmon.js\"\r\n\r\n    // A parser that consumes one digit\r\n    let digit : IParser<string> =\r\n        import \"digit\" \"./Parsimmon.js\"\r\n\r\n    // A parser that consumes one or more digits\r\n    let digits : IParser<string[]> =\r\n        digit\r\n        |> many\r\n\r\n    /// Returns a new parser which tries \"parser\" and, if it fails, yields value without consuming any input.\r\n    let fallback (value: 't) (parser: IParser<'t>) : IParser<'t> =\r\n        parser.fallback value\r\n\r\n    let seperateBy (content: IParser<'u>) (others: IParser<'t>) : IParser<'t[]> =\r\n        others.sepBy(content)\r\n\r\n    let between (left: IParser<'t>) (right: IParser<'u>) (middle: IParser<'v>) =\r\n        left\r\n        |> chain middle\r\n        |> skip right\r\n\r\n    /// Transforms the parsed value of the given parser.\r\n    let map (f: 't -> 'u) (parser: IParser<'t>) = parser.map f\r\n\r\n    /// Alias of Parsimmon.concat\r\n    let tie (parser: IParser<string[]>) : IParser<string> =\r\n        map (String.concat \"\") parser\r\n\r\n    /// A parser that consumes and yields the next character of the input.\r\n    let any : IParser<string> =\r\n        import \"any\" \"./Parsimmon.js\"\r\n\r\n    /// Accepts any number of parsers, yielding the value of the first one that succeeds, backtracking in between.\r\n    let choose (ps: IParser<'t> list) : IParser<'t> =\r\n        List.reduce (fun acc parser -> acc.orTry(parser)) ps\r\n\r\n    /// A parser that consumes and yields the entire remainder of the input.\r\n    let all : IParser<string> =\r\n        import \"all\"  \"./Parsimmon.js\"\r\n\r\n    /// Returns a failing parser with the given message.\r\n    let fail (input: string) : IParser<string> =\r\n        import \"fail\" \"./Parsimmon.js\"\r\n\r\n    /// Returns a parser that yield a single character if it passes the predicate function.\r\n    let satisfy (f: string -> bool) : IParser<string> =\r\n        import \"test\" \"./Parsimmon.js\"\r\n\r\n    /// Returns a parser yield a string containing all the next characters that pass the predicate \"f\"\r\n    let takeWhile (f: string -> bool) : IParser<string> =\r\n        import \"takeWhile\" \"./Parsimmon.js\"\r\n\r\n    /// Returns a parser that can only parse the exact given input string\r\n    let str (input: string) : IParser<string> =\r\n        import \"string\" \"./Parsimmon.js\"\r\n\r\n    /// Returns a parser that parses any of the characters of the input string\r\n    let oneOf (input: string) : IParser<string> =\r\n        import \"oneOf\" \"./Parsimmon.js\"\r\n\r\n    let whitespace : IParser<string> =\r\n        import \"whitespace\" \"./Parsimmon.js\"\r\n\r\n    let optionalWhitespace : IParser<string> =\r\n        import \"optWhitespace\" \"./Parsimmon.js\"\r\n\r\n    /// Returns a parser that succeeds one or more times\r\n    let atLeastOneOrMany (parser: IParser<'t>) : IParser<'t[]> =\r\n        atLeast 1 parser\r\n\r\n    let stringReturn (input: string) (value: 't) : IParser<'t> =\r\n        str input\r\n        |> map (fun _ -> value)\r\n\r\n    /// Returns a parser that parses comsumes any character of a string other than the characters of the input string\r\n    let noneOf (input: string) : IParser<string> =\r\n        import \"noneOf\" \"./Parsimmon.js\"\r\n\r\n    let seq2 (p1: IParser<'t>) (p2:IParser<'u>) :  IParser<'t * 'u> =\r\n        import \"seq\" \"./Parsimmon.js\"\r\n\r\n    let trim (trimmed: IParser<'a>) (p: IParser<'t>) : IParser<'t> =\r\n        p.trim trimmed\r\n\r\n    /// Equivalent to `parser.map (String.concat \"\")`\r\n    let concat (parser: IParser<string[]>) : IParser<string> =\r\n        parser.map (String.concat \"\")\r\n\r\n    let seq3 (p1: IParser<'t>)\r\n             (p2: IParser<'u>)\r\n             (p3:IParser<'v>) :  IParser<'t * 'u * 'v> =\r\n        import \"seq\" \"./Parsimmon.js\"\r\n\r\n    let seq4 (p1: IParser<'t>)\r\n             (p2: IParser<'u>)\r\n             (p3:IParser<'v>)\r\n             (p4:IParser<'w>) :  IParser<'t * 'u * 'v * 'w> =\r\n        import \"seq\" \"./Parsimmon.js\"\r\n\r\n    let seq5 (p1: IParser<'t>)\r\n             (p2: IParser<'u>)\r\n             (p3: IParser<'v>)\r\n             (p4: IParser<'w>)\r\n             (p5: IParser<'q>) : IParser<'t * 'u * 'v * 'w * 'q> =\r\n        import \"seq\" \"./Parsimmon.js\"\r\n\r\n    /// Equivalent to `parser.node(\"description\")`\r\n    let node<'t> description (p:IParser<'t>) = p.node(description)","namespace Fable.SimpleJson\n\nopen Fable.Parsimmon\n\n#nowarn \"40\"\n\nmodule Parser =\n\n    let digits = \n        Parsimmon.digit \n        |> Parsimmon.atLeastOneOrMany\n        |> Parsimmon.concat\n\n    let jint = digits |> Parsimmon.map float\n\n    let negJint = \n        Parsimmon.seq2 (Parsimmon.str \"-\") jint \n        |> Parsimmon.map (fun (sign, number) -> -number)\n\n    let jfloat =\n        let floatWithComma =\n            Parsimmon.regex \"-?(0|[1-9][0-9]*)?[.][0-9]+([eE][+-]?[0-9]+)?\"\n        let floatWithoutComma =\n            Parsimmon.regex \"-?[1-9][0-9]*[eE][+-]?[0-9]+\"\n\n        [ floatWithComma; floatWithoutComma ]\n        |> Parsimmon.choose\n        |> Parsimmon.map float\n\n    let jnumber = \n        [jfloat; jint; negJint] \n        |> Parsimmon.choose\n        |> Parsimmon.map JNumber\n\n    let jbool = \n        [ Parsimmon.stringReturn \"true\" (JBool true)\n          Parsimmon.stringReturn \"false\" (JBool false)]\n        |> Parsimmon.choose\n\n    let jnull = Parsimmon.stringReturn \"null\" JNull\n\n    let stringLiteral =\n        let escape =  \n            Parsimmon.oneOf \"\\\"\\\\/bfnrt\"\n            |> Parsimmon.map(function\n                | \"b\" -> \"\\b\"\n                | \"f\" -> \"\\u000C\"\n                | \"n\" -> \"\\n\"\n                | \"r\" -> \"\\r\"\n                | \"t\" -> \"\\t\"\n                | c   -> c) // every other char is mapped to itself\n\n        let escapedCharSnippet = \n            Parsimmon.seq2 (Parsimmon.str \"\\\\\") escape\n            |> Parsimmon.map snd\n\n        let normalCharSnippet = Parsimmon.satisfy (fun c -> c <> \"\\\"\" && c <> \"\\\\\")\n\n        let anyCharSnippet = \n            normalCharSnippet\n            |> Parsimmon.orTry escapedCharSnippet\n            |> Parsimmon.many\n            |> Parsimmon.concat\n\n        anyCharSnippet\n        |> Parsimmon.between (Parsimmon.str \"\\\"\") (Parsimmon.str \"\\\"\")\n        \n    let jstring = stringLiteral.map JString\n\n    let withWhitespace p = \n        Parsimmon.between (Parsimmon.optionalWhitespace) (Parsimmon.optionalWhitespace) p\n        \n    let jvalue = \n        [ jnull; jbool; jnumber; jstring ]\n        |> List.map withWhitespace\n        |> Parsimmon.choose\n    \n    let comma = withWhitespace (Parsimmon.str \",\")\n \n    let rec json = Parsimmon.ofLazy <| fun () ->\n        \n        let leftBracket = withWhitespace (Parsimmon.str \"[\")\n        let rightBracket = withWhitespace (Parsimmon.str \"]\")\n                    \n        let arrayValue = Parsimmon.seperateBy comma json\n        \n        let jarray = \n            arrayValue\n            |> Parsimmon.between leftBracket rightBracket\n            |> Parsimmon.map (List.ofArray >> JArray)\n\n        let leftBrace = withWhitespace (Parsimmon.str \"{\")\n        let rightBrace = withWhitespace (Parsimmon.str \"}\")\n            \n        let keyValues = \n            Parsimmon.seq3 \n                (withWhitespace stringLiteral)\n                (withWhitespace (Parsimmon.str \":\"))\n                (withWhitespace json)\n            |> Parsimmon.map (fun (key, _ , value) -> key,value)\n            |> Parsimmon.seperateBy comma\n\n        let jobject = \n            keyValues\n            |> Parsimmon.between leftBrace rightBrace\n            |> Parsimmon.map (List.ofArray >> Map.ofList >> JObject)\n\n        [jvalue; jarray; jobject]\n        |> Parsimmon.choose\n        \n    let jsonParser = withWhitespace json\n","import { List, declare, Record } from \"../Types.js\";\nimport { record_type, array_type, int32_type } from \"../Reflection.js\";\nimport { op_LeftShift, op_BitwiseAnd, op_Addition, compare, op_Subtraction, op_Division, equals, toInt, op_Modulus, op_Multiply, fromInteger, fromBits } from \"../Long.js\";\nimport { ofList, copy, initialize, map, fill } from \"../Array.js\";\nimport { int32ToString } from \"../Util.js\";\nimport { isNullOrEmpty, join } from \"../String.js\";\nexport const BigNat = declare(function BigInt_BigNat(bound, digits) {\n  this.bound = bound | 0;\n  this.digits = digits;\n}, Record);\nexport function BigNat$reflection() {\n  return record_type(\"BigInt.BigNat\", [], BigNat, () => [[\"bound\", int32_type], [\"digits\", array_type(int32_type)]]);\n}\nexport function BigNatModule$002EFFT$$$pow32($x$$1, $n$$2) {\n  BigNatModule$002EFFT$$$pow32: while (true) {\n    const x = $x$$1,\n          n = $n$$2;\n\n    if (n === 0) {\n      return 1;\n    } else if (n % 2 === 0) {\n      $x$$1 = x * x;\n      $n$$2 = ~~(n / 2);\n      continue BigNatModule$002EFFT$$$pow32;\n    } else {\n      return x * BigNatModule$002EFFT$$$pow32(x * x, ~~(n / 2)) | 0;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$002EFFT$$$leastBounding2Power(b) {\n  const findBounding2Power = function findBounding2Power($b$$1$$4, $tp$$5, $i$$6) {\n    findBounding2Power: while (true) {\n      const b$$1 = $b$$1$$4,\n            tp = $tp$$5,\n            i = $i$$6;\n\n      if (b$$1 <= tp) {\n        return [tp, i];\n      } else {\n        $b$$1$$4 = b$$1;\n        $tp$$5 = tp * 2;\n        $i$$6 = i + 1;\n        continue findBounding2Power;\n      }\n\n      break;\n    }\n  };\n\n  return findBounding2Power(b, 1, 0);\n}\nexport const BigNatModule$002EFFT$$$p = fromBits(2013265921, 0, false);\nconst BigNatModule$002EFFT$$$patternInput$004075 = [27, 15, 31, 440564289];\nexport const BigNatModule$002EFFT$$$w = BigNatModule$002EFFT$$$patternInput$004075[3];\nexport const BigNatModule$002EFFT$$$m = BigNatModule$002EFFT$$$patternInput$004075[1];\nexport const BigNatModule$002EFFT$$$k = BigNatModule$002EFFT$$$patternInput$004075[0];\nexport const BigNatModule$002EFFT$$$g = BigNatModule$002EFFT$$$patternInput$004075[2];\nexport const BigNatModule$002EFFT$$$primeP = BigNatModule$002EFFT$$$p;\nexport const BigNatModule$002EFFT$$$maxBitsInsideFp = 30;\nexport const BigNatModule$002EFFT$002EFp$$$p = 2013265921;\nexport const BigNatModule$002EFFT$002EFp$$$p64 = fromBits(2013265921, 0, true);\nexport function BigNatModule$002EFFT$002EFp$$$toInt(x$$1) {\n  return ~~x$$1;\n}\nexport function BigNatModule$002EFFT$002EFp$$$ofInt32(x$$2) {\n  return x$$2 >>> 0;\n}\nexport const BigNatModule$002EFFT$002EFp$$$mzero = 0;\nexport const BigNatModule$002EFFT$002EFp$$$mone = 1;\nexport const BigNatModule$002EFFT$002EFp$$$mtwo = 2;\nexport function BigNatModule$002EFFT$002EFp$$$mpow($x$$3$$9, $n$$1$$10) {\n  BigNatModule$002EFFT$002EFp$$$mpow: while (true) {\n    const x$$3 = $x$$3$$9,\n          n$$1 = $n$$1$$10;\n\n    if (n$$1 === 0) {\n      return BigNatModule$002EFFT$002EFp$$$mone;\n    } else if (n$$1 % 2 === 0) {\n      $x$$3$$9 = toInt(op_Modulus(op_Multiply(fromInteger(x$$3, true, 6), fromInteger(x$$3, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n      $n$$1$$10 = ~~(n$$1 / 2);\n      continue BigNatModule$002EFFT$002EFp$$$mpow;\n    } else {\n      const y$$2 = BigNatModule$002EFFT$002EFp$$$mpow(toInt(op_Modulus(op_Multiply(fromInteger(x$$3, true, 6), fromInteger(x$$3, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0, ~~(n$$1 / 2));\n      return toInt(op_Modulus(op_Multiply(fromInteger(x$$3, true, 6), fromInteger(y$$2, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$002EFFT$002EFp$$$mpowL($x$$7$$11, $n$$2$$12) {\n  BigNatModule$002EFFT$002EFp$$$mpowL: while (true) {\n    const x$$7 = $x$$7$$11,\n          n$$2 = $n$$2$$12;\n\n    if (equals(n$$2, fromBits(0, 0, false))) {\n      return BigNatModule$002EFFT$002EFp$$$mone;\n    } else if (equals(op_Modulus(n$$2, fromBits(2, 0, false)), fromBits(0, 0, false))) {\n      $x$$7$$11 = toInt(op_Modulus(op_Multiply(fromInteger(x$$7, true, 6), fromInteger(x$$7, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n      $n$$2$$12 = op_Division(n$$2, fromBits(2, 0, false));\n      continue BigNatModule$002EFFT$002EFp$$$mpowL;\n    } else {\n      const y$$5 = BigNatModule$002EFFT$002EFp$$$mpowL(toInt(op_Modulus(op_Multiply(fromInteger(x$$7, true, 6), fromInteger(x$$7, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0, op_Division(n$$2, fromBits(2, 0, false)));\n      return toInt(op_Modulus(op_Multiply(fromInteger(x$$7, true, 6), fromInteger(y$$5, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$002EFFT$002EFp$$$m2PowNthRoot(n$$3) {\n  return BigNatModule$002EFFT$002EFp$$$mpow(BigNatModule$002EFFT$$$w >>> 0, BigNatModule$002EFFT$$$pow32(2, BigNatModule$002EFFT$$$k - n$$3));\n}\nexport function BigNatModule$002EFFT$002EFp$$$minv(x$$11) {\n  return BigNatModule$002EFFT$002EFp$$$mpowL(x$$11, op_Subtraction(BigNatModule$002EFFT$$$primeP, fromBits(2, 0, false)));\n}\nexport function BigNatModule$002EFFT$$$computeFFT(lambda, mu, n$$4, w, u, res, offset) {\n  if (n$$4 === 1) {\n    res[offset] = u[mu];\n  } else {\n    const halfN = ~~(n$$4 / 2) | 0;\n    const ww = toInt(op_Modulus(op_Multiply(fromInteger(w, true, 6), fromInteger(w, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n    const offsetHalfN = offset + halfN | 0;\n    BigNatModule$002EFFT$$$computeFFT(lambda * 2, mu, halfN, ww, u, res, offset);\n    BigNatModule$002EFFT$$$computeFFT(lambda * 2, lambda + mu, halfN, ww, u, res, offsetHalfN);\n    let wj = BigNatModule$002EFFT$002EFp$$$mone;\n\n    for (let j = 0; j <= halfN - 1; j++) {\n      const even = res[offset + j];\n      const odd = res[offsetHalfN + j];\n      let y$$8;\n      const x$$13 = wj;\n      y$$8 = toInt(op_Modulus(op_Multiply(fromInteger(x$$13, true, 6), fromInteger(odd, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n      res[offset + j] = (even + y$$8) % BigNatModule$002EFFT$002EFp$$$p;\n      let y$$10;\n      const x$$15 = wj;\n      y$$10 = toInt(op_Modulus(op_Multiply(fromInteger(x$$15, true, 6), fromInteger(odd, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n      res[offsetHalfN + j] = (even + BigNatModule$002EFFT$002EFp$$$p - y$$10) % BigNatModule$002EFFT$002EFp$$$p;\n      const y$$11 = wj;\n      wj = toInt(op_Modulus(op_Multiply(fromInteger(w, true, 6), fromInteger(y$$11, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n    }\n  }\n}\nexport function BigNatModule$002EFFT$$$computFftInPlace(n$$5, w$$1, u$$1) {\n  const res$$1 = fill(new Uint32Array(n$$5), 0, n$$5, BigNatModule$002EFFT$002EFp$$$mzero);\n  BigNatModule$002EFFT$$$computeFFT(1, 0, n$$5, w$$1, u$$1, res$$1, 0);\n  return res$$1;\n}\nexport function BigNatModule$002EFFT$$$computeInverseFftInPlace(n$$6, w$$2, uT) {\n  const bigKInv = BigNatModule$002EFFT$002EFp$$$minv(n$$6 >>> 0);\n  return map(function (y$$12) {\n    return toInt(op_Modulus(op_Multiply(fromInteger(bigKInv, true, 6), fromInteger(y$$12, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n  }, BigNatModule$002EFFT$$$computFftInPlace(n$$6, BigNatModule$002EFFT$002EFp$$$minv(w$$2), uT), Uint32Array);\n}\nexport const BigNatModule$002EFFT$$$maxTwoPower = 29;\nexport const BigNatModule$002EFFT$$$twoPowerTable = initialize(BigNatModule$002EFFT$$$maxTwoPower - 1, function (i$$1) {\n  return BigNatModule$002EFFT$$$pow32(2, i$$1);\n}, Int32Array);\nexport function BigNatModule$002EFFT$$$computeFftPaddedPolynomialProduct(bigK, k, u$$2, v) {\n  const w$$3 = BigNatModule$002EFFT$002EFp$$$m2PowNthRoot(k);\n  const uT$$1 = BigNatModule$002EFFT$$$computFftInPlace(bigK, w$$3, u$$2);\n  const vT = BigNatModule$002EFFT$$$computFftInPlace(bigK, w$$3, v);\n  const rT = initialize(bigK, function (i$$2) {\n    const x$$19 = uT$$1[i$$2];\n    const y$$14 = vT[i$$2];\n    return toInt(op_Modulus(op_Multiply(fromInteger(x$$19, true, 6), fromInteger(y$$14, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n  }, Uint32Array);\n  const r = BigNatModule$002EFFT$$$computeInverseFftInPlace(bigK, w$$3, rT);\n  return r;\n}\nexport function BigNatModule$002EFFT$$$padTo(n$$8, u$$3) {\n  const uBound = u$$3.length | 0;\n  return initialize(n$$8, function (i$$3) {\n    return i$$3 < uBound ? BigNatModule$002EFFT$002EFp$$$ofInt32(u$$3[i$$3]) : BigNatModule$002EFFT$002EFp$$$mzero;\n  }, Uint32Array);\n}\nexport function BigNatModule$002EFFT$$$computeFftPolynomialProduct(degu, u$$4, degv, v$$1) {\n  const deguv = degu + degv | 0;\n  const bound = deguv + 1 | 0;\n  const patternInput = BigNatModule$002EFFT$$$leastBounding2Power(bound);\n  const w$$4 = BigNatModule$002EFFT$002EFp$$$m2PowNthRoot(patternInput[1]);\n  const u$$5 = BigNatModule$002EFFT$$$padTo(patternInput[0], u$$4);\n  const v$$2 = BigNatModule$002EFFT$$$padTo(patternInput[0], v$$1);\n  const uT$$2 = BigNatModule$002EFFT$$$computFftInPlace(patternInput[0], w$$4, u$$5);\n  const vT$$1 = BigNatModule$002EFFT$$$computFftInPlace(patternInput[0], w$$4, v$$2);\n  const rT$$1 = initialize(patternInput[0], function (i$$4) {\n    const x$$20 = uT$$2[i$$4];\n    const y$$15 = vT$$1[i$$4];\n    return toInt(op_Modulus(op_Multiply(fromInteger(x$$20, true, 6), fromInteger(y$$15, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n  }, Uint32Array);\n  const r$$1 = BigNatModule$002EFFT$$$computeInverseFftInPlace(patternInput[0], w$$4, rT$$1);\n  return map(BigNatModule$002EFFT$002EFp$$$toInt, r$$1, Int32Array);\n}\nexport const BigNatModule$002EFFT$$$mzero = BigNatModule$002EFFT$002EFp$$$mzero;\nexport const BigNatModule$002EFFT$$$mone = BigNatModule$002EFFT$002EFp$$$mone;\nexport const BigNatModule$002EFFT$$$maxFp = (BigNatModule$002EFFT$002EFp$$$p + BigNatModule$002EFFT$002EFp$$$p - BigNatModule$002EFFT$$$mone) % BigNatModule$002EFFT$002EFp$$$p;\nexport function BigNatModule$$$bound(n$$10) {\n  return n$$10.bound;\n}\nexport function BigNatModule$$$setBound(n$$11, v$$3) {\n  n$$11.bound = v$$3;\n}\nexport function BigNatModule$$$coeff(n$$12, i$$5) {\n  return n$$12.digits[i$$5];\n}\nexport function BigNatModule$$$coeff64(n$$13, i$$6) {\n  return fromInteger(BigNatModule$$$coeff(n$$13, i$$6), false, 2);\n}\nexport function BigNatModule$$$setCoeff(n$$14, i$$7, v$$4) {\n  n$$14.digits[i$$7] = v$$4;\n}\nexport function BigNatModule$$$pow64($x$$23$$48, $n$$15$$49) {\n  BigNatModule$$$pow64: while (true) {\n    const x$$23 = $x$$23$$48,\n          n$$15 = $n$$15$$49;\n\n    if (n$$15 === 0) {\n      return fromBits(1, 0, false);\n    } else if (n$$15 % 2 === 0) {\n      $x$$23$$48 = op_Multiply(x$$23, x$$23);\n      $n$$15$$49 = ~~(n$$15 / 2);\n      continue BigNatModule$$$pow64;\n    } else {\n      return op_Multiply(x$$23, BigNatModule$$$pow64(op_Multiply(x$$23, x$$23), ~~(n$$15 / 2)));\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$pow32($x$$24$$50, $n$$16$$51) {\n  BigNatModule$$$pow32: while (true) {\n    const x$$24 = $x$$24$$50,\n          n$$16 = $n$$16$$51;\n\n    if (n$$16 === 0) {\n      return 1;\n    } else if (n$$16 % 2 === 0) {\n      $x$$24$$50 = x$$24 * x$$24;\n      $n$$16$$51 = ~~(n$$16 / 2);\n      continue BigNatModule$$$pow32;\n    } else {\n      return x$$24 * BigNatModule$$$pow32(x$$24 * x$$24, ~~(n$$16 / 2)) | 0;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$hash(n$$17) {\n  let res$$2 = 0;\n\n  for (let i$$8 = 0; i$$8 <= n$$17.bound - 1; i$$8++) {\n    res$$2 = n$$17.digits[i$$8] + (res$$2 << 3);\n  }\n\n  return res$$2 | 0;\n}\nexport function BigNatModule$$$maxInt(a, b$$2) {\n  if (a < b$$2) {\n    return b$$2 | 0;\n  } else {\n    return a | 0;\n  }\n}\nexport function BigNatModule$$$minInt(a$$1, b$$3) {\n  if (a$$1 < b$$3) {\n    return a$$1 | 0;\n  } else {\n    return b$$3 | 0;\n  }\n}\nexport const BigNatModule$$$baseBits = 24;\nexport const BigNatModule$$$baseN = 16777216;\nexport const BigNatModule$$$baseMask = 16777215;\nexport const BigNatModule$$$baseNi64 = fromBits(16777216, 0, false);\nexport const BigNatModule$$$baseMaski64 = fromBits(16777215, 0, false);\nexport const BigNatModule$$$baseMaskU = fromBits(16777215, 0, true);\nexport const BigNatModule$$$baseMask32A = 16777215;\nexport const BigNatModule$$$baseMask32B = 255;\nexport const BigNatModule$$$baseShift32B = 24;\nexport const BigNatModule$$$baseMask64A = 16777215;\nexport const BigNatModule$$$baseMask64B = 16777215;\nexport const BigNatModule$$$baseMask64C = 65535;\nexport const BigNatModule$$$baseShift64B = 24;\nexport const BigNatModule$$$baseShift64C = 48;\nexport function BigNatModule$$$divbase(x$$25) {\n  return ~~(x$$25 >>> 0 >>> BigNatModule$$$baseBits);\n}\nexport function BigNatModule$$$modbase(x$$26) {\n  return x$$26 & BigNatModule$$$baseMask;\n}\nexport function BigNatModule$$$createN(b$$4) {\n  return new BigNat(b$$4, new Int32Array(b$$4));\n}\nexport function BigNatModule$$$copyN(x$$27) {\n  return new BigNat(x$$27.bound, copy(x$$27.digits, Int32Array));\n}\nexport function BigNatModule$$$normN(n$$18) {\n  const findLeastBound = function findLeastBound($na$$62, $i$$9$$63) {\n    findLeastBound: while (true) {\n      const na = $na$$62,\n            i$$9 = $i$$9$$63;\n\n      if (i$$9 === -1 ? true : na[i$$9] !== 0) {\n        return i$$9 + 1 | 0;\n      } else {\n        $na$$62 = na;\n        $i$$9$$63 = i$$9 - 1;\n        continue findLeastBound;\n      }\n\n      break;\n    }\n  };\n\n  const bound$$1 = findLeastBound(n$$18.digits, n$$18.bound - 1) | 0;\n  n$$18.bound = bound$$1;\n  return n$$18;\n}\nexport const BigNatModule$$$boundInt = 2;\nexport const BigNatModule$$$boundInt64 = 3;\nexport const BigNatModule$$$boundBase = 1;\nexport function BigNatModule$$$embed(x$$28) {\n  const x$$29 = (x$$28 < 0 ? 0 : x$$28) | 0;\n\n  if (x$$29 < BigNatModule$$$baseN) {\n    const r$$2 = BigNatModule$$$createN(1);\n    r$$2.digits[0] = x$$29;\n    return BigNatModule$$$normN(r$$2);\n  } else {\n    const r$$3 = BigNatModule$$$createN(BigNatModule$$$boundInt);\n\n    for (let i$$10 = 0; i$$10 <= BigNatModule$$$boundInt - 1; i$$10++) {\n      r$$3.digits[i$$10] = ~~(x$$29 / BigNatModule$$$pow32(BigNatModule$$$baseN, i$$10)) % BigNatModule$$$baseN;\n    }\n\n    return BigNatModule$$$normN(r$$3);\n  }\n}\nexport function BigNatModule$$$embed64(x$$30) {\n  const x$$31 = compare(x$$30, fromBits(0, 0, false)) < 0 ? fromBits(0, 0, false) : x$$30;\n  const r$$4 = BigNatModule$$$createN(BigNatModule$$$boundInt64);\n\n  for (let i$$11 = 0; i$$11 <= BigNatModule$$$boundInt64 - 1; i$$11++) {\n    r$$4.digits[i$$11] = ~~toInt(op_Modulus(op_Division(x$$31, BigNatModule$$$pow64(BigNatModule$$$baseNi64, i$$11)), BigNatModule$$$baseNi64));\n  }\n\n  return BigNatModule$$$normN(r$$4);\n}\nexport function BigNatModule$$$eval32(n$$19) {\n  if (n$$19.bound === 1) {\n    return n$$19.digits[0] | 0;\n  } else {\n    let acc = 0;\n\n    for (let i$$12 = n$$19.bound - 1; i$$12 >= 0; i$$12--) {\n      acc = n$$19.digits[i$$12] + BigNatModule$$$baseN * acc;\n    }\n\n    return acc | 0;\n  }\n}\nexport function BigNatModule$$$eval64(n$$20) {\n  if (n$$20.bound === 1) {\n    return fromInteger(n$$20.digits[0], false, 2);\n  } else {\n    let acc$$1 = fromBits(0, 0, false);\n\n    for (let i$$13 = n$$20.bound - 1; i$$13 >= 0; i$$13--) {\n      acc$$1 = op_Addition(fromInteger(n$$20.digits[i$$13], false, 2), op_Multiply(BigNatModule$$$baseNi64, acc$$1));\n    }\n\n    return acc$$1;\n  }\n}\nexport const BigNatModule$$$one = BigNatModule$$$embed(1);\nexport const BigNatModule$$$zero = BigNatModule$$$embed(0);\nexport function BigNatModule$$$restrictTo(d, n$$21) {\n  return new BigNat(BigNatModule$$$minInt(d, n$$21.bound), n$$21.digits);\n}\nexport function BigNatModule$$$shiftUp(d$$1, n$$22) {\n  const m = BigNatModule$$$createN(n$$22.bound + d$$1);\n\n  for (let i$$14 = 0; i$$14 <= n$$22.bound - 1; i$$14++) {\n    m.digits[i$$14 + d$$1] = n$$22.digits[i$$14];\n  }\n\n  return m;\n}\nexport function BigNatModule$$$shiftDown(d$$2, n$$23) {\n  if (n$$23.bound - d$$2 <= 0) {\n    return BigNatModule$$$zero;\n  } else {\n    const m$$1 = BigNatModule$$$createN(n$$23.bound - d$$2);\n\n    for (let i$$15 = 0; i$$15 <= m$$1.bound - 1; i$$15++) {\n      m$$1.digits[i$$15] = n$$23.digits[i$$15 + d$$2];\n    }\n\n    return m$$1;\n  }\n}\nexport function BigNatModule$$$degree(n$$24) {\n  return n$$24.bound - 1;\n}\nexport function BigNatModule$$$addP($i$$16$$75, $n$$25$$76, $c$$77, $p$$78, $q$$79, $r$$5$$80) {\n  BigNatModule$$$addP: while (true) {\n    const i$$16 = $i$$16$$75,\n          n$$25 = $n$$25$$76,\n          c = $c$$77,\n          p = $p$$78,\n          q = $q$$79,\n          r$$5 = $r$$5$$80;\n\n    if (i$$16 < n$$25) {\n      const x$$32 = (i$$16 < p.bound ? p.digits[i$$16] : 0) + (i$$16 < q.bound ? q.digits[i$$16] : 0) + c | 0;\n      r$$5.digits[i$$16] = BigNatModule$$$modbase(x$$32);\n      const c$$1 = BigNatModule$$$divbase(x$$32) | 0;\n      $i$$16$$75 = i$$16 + 1;\n      $n$$25$$76 = n$$25;\n      $c$$77 = c$$1;\n      $p$$78 = p;\n      $q$$79 = q;\n      $r$$5$$80 = r$$5;\n      continue BigNatModule$$$addP;\n    } else {\n      void null;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$add(p$$1, q$$1) {\n  const rbound = 1 + BigNatModule$$$maxInt(p$$1.bound, q$$1.bound) | 0;\n  const r$$6 = BigNatModule$$$createN(rbound);\n  BigNatModule$$$addP(0, rbound, 0, p$$1, q$$1, r$$6);\n  return BigNatModule$$$normN(r$$6);\n}\nexport function BigNatModule$$$subP($i$$19$$83, $n$$26$$84, $c$$2$$85, $p$$2$$86, $q$$2$$87, $r$$7$$88) {\n  BigNatModule$$$subP: while (true) {\n    const i$$19 = $i$$19$$83,\n          n$$26 = $n$$26$$84,\n          c$$2 = $c$$2$$85,\n          p$$2 = $p$$2$$86,\n          q$$2 = $q$$2$$87,\n          r$$7 = $r$$7$$88;\n\n    if (i$$19 < n$$26) {\n      const x$$33 = (i$$19 < p$$2.bound ? p$$2.digits[i$$19] : 0) - (i$$19 < q$$2.bound ? q$$2.digits[i$$19] : 0) + c$$2 | 0;\n\n      if (x$$33 > 0) {\n        r$$7.digits[i$$19] = BigNatModule$$$modbase(x$$33);\n        const c$$3 = BigNatModule$$$divbase(x$$33) | 0;\n        $i$$19$$83 = i$$19 + 1;\n        $n$$26$$84 = n$$26;\n        $c$$2$$85 = c$$3;\n        $p$$2$$86 = p$$2;\n        $q$$2$$87 = q$$2;\n        $r$$7$$88 = r$$7;\n        continue BigNatModule$$$subP;\n      } else {\n        const x$$34 = x$$33 + BigNatModule$$$baseN | 0;\n        r$$7.digits[i$$19] = BigNatModule$$$modbase(x$$34);\n        const c$$4 = BigNatModule$$$divbase(x$$34) - 1 | 0;\n        $i$$19$$83 = i$$19 + 1;\n        $n$$26$$84 = n$$26;\n        $c$$2$$85 = c$$4;\n        $p$$2$$86 = p$$2;\n        $q$$2$$87 = q$$2;\n        $r$$7$$88 = r$$7;\n        continue BigNatModule$$$subP;\n      }\n    } else {\n      const underflow = c$$2 !== 0;\n      return underflow;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$sub(p$$3, q$$3) {\n  const rbound$$1 = BigNatModule$$$maxInt(p$$3.bound, q$$3.bound) | 0;\n  const r$$8 = BigNatModule$$$createN(rbound$$1);\n  const underflow$$1 = BigNatModule$$$subP(0, rbound$$1, 0, p$$3, q$$3, r$$8);\n\n  if (underflow$$1) {\n    return BigNatModule$$$embed(0);\n  } else {\n    return BigNatModule$$$normN(r$$8);\n  }\n}\nexport function BigNatModule$$$isZero(p$$4) {\n  return p$$4.bound === 0;\n}\nexport function BigNatModule$$$IsZero(p$$5) {\n  return BigNatModule$$$isZero(p$$5);\n}\nexport function BigNatModule$$$isOne(p$$6) {\n  if (p$$6.bound === 1) {\n    return p$$6.digits[0] === 1;\n  } else {\n    return false;\n  }\n}\nexport function BigNatModule$$$equal(p$$7, q$$4) {\n  if (p$$7.bound === q$$4.bound) {\n    const check = function check($pa$$96, $qa$$97, $i$$22$$98) {\n      check: while (true) {\n        const pa = $pa$$96,\n              qa = $qa$$97,\n              i$$22 = $i$$22$$98;\n\n        if (i$$22 === -1) {\n          return true;\n        } else if (pa[i$$22] === qa[i$$22]) {\n          $pa$$96 = pa;\n          $qa$$97 = qa;\n          $i$$22$$98 = i$$22 - 1;\n          continue check;\n        } else {\n          return false;\n        }\n\n        break;\n      }\n    };\n\n    return check(p$$7.digits, q$$4.digits, p$$7.bound - 1);\n  } else {\n    return false;\n  }\n}\nexport function BigNatModule$$$shiftCompare(p$$8, pn, q$$5, qn) {\n  if (p$$8.bound + pn < q$$5.bound + qn) {\n    return -1 | 0;\n  } else if (p$$8.bound + pn > q$$5.bound + pn) {\n    return 1;\n  } else {\n    const check$$1 = function check$$1($pa$$1$$103, $qa$$1$$104, $i$$23$$105) {\n      check$$1: while (true) {\n        const pa$$1 = $pa$$1$$103,\n              qa$$1 = $qa$$1$$104,\n              i$$23 = $i$$23$$105;\n\n        if (i$$23 === -1) {\n          return 0;\n        } else {\n          const pai = (i$$23 < pn ? 0 : pa$$1[i$$23 - pn]) | 0;\n          const qai = (i$$23 < qn ? 0 : qa$$1[i$$23 - qn]) | 0;\n\n          if (pai === qai) {\n            $pa$$1$$103 = pa$$1;\n            $qa$$1$$104 = qa$$1;\n            $i$$23$$105 = i$$23 - 1;\n            continue check$$1;\n          } else if (pai < qai) {\n            return -1 | 0;\n          } else {\n            return 1;\n          }\n        }\n\n        break;\n      }\n    };\n\n    return check$$1(p$$8.digits, q$$5.digits, p$$8.bound + pn - 1) | 0;\n  }\n}\nexport function BigNatModule$$$compare(p$$9, q$$6) {\n  if (p$$9.bound < q$$6.bound) {\n    return -1 | 0;\n  } else if (p$$9.bound > q$$6.bound) {\n    return 1;\n  } else {\n    const check$$2 = function check$$2($pa$$2$$108, $qa$$2$$109, $i$$24$$110) {\n      check$$2: while (true) {\n        const pa$$2 = $pa$$2$$108,\n              qa$$2 = $qa$$2$$109,\n              i$$24 = $i$$24$$110;\n\n        if (i$$24 === -1) {\n          return 0;\n        } else if (pa$$2[i$$24] === qa$$2[i$$24]) {\n          $pa$$2$$108 = pa$$2;\n          $qa$$2$$109 = qa$$2;\n          $i$$24$$110 = i$$24 - 1;\n          continue check$$2;\n        } else if (pa$$2[i$$24] < qa$$2[i$$24]) {\n          return -1 | 0;\n        } else {\n          return 1;\n        }\n\n        break;\n      }\n    };\n\n    return check$$2(p$$9.digits, q$$6.digits, p$$9.bound - 1) | 0;\n  }\n}\nexport function BigNatModule$$$lt(p$$10, q$$7) {\n  return BigNatModule$$$compare(p$$10, q$$7) === -1;\n}\nexport function BigNatModule$$$gt(p$$11, q$$8) {\n  return BigNatModule$$$compare(p$$11, q$$8) === 1;\n}\nexport function BigNatModule$$$lte(p$$12, q$$9) {\n  return BigNatModule$$$compare(p$$12, q$$9) !== 1;\n}\nexport function BigNatModule$$$gte(p$$13, q$$10) {\n  return BigNatModule$$$compare(p$$13, q$$10) !== -1;\n}\nexport function BigNatModule$$$min(a$$2, b$$5) {\n  if (BigNatModule$$$lt(a$$2, b$$5)) {\n    return a$$2;\n  } else {\n    return b$$5;\n  }\n}\nexport function BigNatModule$$$max(a$$3, b$$6) {\n  if (BigNatModule$$$lt(a$$3, b$$6)) {\n    return b$$6;\n  } else {\n    return a$$3;\n  }\n}\nexport function BigNatModule$$$contributeArr($a$$4$$123, $i$$25$$124, $c$$5$$125) {\n  BigNatModule$$$contributeArr: while (true) {\n    const a$$4 = $a$$4$$123,\n          i$$25 = $i$$25$$124,\n          c$$5 = $c$$5$$125;\n    const x$$35 = op_Addition(fromInteger(a$$4[i$$25], false, 2), c$$5);\n    const c$$6 = op_Division(x$$35, BigNatModule$$$baseNi64);\n    let x$$38;\n    const value = op_BitwiseAnd(x$$35, BigNatModule$$$baseMaski64);\n    x$$38 = ~~toInt(value);\n    a$$4[i$$25] = x$$38;\n\n    if (compare(c$$6, fromBits(0, 0, false)) > 0) {\n      $a$$4$$123 = a$$4;\n      $i$$25$$124 = i$$25 + 1;\n      $c$$5$$125 = c$$6;\n      continue BigNatModule$$$contributeArr;\n    } else {\n      void null;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$scale(k$$2, p$$14) {\n  const rbound$$2 = p$$14.bound + BigNatModule$$$boundInt | 0;\n  const r$$9 = BigNatModule$$$createN(rbound$$2);\n  const k$$3 = fromInteger(k$$2, false, 2);\n\n  for (let i$$26 = 0; i$$26 <= p$$14.bound - 1; i$$26++) {\n    const kpi = op_Multiply(k$$3, fromInteger(p$$14.digits[i$$26], false, 2));\n    BigNatModule$$$contributeArr(r$$9.digits, i$$26, kpi);\n  }\n\n  return BigNatModule$$$normN(r$$9);\n}\nexport function BigNatModule$$$mulSchoolBookBothSmall(p$$15, q$$11) {\n  var value$$1;\n  const r$$11 = BigNatModule$$$createN(2);\n  const rak = op_Multiply(fromInteger(p$$15, false, 2), fromInteger(q$$11, false, 2));\n  BigNatModule$$$setCoeff(r$$11, 0, (value$$1 = op_BitwiseAnd(rak, BigNatModule$$$baseMaski64), (~~toInt(value$$1))));\n  BigNatModule$$$setCoeff(r$$11, 1, ~~toInt(op_Division(rak, BigNatModule$$$baseNi64)));\n  return BigNatModule$$$normN(r$$11);\n}\nexport function BigNatModule$$$mulSchoolBookCarry($r$$12$$130, $c$$8$$131, $k$$4$$132) {\n  var value$$2;\n\n  BigNatModule$$$mulSchoolBookCarry: while (true) {\n    const r$$12 = $r$$12$$130,\n          c$$8 = $c$$8$$131,\n          k$$4 = $k$$4$$132;\n\n    if (compare(c$$8, fromBits(0, 0, false)) > 0) {\n      const rak$$1 = op_Addition(BigNatModule$$$coeff64(r$$12, k$$4), c$$8);\n      BigNatModule$$$setCoeff(r$$12, k$$4, (value$$2 = op_BitwiseAnd(rak$$1, BigNatModule$$$baseMaski64), (~~toInt(value$$2))));\n      $r$$12$$130 = r$$12;\n      $c$$8$$131 = op_Division(rak$$1, BigNatModule$$$baseNi64);\n      $k$$4$$132 = k$$4 + 1;\n      continue BigNatModule$$$mulSchoolBookCarry;\n    } else {\n      void null;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$mulSchoolBookOneSmall(p$$16, q$$12) {\n  var value$$3;\n  const bp = BigNatModule$$$bound(p$$16) | 0;\n  const rbound$$3 = bp + 1 | 0;\n  const r$$13 = BigNatModule$$$createN(rbound$$3);\n  const q$$13 = fromInteger(q$$12, false, 2);\n  let c$$9 = fromBits(0, 0, false);\n\n  for (let i$$28 = 0; i$$28 <= bp - 1; i$$28++) {\n    const rak$$2 = op_Addition(op_Addition(c$$9, BigNatModule$$$coeff64(r$$13, i$$28)), op_Multiply(BigNatModule$$$coeff64(p$$16, i$$28), q$$13));\n    BigNatModule$$$setCoeff(r$$13, i$$28, (value$$3 = op_BitwiseAnd(rak$$2, BigNatModule$$$baseMaski64), (~~toInt(value$$3))));\n    c$$9 = op_Division(rak$$2, BigNatModule$$$baseNi64);\n  }\n\n  BigNatModule$$$mulSchoolBookCarry(r$$13, c$$9, bp);\n  return BigNatModule$$$normN(r$$13);\n}\nexport function BigNatModule$$$mulSchoolBookNeitherSmall(p$$17, q$$14) {\n  var value$$4;\n  const rbound$$4 = p$$17.bound + q$$14.bound | 0;\n  const r$$14 = BigNatModule$$$createN(rbound$$4);\n\n  for (let i$$29 = 0; i$$29 <= p$$17.bound - 1; i$$29++) {\n    const pai$$1 = fromInteger(p$$17.digits[i$$29], false, 2);\n    let c$$10 = fromBits(0, 0, false);\n    let k$$5 = i$$29 | 0;\n\n    for (let j$$1 = 0; j$$1 <= q$$14.bound - 1; j$$1++) {\n      const qaj = fromInteger(q$$14.digits[j$$1], false, 2);\n      const rak$$3 = op_Addition(op_Addition(fromInteger(r$$14.digits[k$$5], false, 2), c$$10), op_Multiply(pai$$1, qaj));\n      r$$14.digits[k$$5] = (value$$4 = op_BitwiseAnd(rak$$3, BigNatModule$$$baseMaski64), (~~toInt(value$$4)));\n      c$$10 = op_Division(rak$$3, BigNatModule$$$baseNi64);\n      k$$5 = k$$5 + 1;\n    }\n\n    BigNatModule$$$mulSchoolBookCarry(r$$14, c$$10, k$$5);\n  }\n\n  return BigNatModule$$$normN(r$$14);\n}\nexport function BigNatModule$$$mulSchoolBook(p$$18, q$$15) {\n  const pSmall = BigNatModule$$$bound(p$$18) === 1;\n  const qSmall = BigNatModule$$$bound(q$$15) === 1;\n\n  if (pSmall ? qSmall : false) {\n    return BigNatModule$$$mulSchoolBookBothSmall(BigNatModule$$$coeff(p$$18, 0), BigNatModule$$$coeff(q$$15, 0));\n  } else if (pSmall) {\n    return BigNatModule$$$mulSchoolBookOneSmall(q$$15, BigNatModule$$$coeff(p$$18, 0));\n  } else if (qSmall) {\n    return BigNatModule$$$mulSchoolBookOneSmall(p$$18, BigNatModule$$$coeff(q$$15, 0));\n  } else {\n    return BigNatModule$$$mulSchoolBookNeitherSmall(p$$18, q$$15);\n  }\n}\nexport const BigNatModule$002Eencoding = declare(function BigInt_BigNatModule_encoding(bigL, twoToBigL, k, bigK, bigN, split, splits) {\n  this.bigL = bigL | 0;\n  this.twoToBigL = twoToBigL | 0;\n  this.k = k | 0;\n  this.bigK = bigK | 0;\n  this.bigN = bigN | 0;\n  this.split = split | 0;\n  this.splits = splits;\n}, Record);\nexport function BigNatModule$002Eencoding$reflection() {\n  return record_type(\"BigInt.BigNatModule.encoding\", [], BigNatModule$002Eencoding, () => [[\"bigL\", int32_type], [\"twoToBigL\", int32_type], [\"k\", int32_type], [\"bigK\", int32_type], [\"bigN\", int32_type], [\"split\", int32_type], [\"splits\", array_type(int32_type)]]);\n}\nexport function BigNatModule$$$mkEncoding(bigL, k$$6, bigK$$2, bigN) {\n  return new BigNatModule$002Eencoding(bigL, BigNatModule$$$pow32(2, bigL), k$$6, bigK$$2, bigN, ~~(BigNatModule$$$baseBits / bigL), initialize(~~(BigNatModule$$$baseBits / bigL), function (i$$30) {\n    return BigNatModule$$$pow32(2, bigL * i$$30);\n  }, Int32Array));\n}\nexport const BigNatModule$$$table = [BigNatModule$$$mkEncoding(1, 28, 268435456, 268435456), BigNatModule$$$mkEncoding(2, 26, 67108864, 134217728), BigNatModule$$$mkEncoding(3, 24, 16777216, 50331648), BigNatModule$$$mkEncoding(4, 22, 4194304, 16777216), BigNatModule$$$mkEncoding(5, 20, 1048576, 5242880), BigNatModule$$$mkEncoding(6, 18, 262144, 1572864), BigNatModule$$$mkEncoding(7, 16, 65536, 458752), BigNatModule$$$mkEncoding(8, 14, 16384, 131072), BigNatModule$$$mkEncoding(9, 12, 4096, 36864), BigNatModule$$$mkEncoding(10, 10, 1024, 10240), BigNatModule$$$mkEncoding(11, 8, 256, 2816), BigNatModule$$$mkEncoding(12, 6, 64, 768), BigNatModule$$$mkEncoding(13, 4, 16, 208)];\nexport function BigNatModule$$$calculateTableTow(bigL$$1) {\n  const k$$7 = BigNatModule$002EFFT$$$maxBitsInsideFp - 2 * bigL$$1 | 0;\n  const bigK$$3 = BigNatModule$$$pow64(fromBits(2, 0, false), k$$7);\n  const N = op_Multiply(bigK$$3, fromInteger(bigL$$1, false, 2));\n  return [bigL$$1, k$$7, bigK$$3, N];\n}\nexport function BigNatModule$$$encodingGivenResultBits(bitsRes) {\n  const selectFrom = function selectFrom($i$$31$$145) {\n    selectFrom: while (true) {\n      const i$$31 = $i$$31$$145;\n\n      if (i$$31 + 1 < BigNatModule$$$table.length ? bitsRes < BigNatModule$$$table[i$$31 + 1].bigN : false) {\n        $i$$31$$145 = i$$31 + 1;\n        continue selectFrom;\n      } else {\n        return BigNatModule$$$table[i$$31];\n      }\n\n      break;\n    }\n  };\n\n  if (bitsRes >= BigNatModule$$$table[0].bigN) {\n    throw new Error(\"Product is huge, around 268435456 bits, beyond quickmul\");\n  } else {\n    return selectFrom(0);\n  }\n}\nexport const BigNatModule$$$bitmask = initialize(BigNatModule$$$baseBits, function (i$$32) {\n  return BigNatModule$$$pow32(2, i$$32) - 1;\n}, Int32Array);\nexport const BigNatModule$$$twopowers = initialize(BigNatModule$$$baseBits, function (i$$33) {\n  return BigNatModule$$$pow32(2, i$$33);\n}, Int32Array);\nexport const BigNatModule$$$twopowersI64 = initialize(BigNatModule$$$baseBits, function (i$$34) {\n  return BigNatModule$$$pow64(fromBits(2, 0, false), i$$34);\n}, Array);\nexport function BigNatModule$$$wordBits(word) {\n  const hi = function hi($k$$8$$147) {\n    hi: while (true) {\n      const k$$8 = $k$$8$$147;\n\n      if (k$$8 === 0) {\n        return 0;\n      } else if ((word & BigNatModule$$$twopowers[k$$8 - 1]) !== 0) {\n        return k$$8 | 0;\n      } else {\n        $k$$8$$147 = k$$8 - 1;\n        continue hi;\n      }\n\n      break;\n    }\n  };\n\n  return hi(BigNatModule$$$baseBits) | 0;\n}\nexport function BigNatModule$$$bits(u$$6) {\n  if (u$$6.bound === 0) {\n    return 0;\n  } else {\n    return BigNatModule$$$degree(u$$6) * BigNatModule$$$baseBits + BigNatModule$$$wordBits(u$$6.digits[BigNatModule$$$degree(u$$6)]) | 0;\n  }\n}\nexport function BigNatModule$$$extractBits(n$$27, enc, bi) {\n  const bj = bi + enc.bigL - 1 | 0;\n  const biw = ~~(bi / BigNatModule$$$baseBits) | 0;\n  const bjw = ~~(bj / BigNatModule$$$baseBits) | 0;\n\n  if (biw !== bjw) {\n    const x$$47 = (biw < n$$27.bound ? n$$27.digits[biw] : 0) | 0;\n    const y$$17 = (bjw < n$$27.bound ? n$$27.digits[bjw] : 0) | 0;\n    const xbit = bi % BigNatModule$$$baseBits | 0;\n    const nxbits = BigNatModule$$$baseBits - xbit | 0;\n    const x$$48 = x$$47 >> xbit | 0;\n    const y$$18 = y$$17 << nxbits | 0;\n    const x$$49 = x$$48 | y$$18 | 0;\n    const x$$50 = x$$49 & BigNatModule$$$bitmask[enc.bigL] | 0;\n    return x$$50 | 0;\n  } else {\n    const x$$51 = (biw < n$$27.bound ? n$$27.digits[biw] : 0) | 0;\n    const xbit$$1 = bi % BigNatModule$$$baseBits | 0;\n    const x$$52 = x$$51 >> xbit$$1 | 0;\n    const x$$53 = x$$52 & BigNatModule$$$bitmask[enc.bigL] | 0;\n    return x$$53 | 0;\n  }\n}\nexport function BigNatModule$$$encodePoly(enc$$1, n$$28) {\n  const poly = fill(new Uint32Array(enc$$1.bigK), 0, enc$$1.bigK, BigNatModule$002EFFT$002EFp$$$ofInt32(0));\n  const biMax = n$$28.bound * BigNatModule$$$baseBits | 0;\n\n  const encoder = function encoder($i$$38$$154, $bi$$1$$155) {\n    encoder: while (true) {\n      const i$$38 = $i$$38$$154,\n            bi$$1 = $bi$$1$$155;\n\n      if (i$$38 === enc$$1.bigK ? true : bi$$1 > biMax) {\n        void null;\n      } else {\n        const pi = BigNatModule$$$extractBits(n$$28, enc$$1, bi$$1) | 0;\n        poly[i$$38] = BigNatModule$002EFFT$002EFp$$$ofInt32(pi);\n        const i$$39 = i$$38 + 1 | 0;\n        const bi$$2 = bi$$1 + enc$$1.bigL | 0;\n        $i$$38$$154 = i$$39;\n        $bi$$1$$155 = bi$$2;\n        continue encoder;\n      }\n\n      break;\n    }\n  };\n\n  encoder(0, 0);\n  return poly;\n}\nexport function BigNatModule$$$decodeResultBits(enc$$2, poly$$1) {\n  let n$$29 = 0;\n\n  for (let i$$40 = 0; i$$40 <= poly$$1.length - 1; i$$40++) {\n    if (poly$$1[i$$40] !== BigNatModule$002EFFT$$$mzero) {\n      n$$29 = i$$40;\n    } else {\n      void null;\n    }\n  }\n\n  const rbits = BigNatModule$002EFFT$$$maxBitsInsideFp + enc$$2.bigL * n$$29 + 1 | 0;\n  return rbits + 1 | 0;\n}\nexport function BigNatModule$$$decodePoly(enc$$3, poly$$2) {\n  const rbound$$5 = ~~(BigNatModule$$$decodeResultBits(enc$$3, poly$$2) / BigNatModule$$$baseBits) + 1 | 0;\n  const r$$15 = BigNatModule$$$createN(rbound$$5);\n\n  const evaluate = function evaluate($i$$41$$160, $j$$2$$161, $d$$3$$162) {\n    evaluate: while (true) {\n      const i$$41 = $i$$41$$160,\n            j$$2 = $j$$2$$161,\n            d$$3 = $d$$3$$162;\n\n      if (i$$41 === enc$$3.bigK) {\n        void null;\n      } else {\n        if (j$$2 >= rbound$$5) {\n          void null;\n        } else {\n          const x$$54 = op_Multiply(fromInteger(BigNatModule$002EFFT$002EFp$$$toInt(poly$$2[i$$41]), false, 2), BigNatModule$$$twopowersI64[d$$3]);\n          BigNatModule$$$contributeArr(r$$15.digits, j$$2, x$$54);\n        }\n\n        const i$$43 = i$$41 + 1 | 0;\n        const d$$4 = d$$3 + enc$$3.bigL | 0;\n        const patternInput$$1 = d$$4 >= BigNatModule$$$baseBits ? [j$$2 + 1, d$$4 - BigNatModule$$$baseBits] : [j$$2, d$$4];\n        $i$$41$$160 = i$$43;\n        $j$$2$$161 = patternInput$$1[0];\n        $d$$3$$162 = patternInput$$1[1];\n        continue evaluate;\n      }\n\n      break;\n    }\n  };\n\n  evaluate(0, 0, 0);\n  return BigNatModule$$$normN(r$$15);\n}\nexport function BigNatModule$$$quickMulUsingFft(u$$7, v$$5) {\n  const bitsRes$$1 = BigNatModule$$$bits(u$$7) + BigNatModule$$$bits(v$$5) | 0;\n  const enc$$4 = BigNatModule$$$encodingGivenResultBits(bitsRes$$1);\n  const upoly = BigNatModule$$$encodePoly(enc$$4, u$$7);\n  const vpoly = BigNatModule$$$encodePoly(enc$$4, v$$5);\n  const rpoly = BigNatModule$002EFFT$$$computeFftPaddedPolynomialProduct(enc$$4.bigK, enc$$4.k, upoly, vpoly);\n  const r$$17 = BigNatModule$$$decodePoly(enc$$4, rpoly);\n  return BigNatModule$$$normN(r$$17);\n}\nexport const BigNatModule$$$minDigitsKaratsuba = 16;\nexport function BigNatModule$$$recMulKaratsuba(mul, p$$19, q$$16) {\n  const bp$$1 = p$$19.bound | 0;\n  const bq = q$$16.bound | 0;\n  const bmax = BigNatModule$$$maxInt(bp$$1, bq) | 0;\n\n  if (bmax > BigNatModule$$$minDigitsKaratsuba) {\n    const k$$9 = ~~(bmax / 2) | 0;\n    const a0 = BigNatModule$$$restrictTo(k$$9, p$$19);\n    const a1 = BigNatModule$$$shiftDown(k$$9, p$$19);\n    const b0 = BigNatModule$$$restrictTo(k$$9, q$$16);\n    const b1 = BigNatModule$$$shiftDown(k$$9, q$$16);\n    const q0 = mul(a0, b0);\n    const q1 = mul(BigNatModule$$$add(a0, a1), BigNatModule$$$add(b0, b1));\n    const q2 = mul(a1, b1);\n    const p1 = BigNatModule$$$sub(q1, BigNatModule$$$add(q0, q2));\n    const r$$18 = BigNatModule$$$add(q0, BigNatModule$$$shiftUp(k$$9, BigNatModule$$$add(p1, BigNatModule$$$shiftUp(k$$9, q2))));\n    return r$$18;\n  } else {\n    return BigNatModule$$$mulSchoolBook(p$$19, q$$16);\n  }\n}\nexport function BigNatModule$$$mulKaratsuba(x$$55, y$$19) {\n  return BigNatModule$$$recMulKaratsuba(BigNatModule$$$mulKaratsuba, x$$55, y$$19);\n}\nexport const BigNatModule$$$productDigitsUpperSchoolBook = ~~(64000 / BigNatModule$$$baseBits);\nexport const BigNatModule$$$singleDigitForceSchoolBook = ~~(32000 / BigNatModule$$$baseBits);\nexport const BigNatModule$$$productDigitsUpperFft = ~~(BigNatModule$$$table[0].bigN / BigNatModule$$$baseBits);\nexport function BigNatModule$$$mul(p$$20, q$$17) {\n  return BigNatModule$$$mulSchoolBook(p$$20, q$$17);\n}\nexport function BigNatModule$$$scaleSubInPlace(x$$57, f, a$$5, n$$30) {\n  const patternInput$$2 = [x$$57.digits, BigNatModule$$$degree(x$$57)];\n  const patternInput$$3 = [a$$5.digits, BigNatModule$$$degree(a$$5)];\n  const f$$1 = fromInteger(f, false, 2);\n  let j$$4 = 0;\n  let z$$7 = op_Multiply(f$$1, fromInteger(patternInput$$3[0][0], false, 2));\n\n  while (compare(z$$7, fromBits(0, 0, false)) > 0 ? true : j$$4 < patternInput$$3[1]) {\n    if (j$$4 > patternInput$$2[1]) {\n      throw new Error(\"scaleSubInPlace: pre-condition did not apply, result would be -ve\");\n    } else {\n      void null;\n    }\n\n    let zLo;\n    let value$$6;\n    const x$$59 = z$$7;\n    const value$$5 = op_BitwiseAnd(x$$59, BigNatModule$$$baseMaski64);\n    value$$6 = ~~toInt(value$$5);\n    zLo = value$$6;\n    let zHi;\n    const x$$60 = z$$7;\n    zHi = op_Division(x$$60, BigNatModule$$$baseNi64);\n\n    if (zLo <= patternInput$$2[0][j$$4 + n$$30]) {\n      patternInput$$2[0][j$$4 + n$$30] = patternInput$$2[0][j$$4 + n$$30] - zLo;\n    } else {\n      patternInput$$2[0][j$$4 + n$$30] = patternInput$$2[0][j$$4 + n$$30] + (BigNatModule$$$baseN - zLo);\n      zHi = op_Addition(zHi, fromBits(1, 0, false));\n    }\n\n    if (j$$4 < patternInput$$3[1]) {\n      z$$7 = op_Addition(zHi, op_Multiply(f$$1, fromInteger(patternInput$$3[0][j$$4 + 1], false, 2)));\n    } else {\n      z$$7 = zHi;\n    }\n\n    j$$4 = j$$4 + 1;\n  }\n\n  void BigNatModule$$$normN(x$$57);\n}\nexport function BigNatModule$$$scaleSub(x$$61, f$$2, a$$7, n$$31) {\n  const freshx = BigNatModule$$$add(x$$61, BigNatModule$$$zero);\n  BigNatModule$$$scaleSubInPlace(freshx, f$$2, a$$7, n$$31);\n  return BigNatModule$$$normN(freshx);\n}\nexport function BigNatModule$$$scaleAddInPlace(x$$62, f$$3, a$$8, n$$32) {\n  const patternInput$$4 = [x$$62.digits, BigNatModule$$$degree(x$$62)];\n  const patternInput$$5 = [a$$8.digits, BigNatModule$$$degree(a$$8)];\n  const f$$4 = fromInteger(f$$3, false, 2);\n  let j$$5 = 0;\n  let z$$8 = op_Multiply(f$$4, fromInteger(patternInput$$5[0][0], false, 2));\n\n  while (compare(z$$8, fromBits(0, 0, false)) > 0 ? true : j$$5 < patternInput$$5[1]) {\n    if (j$$5 > patternInput$$4[1]) {\n      throw new Error(\"scaleSubInPlace: pre-condition did not apply, result would be -ve\");\n    } else {\n      void null;\n    }\n\n    let zLo$$1;\n    let value$$8;\n    const x$$64 = z$$8;\n    const value$$7 = op_BitwiseAnd(x$$64, BigNatModule$$$baseMaski64);\n    value$$8 = ~~toInt(value$$7);\n    zLo$$1 = value$$8;\n    let zHi$$1;\n    const x$$65 = z$$8;\n    zHi$$1 = op_Division(x$$65, BigNatModule$$$baseNi64);\n\n    if (zLo$$1 < BigNatModule$$$baseN - patternInput$$4[0][j$$5 + n$$32]) {\n      patternInput$$4[0][j$$5 + n$$32] = patternInput$$4[0][j$$5 + n$$32] + zLo$$1;\n    } else {\n      patternInput$$4[0][j$$5 + n$$32] = zLo$$1 - (BigNatModule$$$baseN - patternInput$$4[0][j$$5 + n$$32]);\n      zHi$$1 = op_Addition(zHi$$1, fromBits(1, 0, false));\n    }\n\n    if (j$$5 < patternInput$$5[1]) {\n      z$$8 = op_Addition(zHi$$1, op_Multiply(f$$4, fromInteger(patternInput$$5[0][j$$5 + 1], false, 2)));\n    } else {\n      z$$8 = zHi$$1;\n    }\n\n    j$$5 = j$$5 + 1;\n  }\n\n  void BigNatModule$$$normN(x$$62);\n}\nexport function BigNatModule$$$scaleAdd(x$$66, f$$5, a$$10, n$$33) {\n  const freshx$$1 = BigNatModule$$$add(x$$66, BigNatModule$$$zero);\n  BigNatModule$$$scaleAddInPlace(freshx$$1, f$$5, a$$10, n$$33);\n  return BigNatModule$$$normN(freshx$$1);\n}\nexport function BigNatModule$$$removeFactor(x$$67, a$$11, n$$34) {\n  const patternInput$$6 = [BigNatModule$$$degree(a$$11), BigNatModule$$$degree(x$$67)];\n\n  if (patternInput$$6[1] < patternInput$$6[0] + n$$34) {\n    return 0;\n  } else {\n    let f$$6;\n\n    if (patternInput$$6[0] === 0) {\n      if (patternInput$$6[1] === n$$34) {\n        f$$6 = ~~(x$$67.digits[n$$34] / a$$11.digits[0]);\n      } else {\n        const f64 = op_Division(op_Addition(op_Multiply(fromInteger(x$$67.digits[patternInput$$6[1]], false, 2), BigNatModule$$$baseNi64), fromInteger(x$$67.digits[patternInput$$6[1] - 1], false, 2)), fromInteger(a$$11.digits[0], false, 2));\n        f$$6 = ~~toInt(f64);\n      }\n    } else if (patternInput$$6[1] === patternInput$$6[0] + n$$34) {\n      f$$6 = ~~(x$$67.digits[patternInput$$6[1]] / (a$$11.digits[patternInput$$6[0]] + 1));\n    } else {\n      const f64$$1 = op_Division(op_Addition(op_Multiply(fromInteger(x$$67.digits[patternInput$$6[1]], false, 2), BigNatModule$$$baseNi64), fromInteger(x$$67.digits[patternInput$$6[1] - 1], false, 2)), op_Addition(fromInteger(a$$11.digits[patternInput$$6[0]], false, 2), fromBits(1, 0, false)));\n      f$$6 = ~~toInt(f64$$1);\n    }\n\n    if (f$$6 === 0) {\n      const lte = BigNatModule$$$shiftCompare(a$$11, n$$34, x$$67, 0) !== 1;\n\n      if (lte) {\n        return 1;\n      } else {\n        return 0;\n      }\n    } else {\n      return f$$6 | 0;\n    }\n  }\n}\nexport function BigNatModule$$$divmod(b$$7, a$$12) {\n  if (BigNatModule$$$isZero(a$$12)) {\n    throw new Error();\n  } else if (BigNatModule$$$degree(b$$7) < BigNatModule$$$degree(a$$12)) {\n    return [BigNatModule$$$zero, b$$7];\n  } else {\n    const x$$68 = BigNatModule$$$copyN(b$$7);\n    const d$$6 = BigNatModule$$$createN(BigNatModule$$$degree(b$$7) - BigNatModule$$$degree(a$$12) + 1 + 1);\n    let p$$21 = BigNatModule$$$degree(b$$7) | 0;\n    const m$$2 = BigNatModule$$$degree(a$$12) | 0;\n    let n$$35 = p$$21 - m$$2 | 0;\n\n    const Invariant = function Invariant(tupledArg) {\n      void null;\n    };\n\n    let finished = false;\n\n    while (!finished) {\n      Invariant([d$$6, x$$68, n$$35, p$$21]);\n      const f$$7 = BigNatModule$$$removeFactor(x$$68, a$$12, n$$35) | 0;\n\n      if (f$$7 > 0) {\n        BigNatModule$$$scaleSubInPlace(x$$68, f$$7, a$$12, n$$35);\n        BigNatModule$$$scaleAddInPlace(d$$6, f$$7, BigNatModule$$$one, n$$35);\n        Invariant([d$$6, x$$68, n$$35, p$$21]);\n      } else {\n        finished = f$$7 === 0 ? n$$35 === 0 : false;\n\n        if (!finished) {\n          if (p$$21 === m$$2 + n$$35) {\n            Invariant([d$$6, x$$68, n$$35 - 1, p$$21]);\n            n$$35 = n$$35 - 1;\n          } else {\n            Invariant([d$$6, x$$68, n$$35 - 1, p$$21 - 1]);\n            n$$35 = n$$35 - 1;\n            p$$21 = p$$21 - 1;\n          }\n        } else {\n          void null;\n        }\n      }\n    }\n\n    return [BigNatModule$$$normN(d$$6), BigNatModule$$$normN(x$$68)];\n  }\n}\nexport function BigNatModule$$$div(b$$8, a$$13) {\n  return BigNatModule$$$divmod(b$$8, a$$13)[0];\n}\nexport function BigNatModule$$$rem(b$$9, a$$14) {\n  return BigNatModule$$$divmod(b$$9, a$$14)[1];\n}\nexport function BigNatModule$$$bitAnd(a$$15, b$$10) {\n  const rbound$$6 = BigNatModule$$$minInt(a$$15.bound, b$$10.bound) | 0;\n  const r$$19 = BigNatModule$$$createN(rbound$$6);\n\n  for (let i$$44 = 0; i$$44 <= r$$19.bound - 1; i$$44++) {\n    r$$19.digits[i$$44] = a$$15.digits[i$$44] & b$$10.digits[i$$44];\n  }\n\n  return BigNatModule$$$normN(r$$19);\n}\nexport function BigNatModule$$$bitOr(a$$16, b$$11) {\n  const rbound$$7 = BigNatModule$$$maxInt(a$$16.bound, b$$11.bound) | 0;\n  const r$$20 = BigNatModule$$$createN(rbound$$7);\n\n  for (let i$$45 = 0; i$$45 <= a$$16.bound - 1; i$$45++) {\n    r$$20.digits[i$$45] = r$$20.digits[i$$45] | a$$16.digits[i$$45];\n  }\n\n  for (let i$$46 = 0; i$$46 <= b$$11.bound - 1; i$$46++) {\n    r$$20.digits[i$$46] = r$$20.digits[i$$46] | b$$11.digits[i$$46];\n  }\n\n  return BigNatModule$$$normN(r$$20);\n}\nexport function BigNatModule$$$bitXor(a$$17, b$$12) {\n  const rbound$$8 = BigNatModule$$$maxInt(a$$17.bound, b$$12.bound) | 0;\n  const r$$21 = BigNatModule$$$createN(rbound$$8);\n\n  for (let i$$47 = 0; i$$47 <= a$$17.bound - 1; i$$47++) {\n    r$$21.digits[i$$47] = r$$21.digits[i$$47] ^ a$$17.digits[i$$47];\n  }\n\n  for (let i$$48 = 0; i$$48 <= b$$12.bound - 1; i$$48++) {\n    r$$21.digits[i$$48] = r$$21.digits[i$$48] ^ b$$12.digits[i$$48];\n  }\n\n  return BigNatModule$$$normN(r$$21);\n}\nexport function BigNatModule$$$hcf(a$$18, b$$13) {\n  const hcfloop = function hcfloop($a$$19$$206, $b$$14$$207) {\n    hcfloop: while (true) {\n      const a$$19 = $a$$19$$206,\n            b$$14 = $b$$14$$207;\n\n      if (BigNatModule$$$equal(BigNatModule$$$zero, a$$19)) {\n        return b$$14;\n      } else {\n        const patternInput$$8 = BigNatModule$$$divmod(b$$14, a$$19);\n        $a$$19$$206 = patternInput$$8[1];\n        $b$$14$$207 = a$$19;\n        continue hcfloop;\n      }\n\n      break;\n    }\n  };\n\n  if (BigNatModule$$$lt(a$$18, b$$13)) {\n    return hcfloop(a$$18, b$$13);\n  } else {\n    return hcfloop(b$$13, a$$18);\n  }\n}\nexport const BigNatModule$$$two = BigNatModule$$$embed(2);\nexport function BigNatModule$$$powi(x$$69, n$$36) {\n  const power = function power($acc$$2$$210, $x$$70$$211, $n$$37$$212) {\n    power: while (true) {\n      const acc$$2 = $acc$$2$$210,\n            x$$70 = $x$$70$$211,\n            n$$37 = $n$$37$$212;\n\n      if (n$$37 === 0) {\n        return acc$$2;\n      } else if (n$$37 % 2 === 0) {\n        $acc$$2$$210 = acc$$2;\n        $x$$70$$211 = BigNatModule$$$mul(x$$70, x$$70);\n        $n$$37$$212 = ~~(n$$37 / 2);\n        continue power;\n      } else {\n        $acc$$2$$210 = BigNatModule$$$mul(x$$70, acc$$2);\n        $x$$70$$211 = BigNatModule$$$mul(x$$70, x$$70);\n        $n$$37$$212 = ~~(n$$37 / 2);\n        continue power;\n      }\n\n      break;\n    }\n  };\n\n  return power(BigNatModule$$$one, x$$69, n$$36);\n}\nexport function BigNatModule$$$pow(x$$71, n$$38) {\n  const power$$1 = function power$$1($acc$$3$$215, $x$$72$$216, $n$$39$$217) {\n    power$$1: while (true) {\n      const acc$$3 = $acc$$3$$215,\n            x$$72 = $x$$72$$216,\n            n$$39 = $n$$39$$217;\n\n      if (BigNatModule$$$isZero(n$$39)) {\n        return acc$$3;\n      } else {\n        const patternInput$$9 = BigNatModule$$$divmod(n$$39, BigNatModule$$$two);\n\n        if (BigNatModule$$$isZero(patternInput$$9[1])) {\n          $acc$$3$$215 = acc$$3;\n          $x$$72$$216 = BigNatModule$$$mul(x$$72, x$$72);\n          $n$$39$$217 = patternInput$$9[0];\n          continue power$$1;\n        } else {\n          $acc$$3$$215 = BigNatModule$$$mul(x$$72, acc$$3);\n          $x$$72$$216 = BigNatModule$$$mul(x$$72, x$$72);\n          $n$$39$$217 = patternInput$$9[0];\n          continue power$$1;\n        }\n      }\n\n      break;\n    }\n  };\n\n  return power$$1(BigNatModule$$$one, x$$71, n$$38);\n}\nexport function BigNatModule$$$toFloat(n$$40) {\n  const basef = BigNatModule$$$baseN;\n\n  const evalFloat = function evalFloat($acc$$4$$219, $k$$10$$220, $i$$49$$221) {\n    evalFloat: while (true) {\n      const acc$$4 = $acc$$4$$219,\n            k$$10 = $k$$10$$220,\n            i$$49 = $i$$49$$221;\n\n      if (i$$49 === n$$40.bound) {\n        return acc$$4;\n      } else {\n        $acc$$4$$219 = acc$$4 + k$$10 * n$$40.digits[i$$49];\n        $k$$10$$220 = k$$10 * basef;\n        $i$$49$$221 = i$$49 + 1;\n        continue evalFloat;\n      }\n\n      break;\n    }\n  };\n\n  return evalFloat(0, 1, 0);\n}\nexport function BigNatModule$$$ofInt32(n$$41) {\n  return BigNatModule$$$embed(n$$41);\n}\nexport function BigNatModule$$$ofInt64(n$$42) {\n  return BigNatModule$$$embed64(n$$42);\n}\nexport function BigNatModule$$$toUInt32(n$$43) {\n  const matchValue = n$$43.bound | 0;\n\n  switch (matchValue) {\n    case 0:\n      {\n        return 0;\n      }\n\n    case 1:\n      {\n        const value$$9 = n$$43.digits[0] | 0;\n        return value$$9 >>> 0;\n      }\n\n    case 2:\n      {\n        const patternInput$$10 = [n$$43.digits[0], n$$43.digits[1]];\n\n        if (patternInput$$10[1] > BigNatModule$$$baseMask32B) {\n          throw new Error();\n        } else {\n          void null;\n        }\n\n        return ((patternInput$$10[0] & BigNatModule$$$baseMask32A) >>> 0) + ((patternInput$$10[1] & BigNatModule$$$baseMask32B) >>> 0 << BigNatModule$$$baseShift32B >>> 0);\n      }\n\n    default:\n      {\n        throw new Error();\n      }\n  }\n}\nexport function BigNatModule$$$toUInt64(n$$44) {\n  const matchValue$$1 = n$$44.bound | 0;\n\n  switch (matchValue$$1) {\n    case 0:\n      {\n        return fromBits(0, 0, true);\n      }\n\n    case 1:\n      {\n        const value$$10 = n$$44.digits[0] | 0;\n        return fromInteger(value$$10, true, 2);\n      }\n\n    case 2:\n      {\n        const patternInput$$11 = [n$$44.digits[0], n$$44.digits[1]];\n        return op_Addition(fromInteger(patternInput$$11[0] & BigNatModule$$$baseMask64A, true, 2), op_LeftShift(fromInteger(patternInput$$11[1] & BigNatModule$$$baseMask64B, true, 2), BigNatModule$$$baseShift64B));\n      }\n\n    case 3:\n      {\n        const patternInput$$12 = [n$$44.digits[0], n$$44.digits[1], n$$44.digits[2]];\n\n        if (patternInput$$12[2] > BigNatModule$$$baseMask64C) {\n          throw new Error();\n        } else {\n          void null;\n        }\n\n        return op_Addition(op_Addition(fromInteger(patternInput$$12[0] & BigNatModule$$$baseMask64A, true, 2), op_LeftShift(fromInteger(patternInput$$12[1] & BigNatModule$$$baseMask64B, true, 2), BigNatModule$$$baseShift64B)), op_LeftShift(fromInteger(patternInput$$12[2] & BigNatModule$$$baseMask64C, true, 2), BigNatModule$$$baseShift64C));\n      }\n\n    default:\n      {\n        throw new Error();\n      }\n  }\n}\nexport function BigNatModule$$$toString(n$$45) {\n  const degn = BigNatModule$$$degree(n$$45) | 0;\n\n  const route = function route($prior$$227, $k$$11$$228, $ten2k$$229) {\n    route: while (true) {\n      const prior = $prior$$227,\n            k$$11 = $k$$11$$228,\n            ten2k = $ten2k$$229;\n\n      if (BigNatModule$$$degree(ten2k) > degn) {\n        return new List([k$$11, ten2k], prior);\n      } else {\n        $prior$$227 = new List([k$$11, ten2k], prior);\n        $k$$11$$228 = k$$11 + 1;\n        $ten2k$$229 = BigNatModule$$$mul(ten2k, ten2k);\n        continue route;\n      }\n\n      break;\n    }\n  };\n\n  const kten2ks = route(new List(), 0, BigNatModule$$$embed(10));\n\n  const collect = function collect(isLeading, digits, n$$46, _arg1$$1) {\n    if (_arg1$$1.tail != null) {\n      const patternInput$$13 = BigNatModule$$$divmod(n$$46, _arg1$$1.head[1]);\n\n      if (isLeading ? BigNatModule$$$isZero(patternInput$$13[0]) : false) {\n        const digits$$1 = collect(isLeading, digits, patternInput$$13[1], _arg1$$1.tail);\n        return digits$$1;\n      } else {\n        const digits$$2 = collect(false, digits, patternInput$$13[1], _arg1$$1.tail);\n        const digits$$3 = collect(isLeading, digits$$2, patternInput$$13[0], _arg1$$1.tail);\n        return digits$$3;\n      }\n    } else {\n      const n$$47 = BigNatModule$$$eval32(n$$46) | 0;\n\n      if (isLeading ? n$$47 === 0 : false) {\n        return digits;\n      } else {\n        return new List(int32ToString(n$$47), digits);\n      }\n    }\n  };\n\n  const digits$$4 = collect(true, new List(), n$$45, kten2ks);\n\n  if (digits$$4.tail == null) {\n    return \"0\";\n  } else {\n    let arg00;\n    arg00 = ofList(digits$$4, Array);\n    return join(\"\", arg00);\n  }\n}\nexport function BigNatModule$$$ofString(str) {\n  const len = str.length | 0;\n\n  if (isNullOrEmpty(str)) {\n    throw new Error(\"empty string\\\\nParameter name: str\");\n  } else {\n    void null;\n  }\n\n  const ten = BigNatModule$$$embed(10);\n\n  const build = function build($acc$$5$$235, $i$$50$$236) {\n    build: while (true) {\n      const acc$$5 = $acc$$5$$235,\n            i$$50 = $i$$50$$236;\n\n      if (i$$50 === len) {\n        return acc$$5;\n      } else {\n        const c$$12 = str[i$$50];\n        const d$$7 = c$$12.charCodeAt(0) - \"0\".charCodeAt(0) | 0;\n\n        if (0 <= d$$7 ? d$$7 <= 9 : false) {\n          $acc$$5$$235 = BigNatModule$$$add(BigNatModule$$$mul(ten, acc$$5), BigNatModule$$$embed(d$$7));\n          $i$$50$$236 = i$$50 + 1;\n          continue build;\n        } else {\n          throw new Error();\n        }\n      }\n\n      break;\n    }\n  };\n\n  return build(BigNatModule$$$embed(0), 0);\n}\nexport function BigNatModule$$$isSmall(n$$48) {\n  return n$$48.bound <= 1;\n}\nexport function BigNatModule$$$getSmall(n$$49) {\n  if (0 < n$$49.bound) {\n    return n$$49.digits[0] | 0;\n  } else {\n    return 0;\n  }\n}\nexport function BigNatModule$$$factorial(n$$50) {\n  const productR = function productR(a$$20, b$$15) {\n    if (BigNatModule$$$equal(a$$20, b$$15)) {\n      return a$$20;\n    } else {\n      const m$$3 = BigNatModule$$$div(BigNatModule$$$add(a$$20, b$$15), BigNatModule$$$ofInt32(2));\n      return BigNatModule$$$mul(productR(a$$20, m$$3), productR(BigNatModule$$$add(m$$3, BigNatModule$$$one), b$$15));\n    }\n  };\n\n  return productR(BigNatModule$$$one, n$$50);\n}","import { declare, Record } from \"../Types.js\";\nimport { class_type } from \"../Reflection.js\";\nimport { BigNatModule$$$factorial as BigNatModule$0024$0024$0024factorial, BigNatModule$$$ofString as BigNatModule$0024$0024$0024ofString, BigNatModule$$$toFloat as BigNatModule$0024$0024$0024toFloat, BigNatModule$$$toUInt64 as BigNatModule$0024$0024$0024toUInt64, BigNatModule$$$toUInt32 as BigNatModule$0024$0024$0024toUInt32, BigNatModule$$$pow as BigNatModule$0024$0024$0024pow, BigNatModule$$$rem as BigNatModule$0024$0024$0024rem, BigNatModule$$$two as BigNatModule$0024$0024$0024two, BigNatModule$$$lte as BigNatModule$0024$0024$0024lte, BigNatModule$$$hcf as BigNatModule$0024$0024$0024hcf, BigNatModule$$$bitXor as BigNatModule$0024$0024$0024bitXor, BigNatModule$$$bitOr as BigNatModule$0024$0024$0024bitOr, BigNatModule$$$bitAnd as BigNatModule$0024$0024$0024bitAnd, BigNatModule$$$divmod as BigNatModule$0024$0024$0024divmod, BigNatModule$$$mul as BigNatModule$0024$0024$0024mul, BigNatModule$$$isOne as BigNatModule$0024$0024$0024isOne, BigNatModule$$$sub as BigNatModule$0024$0024$0024sub, BigNatModule$$$gte as BigNatModule$0024$0024$0024gte, BigNatModule$$$scale as BigNatModule$0024$0024$0024scale, BigNatModule$$$add as BigNatModule$0024$0024$0024add, BigNatModule$$$one as BigNatModule$0024$0024$0024one, BigNatModule$$$ofInt64 as BigNatModule$0024$0024$0024ofInt64, BigNatModule$$$toString as BigNatModule$0024$0024$0024toString, BigNatModule$$$hash as BigNatModule$0024$0024$0024hash, BigNatModule$$$gt as BigNatModule$0024$0024$0024gt, BigNatModule$$$lt as BigNatModule$0024$0024$0024lt, BigNatModule$$$isZero as BigNatModule$0024$0024$0024isZero, BigNatModule$$$equal as BigNatModule$0024$0024$0024equal, BigNatModule$$$getSmall as BigNatModule$0024$0024$0024getSmall, BigNatModule$$$isSmall as BigNatModule$0024$0024$0024isSmall, BigNatModule$$$ofInt32 as BigNatModule$0024$0024$0024ofInt32 } from \"./n\";\nimport { initialize } from \"../Array.js\";\nimport { op_Addition, op_Multiply, fromValue, equals, compare, fromBits, op_UnaryNegation, fromInteger } from \"../Long.js\";\nimport { op_UnaryNegation_Int32 } from \"../Int32.js\";\nimport Decimal from \"../Decimal.js\";\nexport const BigInteger = declare(function BigInt_BigInteger(signInt, v) {\n  const $this$$1 = this;\n  void null;\n  $this$$1.signInt = signInt;\n  $this$$1.v = v;\n  void null;\n}, Record);\nexport function BigInteger$reflection() {\n  return class_type(\"BigInt.BigInteger\", undefined, BigInteger);\n}\nexport function BigInteger$$$$002Ector$$Z2BE94A1(signInt, v) {\n  return this instanceof BigInteger ? BigInteger.call(this, signInt, v) : new BigInteger(signInt, v);\n}\n\n(function BigInteger$$$$002Ecctor() {\n  BigInteger.smallLim = 4096;\n  BigInteger.smallPosTab = initialize(BigInteger.smallLim, BigNatModule$0024$0024$0024ofInt32, Array);\n  BigInteger.one = BigInteger$$$$002Ector$$Z524259A4(1);\n  BigInteger.two = BigInteger$$$$002Ector$$Z524259A4(2);\n  BigInteger.zero = BigInteger$$$$002Ector$$Z524259A4(0);\n  void null;\n})();\n\nexport function BigInteger$$$nat$$Z67CCE57D(n$$1) {\n  if (BigNatModule$0024$0024$0024isSmall(n$$1) ? BigNatModule$0024$0024$0024getSmall(n$$1) < BigInteger.smallLim : false) {\n    return BigInteger.smallPosTab[BigNatModule$0024$0024$0024getSmall(n$$1)];\n  } else {\n    return n$$1;\n  }\n}\nexport function BigInteger$$$create$$Z2BE94A1(s, n$$2) {\n  return BigInteger$$$$002Ector$$Z2BE94A1(s, BigInteger$$$nat$$Z67CCE57D(n$$2));\n}\nexport function BigInteger$$$posn$$Z67CCE57D(n$$3) {\n  return BigInteger$$$$002Ector$$Z2BE94A1(1, BigInteger$$$nat$$Z67CCE57D(n$$3));\n}\nexport function BigInteger$$$negn$$Z67CCE57D(n$$4) {\n  return BigInteger$$$$002Ector$$Z2BE94A1(-1, BigInteger$$$nat$$Z67CCE57D(n$$4));\n}\nexport function BigInteger$$get_Sign(x) {\n  if (BigInteger$$get_IsZero(x)) {\n    return 0;\n  } else {\n    return x.signInt | 0;\n  }\n}\nexport function BigInteger$$get_SignInt(x$$1) {\n  return x$$1.signInt;\n}\nexport function BigInteger$$get_V(x$$2) {\n  return x$$2.v;\n}\nexport function BigInteger$$$op_Equality$$56F059C0(x$$3, y) {\n  const matchValue = [BigInteger$$get_SignInt(x$$3), BigInteger$$get_SignInt(y)];\n  var $target$$12;\n\n  if (matchValue[0] === -1) {\n    if (matchValue[1] === -1) {\n      $target$$12 = 1;\n    } else if (matchValue[1] === 0) {\n      $target$$12 = 8;\n    } else if (matchValue[1] === 1) {\n      $target$$12 = 3;\n    } else {\n      $target$$12 = 9;\n    }\n  } else if (matchValue[0] === 0) {\n    if (matchValue[1] === -1) {\n      $target$$12 = 6;\n    } else if (matchValue[1] === 0) {\n      $target$$12 = 4;\n    } else if (matchValue[1] === 1) {\n      $target$$12 = 5;\n    } else {\n      $target$$12 = 9;\n    }\n  } else if (matchValue[0] === 1) {\n    if (matchValue[1] === -1) {\n      $target$$12 = 2;\n    } else if (matchValue[1] === 0) {\n      $target$$12 = 7;\n    } else if (matchValue[1] === 1) {\n      $target$$12 = 0;\n    } else {\n      $target$$12 = 9;\n    }\n  } else {\n    $target$$12 = 9;\n  }\n\n  switch ($target$$12) {\n    case 0:\n      {\n        return BigNatModule$0024$0024$0024equal(BigInteger$$get_V(x$$3), BigInteger$$get_V(y));\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024equal(BigInteger$$get_V(x$$3), BigInteger$$get_V(y));\n      }\n\n    case 2:\n      {\n        if (BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$3))) {\n          return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y));\n        } else {\n          return false;\n        }\n      }\n\n    case 3:\n      {\n        if (BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$3))) {\n          return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y));\n        } else {\n          return false;\n        }\n      }\n\n    case 4:\n      {\n        return true;\n      }\n\n    case 5:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y));\n      }\n\n    case 6:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y));\n      }\n\n    case 7:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$3));\n      }\n\n    case 8:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$3));\n      }\n\n    case 9:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$$op_Inequality$$56F059C0(x$$4, y$$1) {\n  return !BigInteger$$$op_Equality$$56F059C0(x$$4, y$$1);\n}\nexport function BigInteger$$$op_LessThan$$56F059C0(x$$5, y$$2) {\n  const matchValue$$1 = [BigInteger$$get_SignInt(x$$5), BigInteger$$get_SignInt(y$$2)];\n  var $target$$17;\n\n  if (matchValue$$1[0] === -1) {\n    if (matchValue$$1[1] === -1) {\n      $target$$17 = 1;\n    } else if (matchValue$$1[1] === 0) {\n      $target$$17 = 8;\n    } else if (matchValue$$1[1] === 1) {\n      $target$$17 = 3;\n    } else {\n      $target$$17 = 9;\n    }\n  } else if (matchValue$$1[0] === 0) {\n    if (matchValue$$1[1] === -1) {\n      $target$$17 = 6;\n    } else if (matchValue$$1[1] === 0) {\n      $target$$17 = 4;\n    } else if (matchValue$$1[1] === 1) {\n      $target$$17 = 5;\n    } else {\n      $target$$17 = 9;\n    }\n  } else if (matchValue$$1[0] === 1) {\n    if (matchValue$$1[1] === -1) {\n      $target$$17 = 2;\n    } else if (matchValue$$1[1] === 0) {\n      $target$$17 = 7;\n    } else if (matchValue$$1[1] === 1) {\n      $target$$17 = 0;\n    } else {\n      $target$$17 = 9;\n    }\n  } else {\n    $target$$17 = 9;\n  }\n\n  switch ($target$$17) {\n    case 0:\n      {\n        return BigNatModule$0024$0024$0024lt(BigInteger$$get_V(x$$5), BigInteger$$get_V(y$$2));\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024lt(BigInteger$$get_V(y$$2), BigInteger$$get_V(x$$5));\n      }\n\n    case 2:\n      {\n        return false;\n      }\n\n    case 3:\n      {\n        if (!BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$5))) {\n          return true;\n        } else {\n          return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$2));\n        }\n      }\n\n    case 4:\n      {\n        return false;\n      }\n\n    case 5:\n      {\n        return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$2));\n      }\n\n    case 6:\n      {\n        return false;\n      }\n\n    case 7:\n      {\n        return false;\n      }\n\n    case 8:\n      {\n        return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$5));\n      }\n\n    case 9:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$$op_GreaterThan$$56F059C0(x$$6, y$$3) {\n  const matchValue$$2 = [BigInteger$$get_SignInt(x$$6), BigInteger$$get_SignInt(y$$3)];\n  var $target$$20;\n\n  if (matchValue$$2[0] === -1) {\n    if (matchValue$$2[1] === -1) {\n      $target$$20 = 1;\n    } else if (matchValue$$2[1] === 0) {\n      $target$$20 = 8;\n    } else if (matchValue$$2[1] === 1) {\n      $target$$20 = 3;\n    } else {\n      $target$$20 = 9;\n    }\n  } else if (matchValue$$2[0] === 0) {\n    if (matchValue$$2[1] === -1) {\n      $target$$20 = 6;\n    } else if (matchValue$$2[1] === 0) {\n      $target$$20 = 4;\n    } else if (matchValue$$2[1] === 1) {\n      $target$$20 = 5;\n    } else {\n      $target$$20 = 9;\n    }\n  } else if (matchValue$$2[0] === 1) {\n    if (matchValue$$2[1] === -1) {\n      $target$$20 = 2;\n    } else if (matchValue$$2[1] === 0) {\n      $target$$20 = 7;\n    } else if (matchValue$$2[1] === 1) {\n      $target$$20 = 0;\n    } else {\n      $target$$20 = 9;\n    }\n  } else {\n    $target$$20 = 9;\n  }\n\n  switch ($target$$20) {\n    case 0:\n      {\n        return BigNatModule$0024$0024$0024gt(BigInteger$$get_V(x$$6), BigInteger$$get_V(y$$3));\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024gt(BigInteger$$get_V(y$$3), BigInteger$$get_V(x$$6));\n      }\n\n    case 2:\n      {\n        if (!BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$6))) {\n          return true;\n        } else {\n          return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$3));\n        }\n      }\n\n    case 3:\n      {\n        return false;\n      }\n\n    case 4:\n      {\n        return false;\n      }\n\n    case 5:\n      {\n        return false;\n      }\n\n    case 6:\n      {\n        return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$3));\n      }\n\n    case 7:\n      {\n        return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$6));\n      }\n\n    case 8:\n      {\n        return false;\n      }\n\n    case 9:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$$compare$$56F059C0(n$$5, nn) {\n  if (BigInteger$$$op_LessThan$$56F059C0(n$$5, nn)) {\n    return -1 | 0;\n  } else if (BigInteger$$$op_Equality$$56F059C0(n$$5, nn)) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nexport function BigInteger$$$hash$$Z665282C2(z) {\n  if (BigInteger$$get_SignInt(z) === 0) {\n    return 1;\n  } else {\n    return BigInteger$$get_SignInt(z) + BigNatModule$0024$0024$0024hash(BigInteger$$get_V(z)) | 0;\n  }\n}\n\nBigInteger.prototype.toString = function () {\n  const x$$7 = this;\n  const matchValue$$3 = BigInteger$$get_SignInt(x$$7) | 0;\n\n  switch (matchValue$$3) {\n    case -1:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$7)) ? \"0\" : \"-\" + BigNatModule$0024$0024$0024toString(BigInteger$$get_V(x$$7));\n      }\n\n    case 0:\n      {\n        return \"0\";\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024toString(BigInteger$$get_V(x$$7));\n      }\n\n    default:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\");\n      }\n  }\n};\n\nexport function BigInteger$$get_StructuredDisplayString(x$$8) {\n  return String(x$$8);\n}\n\nBigInteger.prototype.Equals = function (obj) {\n  const this$ = this;\n  return obj instanceof BigInteger ? BigInteger$$$op_Equality$$56F059C0(this$, obj) : false;\n};\n\nBigInteger.prototype.GetHashCode = function () {\n  const x$$9 = this;\n  return BigInteger$$$hash$$Z665282C2(x$$9) | 0;\n};\n\nexport function BigInteger$$$$002Ector$$Z524259A4(n$$6) {\n  if (n$$6 >= 0) {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, 1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024ofInt32(n$$6)));\n  } else if (n$$6 === -2147483648) {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, -1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024ofInt64(op_UnaryNegation(fromInteger(n$$6, false, 2)))));\n  } else {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, -1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024ofInt32(op_UnaryNegation_Int32(n$$6))));\n  }\n}\nexport function BigInteger$$$$002Ector$$Z524259C1(n$$7) {\n  if (compare(n$$7, fromBits(0, 0, false)) >= 0) {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, 1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024ofInt64(n$$7)));\n  } else if (equals(n$$7, fromBits(0, 2147483648, false))) {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, -1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024add(BigNatModule$0024$0024$0024ofInt64(fromBits(4294967295, 2147483647, false)), BigNatModule$0024$0024$0024one)));\n  } else {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, -1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024ofInt64(op_UnaryNegation(n$$7))));\n  }\n}\nexport function BigInteger$$$get_One() {\n  return BigInteger.one;\n}\nexport function BigInteger$$$get_Two() {\n  return BigInteger.two;\n}\nexport function BigInteger$$$get_Zero() {\n  return BigInteger.zero;\n}\nexport function BigInteger$$$op_UnaryNegation$$Z665282C2(z$$1) {\n  const matchValue$$4 = BigInteger$$get_SignInt(z$$1) | 0;\n\n  if (matchValue$$4 === 0) {\n    return BigInteger$$$get_Zero();\n  } else {\n    return BigInteger$$$create$$Z2BE94A1(op_UnaryNegation_Int32(matchValue$$4), BigInteger$$get_V(z$$1));\n  }\n}\nexport function BigInteger$$$Scale$$Z320F31E(k, z$$2) {\n  if (BigInteger$$get_SignInt(z$$2) === 0) {\n    return BigInteger$$$get_Zero();\n  } else if (k < 0) {\n    return BigInteger$$$create$$Z2BE94A1(op_UnaryNegation_Int32(BigInteger$$get_SignInt(z$$2)), BigNatModule$0024$0024$0024scale(op_UnaryNegation_Int32(k), BigInteger$$get_V(z$$2)));\n  } else {\n    return BigInteger$$$create$$Z2BE94A1(BigInteger$$get_SignInt(z$$2), BigNatModule$0024$0024$0024scale(k, BigInteger$$get_V(z$$2)));\n  }\n}\nexport function BigInteger$$$subnn$$6A57060(nx, ny) {\n  if (BigNatModule$0024$0024$0024gte(nx, ny)) {\n    return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024sub(nx, ny));\n  } else {\n    return BigInteger$$$negn$$Z67CCE57D(BigNatModule$0024$0024$0024sub(ny, nx));\n  }\n}\nexport function BigInteger$$$addnn$$6A57060(nx$$1, ny$$1) {\n  return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024add(nx$$1, ny$$1));\n}\nexport function BigInteger$$get_IsZero(x$$10) {\n  if (BigInteger$$get_SignInt(x$$10) === 0) {\n    return true;\n  } else {\n    return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$10));\n  }\n}\nexport function BigInteger$$get_IsOne(x$$11) {\n  if (BigInteger$$get_SignInt(x$$11) === 1) {\n    return BigNatModule$0024$0024$0024isOne(BigInteger$$get_V(x$$11));\n  } else {\n    return false;\n  }\n}\nexport function BigInteger$$$op_Addition$$56F059C0(x$$12, y$$4) {\n  if (BigInteger$$get_IsZero(y$$4)) {\n    return x$$12;\n  } else if (BigInteger$$get_IsZero(x$$12)) {\n    return y$$4;\n  } else {\n    const matchValue$$5 = [BigInteger$$get_SignInt(x$$12), BigInteger$$get_SignInt(y$$4)];\n    var $target$$38;\n\n    if (matchValue$$5[0] === -1) {\n      if (matchValue$$5[1] === -1) {\n        $target$$38 = 1;\n      } else if (matchValue$$5[1] === 1) {\n        $target$$38 = 3;\n      } else {\n        $target$$38 = 4;\n      }\n    } else if (matchValue$$5[0] === 1) {\n      if (matchValue$$5[1] === -1) {\n        $target$$38 = 2;\n      } else if (matchValue$$5[1] === 1) {\n        $target$$38 = 0;\n      } else {\n        $target$$38 = 4;\n      }\n    } else {\n      $target$$38 = 4;\n    }\n\n    switch ($target$$38) {\n      case 0:\n        {\n          return BigInteger$$$addnn$$6A57060(BigInteger$$get_V(x$$12), BigInteger$$get_V(y$$4));\n        }\n\n      case 1:\n        {\n          return BigInteger$$$op_UnaryNegation$$Z665282C2(BigInteger$$$addnn$$6A57060(BigInteger$$get_V(x$$12), BigInteger$$get_V(y$$4)));\n        }\n\n      case 2:\n        {\n          return BigInteger$$$subnn$$6A57060(BigInteger$$get_V(x$$12), BigInteger$$get_V(y$$4));\n        }\n\n      case 3:\n        {\n          return BigInteger$$$subnn$$6A57060(BigInteger$$get_V(y$$4), BigInteger$$get_V(x$$12));\n        }\n\n      case 4:\n        {\n          throw new Error(\"signs should be +/- 1\\\\nParameter name: x\");\n        }\n    }\n  }\n}\nexport function BigInteger$$$op_Subtraction$$56F059C0(x$$13, y$$5) {\n  if (BigInteger$$get_IsZero(y$$5)) {\n    return x$$13;\n  } else if (BigInteger$$get_IsZero(x$$13)) {\n    return BigInteger$$$op_UnaryNegation$$Z665282C2(y$$5);\n  } else {\n    const matchValue$$6 = [BigInteger$$get_SignInt(x$$13), BigInteger$$get_SignInt(y$$5)];\n    var $target$$41;\n\n    if (matchValue$$6[0] === -1) {\n      if (matchValue$$6[1] === -1) {\n        $target$$41 = 1;\n      } else if (matchValue$$6[1] === 1) {\n        $target$$41 = 3;\n      } else {\n        $target$$41 = 4;\n      }\n    } else if (matchValue$$6[0] === 1) {\n      if (matchValue$$6[1] === -1) {\n        $target$$41 = 2;\n      } else if (matchValue$$6[1] === 1) {\n        $target$$41 = 0;\n      } else {\n        $target$$41 = 4;\n      }\n    } else {\n      $target$$41 = 4;\n    }\n\n    switch ($target$$41) {\n      case 0:\n        {\n          return BigInteger$$$subnn$$6A57060(BigInteger$$get_V(x$$13), BigInteger$$get_V(y$$5));\n        }\n\n      case 1:\n        {\n          return BigInteger$$$subnn$$6A57060(BigInteger$$get_V(y$$5), BigInteger$$get_V(x$$13));\n        }\n\n      case 2:\n        {\n          return BigInteger$$$addnn$$6A57060(BigInteger$$get_V(x$$13), BigInteger$$get_V(y$$5));\n        }\n\n      case 3:\n        {\n          return BigInteger$$$op_UnaryNegation$$Z665282C2(BigInteger$$$addnn$$6A57060(BigInteger$$get_V(x$$13), BigInteger$$get_V(y$$5)));\n        }\n\n      case 4:\n        {\n          throw new Error(\"signs should be +/- 1\\\\nParameter name: x\");\n        }\n    }\n  }\n}\nexport function BigInteger$$$op_Multiply$$56F059C0(x$$14, y$$6) {\n  if (BigInteger$$get_IsZero(x$$14)) {\n    return x$$14;\n  } else if (BigInteger$$get_IsZero(y$$6)) {\n    return y$$6;\n  } else if (BigInteger$$get_IsOne(x$$14)) {\n    return y$$6;\n  } else if (BigInteger$$get_IsOne(y$$6)) {\n    return x$$14;\n  } else {\n    const m = BigNatModule$0024$0024$0024mul(BigInteger$$get_V(x$$14), BigInteger$$get_V(y$$6));\n    return BigInteger$$$create$$Z2BE94A1(BigInteger$$get_SignInt(x$$14) * BigInteger$$get_SignInt(y$$6), m);\n  }\n}\nexport function BigInteger$$$DivRem$$56F059C0(x$$15, y$$7) {\n  if (BigInteger$$get_IsZero(y$$7)) {\n    throw new Error();\n  } else {\n    void null;\n  }\n\n  if (BigInteger$$get_IsZero(x$$15)) {\n    return [BigInteger$$$get_Zero(), BigInteger$$$get_Zero()];\n  } else {\n    const patternInput = BigNatModule$0024$0024$0024divmod(BigInteger$$get_V(x$$15), BigInteger$$get_V(y$$7));\n    const matchValue$$7 = [BigInteger$$get_SignInt(x$$15), BigInteger$$get_SignInt(y$$7)];\n    var $target$$46;\n\n    if (matchValue$$7[0] === -1) {\n      if (matchValue$$7[1] === -1) {\n        $target$$46 = 1;\n      } else if (matchValue$$7[1] === 1) {\n        $target$$46 = 3;\n      } else {\n        $target$$46 = 4;\n      }\n    } else if (matchValue$$7[0] === 1) {\n      if (matchValue$$7[1] === -1) {\n        $target$$46 = 2;\n      } else if (matchValue$$7[1] === 1) {\n        $target$$46 = 0;\n      } else {\n        $target$$46 = 4;\n      }\n    } else {\n      $target$$46 = 4;\n    }\n\n    switch ($target$$46) {\n      case 0:\n        {\n          return [BigInteger$$$posn$$Z67CCE57D(patternInput[0]), BigInteger$$$posn$$Z67CCE57D(patternInput[1])];\n        }\n\n      case 1:\n        {\n          return [BigInteger$$$posn$$Z67CCE57D(patternInput[0]), BigInteger$$$negn$$Z67CCE57D(patternInput[1])];\n        }\n\n      case 2:\n        {\n          return [BigInteger$$$negn$$Z67CCE57D(patternInput[0]), BigInteger$$$posn$$Z67CCE57D(patternInput[1])];\n        }\n\n      case 3:\n        {\n          return [BigInteger$$$negn$$Z67CCE57D(patternInput[0]), BigInteger$$$negn$$Z67CCE57D(patternInput[1])];\n        }\n\n      case 4:\n        {\n          throw new Error(\"signs should be +/- 1\\\\nParameter name: x\");\n        }\n    }\n  }\n}\nexport function BigInteger$$$op_Division$$56F059C0(x$$16, y$$8) {\n  const tuple = BigInteger$$$DivRem$$56F059C0(x$$16, y$$8);\n  return tuple[0];\n}\nexport function BigInteger$$$op_Modulus$$56F059C0(x$$17, y$$9) {\n  const tuple$$1 = BigInteger$$$DivRem$$56F059C0(x$$17, y$$9);\n  return tuple$$1[1];\n}\nexport function BigInteger$$$op_RightShift$$62E082A2(x$$18, y$$10) {\n  return BigInteger$$$op_Division$$56F059C0(x$$18, BigInteger$$$Pow$$62E082A2(BigInteger$$$get_Two(), y$$10));\n}\nexport function BigInteger$$$op_LeftShift$$62E082A2(x$$19, y$$11) {\n  return BigInteger$$$op_Multiply$$56F059C0(x$$19, BigInteger$$$Pow$$62E082A2(BigInteger$$$get_Two(), y$$11));\n}\nexport function BigInteger$$$op_BitwiseAnd$$56F059C0(x$$20, y$$12) {\n  return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024bitAnd(BigInteger$$get_V(x$$20), BigInteger$$get_V(y$$12)));\n}\nexport function BigInteger$$$op_BitwiseOr$$56F059C0(x$$21, y$$13) {\n  return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024bitOr(BigInteger$$get_V(x$$21), BigInteger$$get_V(y$$13)));\n}\nexport function BigInteger$$$op_ExclusiveOr$$56F059C0(x$$22, y$$14) {\n  return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024bitXor(BigInteger$$get_V(x$$22), BigInteger$$get_V(y$$14)));\n}\nexport function BigInteger$$$GreatestCommonDivisor$$56F059C0(x$$23, y$$15) {\n  const matchValue$$8 = [BigInteger$$get_SignInt(x$$23), BigInteger$$get_SignInt(y$$15)];\n\n  if (matchValue$$8[0] === 0) {\n    if (matchValue$$8[1] === 0) {\n      return BigInteger$$$get_Zero();\n    } else {\n      return BigInteger$$$posn$$Z67CCE57D(BigInteger$$get_V(y$$15));\n    }\n  } else if (matchValue$$8[1] === 0) {\n    return BigInteger$$$posn$$Z67CCE57D(BigInteger$$get_V(x$$23));\n  } else {\n    return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024hcf(BigInteger$$get_V(x$$23), BigInteger$$get_V(y$$15)));\n  }\n}\nexport function BigInteger$$get_IsNegative(x$$24) {\n  if (BigInteger$$get_SignInt(x$$24) === -1) {\n    return !BigInteger$$get_IsZero(x$$24);\n  } else {\n    return false;\n  }\n}\nexport function BigInteger$$get_IsPositive(x$$25) {\n  if (BigInteger$$get_SignInt(x$$25) === 1) {\n    return !BigInteger$$get_IsZero(x$$25);\n  } else {\n    return false;\n  }\n}\nexport function BigInteger$$$Abs$$Z665282C2(x$$26) {\n  if (BigInteger$$get_SignInt(x$$26) === -1) {\n    return BigInteger$$$op_UnaryNegation$$Z665282C2(x$$26);\n  } else {\n    return x$$26;\n  }\n}\nexport function BigInteger$$$op_LessThanOrEqual$$56F059C0(x$$27, y$$16) {\n  const matchValue$$9 = [BigInteger$$get_SignInt(x$$27), BigInteger$$get_SignInt(y$$16)];\n  var $target$$68;\n\n  if (matchValue$$9[0] === -1) {\n    if (matchValue$$9[1] === -1) {\n      $target$$68 = 1;\n    } else if (matchValue$$9[1] === 0) {\n      $target$$68 = 6;\n    } else if (matchValue$$9[1] === 1) {\n      $target$$68 = 3;\n    } else {\n      $target$$68 = 9;\n    }\n  } else if (matchValue$$9[0] === 0) {\n    if (matchValue$$9[1] === -1) {\n      $target$$68 = 8;\n    } else if (matchValue$$9[1] === 0) {\n      $target$$68 = 4;\n    } else if (matchValue$$9[1] === 1) {\n      $target$$68 = 7;\n    } else {\n      $target$$68 = 9;\n    }\n  } else if (matchValue$$9[0] === 1) {\n    if (matchValue$$9[1] === -1) {\n      $target$$68 = 2;\n    } else if (matchValue$$9[1] === 0) {\n      $target$$68 = 5;\n    } else if (matchValue$$9[1] === 1) {\n      $target$$68 = 0;\n    } else {\n      $target$$68 = 9;\n    }\n  } else {\n    $target$$68 = 9;\n  }\n\n  switch ($target$$68) {\n    case 0:\n      {\n        return BigNatModule$0024$0024$0024lte(BigInteger$$get_V(x$$27), BigInteger$$get_V(y$$16));\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024lte(BigInteger$$get_V(y$$16), BigInteger$$get_V(x$$27));\n      }\n\n    case 2:\n      {\n        if (BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$27))) {\n          return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$16));\n        } else {\n          return false;\n        }\n      }\n\n    case 3:\n      {\n        return true;\n      }\n\n    case 4:\n      {\n        return true;\n      }\n\n    case 5:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$27));\n      }\n\n    case 6:\n      {\n        return true;\n      }\n\n    case 7:\n      {\n        return true;\n      }\n\n    case 8:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$16));\n      }\n\n    case 9:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$$op_GreaterThanOrEqual$$56F059C0(x$$28, y$$17) {\n  const matchValue$$10 = [BigInteger$$get_SignInt(x$$28), BigInteger$$get_SignInt(y$$17)];\n  var $target$$71;\n\n  if (matchValue$$10[0] === -1) {\n    if (matchValue$$10[1] === -1) {\n      $target$$71 = 1;\n    } else if (matchValue$$10[1] === 0) {\n      $target$$71 = 6;\n    } else if (matchValue$$10[1] === 1) {\n      $target$$71 = 3;\n    } else {\n      $target$$71 = 9;\n    }\n  } else if (matchValue$$10[0] === 0) {\n    if (matchValue$$10[1] === -1) {\n      $target$$71 = 8;\n    } else if (matchValue$$10[1] === 0) {\n      $target$$71 = 4;\n    } else if (matchValue$$10[1] === 1) {\n      $target$$71 = 7;\n    } else {\n      $target$$71 = 9;\n    }\n  } else if (matchValue$$10[0] === 1) {\n    if (matchValue$$10[1] === -1) {\n      $target$$71 = 2;\n    } else if (matchValue$$10[1] === 0) {\n      $target$$71 = 5;\n    } else if (matchValue$$10[1] === 1) {\n      $target$$71 = 0;\n    } else {\n      $target$$71 = 9;\n    }\n  } else {\n    $target$$71 = 9;\n  }\n\n  switch ($target$$71) {\n    case 0:\n      {\n        return BigNatModule$0024$0024$0024gte(BigInteger$$get_V(x$$28), BigInteger$$get_V(y$$17));\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024gte(BigInteger$$get_V(y$$17), BigInteger$$get_V(x$$28));\n      }\n\n    case 2:\n      {\n        return true;\n      }\n\n    case 3:\n      {\n        if (BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$28))) {\n          return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$17));\n        } else {\n          return false;\n        }\n      }\n\n    case 4:\n      {\n        return true;\n      }\n\n    case 5:\n      {\n        return true;\n      }\n\n    case 6:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$28));\n      }\n\n    case 7:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$17));\n      }\n\n    case 8:\n      {\n        return true;\n      }\n\n    case 9:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$$Pow$$62E082A2(x$$29, y$$18) {\n  if (y$$18 < 0) {\n    throw new Error(\"y\");\n  } else {\n    void null;\n  }\n\n  const matchValue$$11 = [BigInteger$$get_IsZero(x$$29), y$$18];\n\n  if (matchValue$$11[0]) {\n    if (matchValue$$11[1] === 0) {\n      return BigInteger$$$get_One();\n    } else {\n      return BigInteger$$$get_Zero();\n    }\n  } else {\n    const yval = BigInteger$$$$002Ector$$Z524259A4(y$$18);\n    return BigInteger$$$create$$Z2BE94A1(BigNatModule$0024$0024$0024isZero(BigNatModule$0024$0024$0024rem(BigInteger$$get_V(yval), BigNatModule$0024$0024$0024two)) ? 1 : BigInteger$$get_SignInt(x$$29), BigNatModule$0024$0024$0024pow(BigInteger$$get_V(x$$29), BigInteger$$get_V(yval)));\n  }\n}\nexport function BigInteger$$get_ToInt32(x$$30) {\n  if (BigInteger$$get_IsZero(x$$30)) {\n    return 0;\n  } else {\n    const u = BigNatModule$0024$0024$0024toUInt32(BigInteger$$get_V(x$$30));\n\n    if (u <= 2147483647 >>> 0) {\n      return BigInteger$$get_SignInt(x$$30) * ~~u | 0;\n    } else if (BigInteger$$get_SignInt(x$$30) === -1 ? u === 2147483647 + 1 >>> 0 : false) {\n      return -2147483648 | 0;\n    } else {\n      throw new Error();\n    }\n  }\n}\nexport function BigInteger$$get_ToUInt32(x$$31) {\n  if (BigInteger$$get_IsZero(x$$31)) {\n    return 0;\n  } else {\n    return BigNatModule$0024$0024$0024toUInt32(BigInteger$$get_V(x$$31));\n  }\n}\nexport function BigInteger$$get_ToInt64(x$$32) {\n  if (BigInteger$$get_IsZero(x$$32)) {\n    return fromBits(0, 0, false);\n  } else {\n    const u$$1 = BigNatModule$0024$0024$0024toUInt64(BigInteger$$get_V(x$$32));\n\n    if (compare(u$$1, fromValue(fromBits(4294967295, 2147483647, false), true)) <= 0) {\n      return op_Multiply(fromInteger(BigInteger$$get_SignInt(x$$32), false, 2), fromValue(u$$1, false));\n    } else if (BigInteger$$get_SignInt(x$$32) === -1 ? equals(u$$1, fromValue(op_Addition(fromBits(4294967295, 2147483647, false), fromBits(1, 0, false)), true)) : false) {\n      return fromBits(0, 2147483648, false);\n    } else {\n      throw new Error();\n    }\n  }\n}\nexport function BigInteger$$get_ToUInt64(x$$33) {\n  if (BigInteger$$get_IsZero(x$$33)) {\n    return fromBits(0, 0, true);\n  } else {\n    return BigNatModule$0024$0024$0024toUInt64(BigInteger$$get_V(x$$33));\n  }\n}\nexport function BigInteger$$get_ToDouble(x$$34) {\n  const matchValue$$12 = BigInteger$$get_SignInt(x$$34) | 0;\n\n  switch (matchValue$$12) {\n    case -1:\n      {\n        return -BigNatModule$0024$0024$0024toFloat(BigInteger$$get_V(x$$34));\n      }\n\n    case 0:\n      {\n        return 0;\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024toFloat(BigInteger$$get_V(x$$34));\n      }\n\n    default:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$get_ToSByte(x$$35) {\n  return (BigInteger$$get_ToInt32(x$$35) + 0x80 & 0xFF) - 0x80;\n}\nexport function BigInteger$$get_ToByte(x$$36) {\n  return BigInteger$$get_ToUInt32(x$$36) & 0xFF;\n}\nexport function BigInteger$$get_ToInt16(x$$37) {\n  return (BigInteger$$get_ToInt32(x$$37) + 0x8000 & 0xFFFF) - 0x8000;\n}\nexport function BigInteger$$get_ToUInt16(x$$38) {\n  return BigInteger$$get_ToUInt32(x$$38) & 0xFFFF;\n}\nexport function BigInteger$$get_ToSingle(x$$39) {\n  return BigInteger$$get_ToDouble(x$$39);\n}\nexport function BigInteger$$get_ToDecimal(x$$40) {\n  return new Decimal(BigInteger$$get_ToDouble(x$$40));\n}\nexport function BigInteger$$$Parse$$Z721C83C5(text) {\n  if (text == null) {\n    throw new Error(\"text\");\n  } else {\n    void null;\n  }\n\n  const text$$1 = text.trim();\n  const len = text$$1.length | 0;\n\n  if (len === 0) {\n    throw new Error();\n  } else {\n    void null;\n  }\n\n  const matchValue$$13 = [text$$1[0], len];\n\n  if (matchValue$$13[0] === \"+\") {\n    if (matchValue$$13[1] === 1) {\n      throw new Error();\n    } else {\n      return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024ofString(text$$1.slice(1, len - 1 + 1)));\n    }\n  } else if (matchValue$$13[0] === \"-\") {\n    if (matchValue$$13[1] === 1) {\n      throw new Error();\n    } else {\n      return BigInteger$$$negn$$Z67CCE57D(BigNatModule$0024$0024$0024ofString(text$$1.slice(1, len - 1 + 1)));\n    }\n  } else {\n    return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024ofString(text$$1));\n  }\n}\nexport function BigInteger$$get_IsSmall(x$$41) {\n  if (BigInteger$$get_IsZero(x$$41)) {\n    return true;\n  } else {\n    return BigNatModule$0024$0024$0024isSmall(BigInteger$$get_V(x$$41));\n  }\n}\nexport function BigInteger$$$Factorial$$Z665282C2(x$$42) {\n  if (BigInteger$$get_IsNegative(x$$42)) {\n    throw new Error(\"mustBeNonNegative\\\\nParameter name: x\");\n  } else {\n    void null;\n  }\n\n  if (BigInteger$$get_IsPositive(x$$42)) {\n    return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024factorial(BigInteger$$get_V(x$$42)));\n  } else {\n    return BigInteger$$$get_One();\n  }\n}\nexport function BigInteger$$$op_UnaryPlus$$Z665282C2(n1) {\n  return n1;\n}\nexport function BigInteger$$$FromInt64$$Z524259C1(x$$43) {\n  return BigInteger$$$$002Ector$$Z524259C1(x$$43);\n}\nexport function BigInteger$$$FromInt32$$Z524259A4(x$$44) {\n  return BigInteger$$$$002Ector$$Z524259A4(x$$44);\n}\n\nBigInteger.prototype.CompareTo = function (obj$$1) {\n  const this$$$1 = this;\n\n  if (obj$$1 instanceof BigInteger) {\n    return BigInteger$$$compare$$56F059C0(this$$$1, obj$$1) | 0;\n  } else {\n    throw new Error(\"the objects are not comparable\\\\nParameter name: obj\");\n  }\n};","namespace Fable.SimpleJson\n\nopen System\nopen Fable.Core\nopen FSharp.Reflection\nopen System.Numerics\nopen System.Collections\nopen System.Collections.Generic\nopen Fable.Core.JsInterop\n\nmodule Node =\n\n    /// Converts Base64 string into a byte array in Node environment\n    [<Emit(\"Array.prototype.slice.call(Buffer.from($0, 'base64'))\")>]\n    let bytesFromBase64 (value: string) : byte array = jsNative\n\nmodule Convert =\n    let internal isBrowser () : bool = importDefault \"./isBrowser.js\"\n\n    let insideBrowser = isBrowser()\n\n    [<Emit \"($0 === undefined)\">]\n    let private isUndefined (value: obj) : bool = jsNative\n    let private isDefined (value: obj) : bool = not (isUndefined value)\n\n    /// <summary>Uses internal representation of F# maps to determine whether we are using Fable 3 or not</summary>\n    let usingFable3() =\n        #if FABLE_COMPILER_3\n        true\n        #else\n        let map = JS.JSON.parse(JS.JSON.stringify (Map.ofList [ 1, 1; 2, 2 ]))\n        let tree = get \"tree\" map\n        isDefined tree && isDefined (get \"k\" tree) && isDefined (get \"v\" tree) && isDefined (get \"h\" tree)\n        #endif\n\n    let isUsingFable3 = usingFable3()\n\n    [<Emit(\"typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\")>]\n    let internal insideWorker :  bool = jsNative\n\n    [<Emit(\"$0[$1] = $2\")>]\n    let internal setProp o k v = jsNative\n\n    type InternalMap =\n        | MapEmpty\n        | MapOne of string * Json\n        | MapNode of string * Json * InternalMap * InternalMap\n\n    let rec flattenMap = function\n        | MapEmpty -> [ ]\n        | MapOne (key, value) -> [ key, value ]\n        | MapNode (key, value, left, right) ->\n            [ yield! flattenMap left\n              yield! flattenMap right\n              yield  (key, value) ]\n\n    let (|KeyValue|_|) key (map: Map<string, Json>) =\n        map\n        |> Map.tryFind key\n        |> Option.map (fun value -> key, value, Map.remove key map)\n\n    let (|NonArray|_|) = function\n        | JArray _ -> None\n        | json -> Some json\n\n    let (|MapEmpty|_|) json =\n        match json with\n        | JString \"MapEmpty\" -> Some json\n        | _ -> None\n\n    let (|MapKey|_|) = function\n        | JNumber number -> Some (string number)\n        | JString key -> Some key\n        | _ -> None\n\n    let (|MapOne|_|) = function\n        | JArray [ JString \"MapOne\"; MapKey key; value ] -> Some (key, value)\n        | _ -> None\n\n    let (|MapNode|_|) = function\n        | JArray [ JString \"MapNode\"; MapKey key; value; left; right; JNumber _  ] ->\n            Some (key, value, left, right)\n        | _ -> None\n\n    let rec generateMap json =\n        match json with\n        | MapEmpty _ -> Some InternalMap.MapEmpty\n        | MapOne (key, value) -> Some (InternalMap.MapOne (key, value))\n        | MapNode (key, value, left, right) ->\n            match generateMap left, generateMap right with\n            | Some leftMap, Some rightMap ->\n                Some (InternalMap.MapNode(key, value, leftMap, rightMap))\n            | _ -> None\n        | _ -> None\n\n    let rec flatteFable3Map (tree: Map<string, Json>) =\n        [\n            match Map.tryFind \"k\" tree, Map.tryFind \"v\" tree with\n            | Some (JString key), Some value -> (key, value)\n            | _ -> ()\n\n            match Map.tryFind \"left\" tree with\n            | Some (JObject left) -> yield! flatteFable3Map left\n            | _ -> ()\n\n            match Map.tryFind \"right\" tree with\n            | Some (JObject right) -> yield! flatteFable3Map right\n            | _ -> ()\n        ]\n\n    let rec flattenFable3Lists (linkedList: Map<string, Json>) =\n        [\n            match Map.tryFind \"head\" linkedList with\n            | Some value -> value\n            | None -> ()\n\n            match Map.tryFind \"tail\" linkedList with\n            | Some (JObject tail) -> yield! flattenFable3Lists tail\n            | _ -> ()\n        ]\n\n    /// <summary>Returns whether the type information resembles a type of a sequence of elements (including tuples)</summary>\n    let arrayLike = function\n        | TypeInfo.Array _ -> true\n        | TypeInfo.List _ -> true\n        | TypeInfo.Seq _ -> true\n        | TypeInfo.Tuple _ -> true\n        | TypeInfo.Set _ -> true\n        | TypeInfo.ResizeArray _ -> true\n        | TypeInfo.HashSet _ -> true\n        | _ -> false\n\n    let isRecord = function\n        | TypeInfo.Record recordType -> true\n        | _ -> false\n\n    let unionOfRecords = function\n        | TypeInfo.Union getCases ->\n            let (unionCases, unionType) = getCases()\n            unionCases\n            |> Seq.forall (fun case -> case.CaseTypes.Length = 1 && isRecord case.CaseTypes.[0])\n        | _ ->\n            false\n\n    let optional = function\n        | TypeInfo.Option _ -> true\n        | _ -> false\n\n    let isQuoted (input: string) =\n        input.StartsWith \"\\\"\" && input.EndsWith \"\\\"\"\n\n    let betweenQuotes (input: string) = \"\\\"\" + input + \"\\\"\"\n\n    let removeQuotes (input: string) =\n        input.Substring(1, input.Length - 2)\n\n    let rec fromJsonAs (input: Json) (typeInfo: Fable.SimpleJson.TypeInfo) : obj =\n        match input, typeInfo with\n        | JNumber value, TypeInfo.Float -> unbox value\n        | JString value, TypeInfo.Float when value.ToLower() = \"nan\" -> unbox (Double.NaN)\n        | JString value, TypeInfo.Float -> unbox (float value)\n        | JNumber value, TypeInfo.Float32 -> unbox (float32 value)\n        | JString value, TypeInfo.Float32 when value.ToLower() = \"nan\" -> unbox (Double.NaN)\n        | JString value, TypeInfo.Float32 -> unbox (float32 value)\n        // reading number as int -> floor it\n        | JNumber value, TypeInfo.Int32 -> unbox (JS.Math.floor(value))\n        | JBool value, TypeInfo.Bool -> unbox value\n        // reading int from string -> parse it\n        | JString value, TypeInfo.Int32 -> unbox (int value)\n        | JString value, TypeInfo.Char -> unbox (char value)\n        | JNumber value, TypeInfo.Char -> unbox (char (unbox<int> value))\n        // reading into strings\n        | JString value, TypeInfo.String -> unbox value\n        | JNumber value, TypeInfo.String -> unbox (string value)\n        // uri\n        | JString value, TypeInfo.Uri -> unbox(Uri(value))\n        // decimals\n        | JString value, TypeInfo.Decimal -> unbox (decimal value)\n        | JNumber value, TypeInfo.Decimal -> unbox (decimal value)\n        | JString value, TypeInfo.Short -> unbox (int16 value)\n        | JNumber value, TypeInfo.Short -> unbox (int16 value)\n        // Unsigned integers\n        | JNumber value, TypeInfo.UInt16 -> unbox (uint16 value)\n        | JString value, TypeInfo.UInt16 -> unbox (uint16 value)\n        | JNumber value, TypeInfo.UInt32 -> unbox (uint32 value)\n        | JString value, TypeInfo.UInt32 -> unbox (uint32 value)\n        | JNumber value, TypeInfo.UInt64 -> unbox (uint64 value)\n        | JString value, TypeInfo.UInt64 -> unbox (uint64 value)\n        | JNumber value, TypeInfo.TimeSpan -> unbox (JS.Math.floor value)\n        | JString value, TypeInfo.Enum getlElemType ->\n            let (underlyingType, originalType) = getlElemType()\n            match underlyingType with\n            | TypeInfo.Int32 ->\n                match Int32.TryParse(value) with\n                | true, parsedNumber ->\n                    unbox parsedNumber\n                | false, _ ->\n                    failwithf \"The value '%s' is not valid for enum of type '%s'\" value originalType.Name\n            | TypeInfo.Long ->\n                match Int64.TryParse(value) with\n                | true, parsedNumber ->\n                    unbox parsedNumber\n                | false, _ ->\n                    failwithf \"The value '%s' is not valid for enum of type '%s'\" value originalType.Name\n            | other ->\n                failwithf \"The value '%s' cannot be converted to enum of type '%s'\" value originalType.Name\n        | JNumber value, TypeInfo.Enum getElemType ->\n            let (_, originalType) = getElemType()\n            unbox value\n        // byte[] coming from the server is serialized as base64 string\n        // convert it back to the actual byte array\n        | JString value, TypeInfo.Array getElemType ->\n            let elemType = getElemType()\n            match elemType with\n            | TypeInfo.Byte ->\n                if insideWorker || insideBrowser\n                then unbox (Convert.FromBase64String value)\n                else unbox (Node.bytesFromBase64 value)\n            | otherType -> failwithf \"Cannot convert arbitrary string '%s' to %A\" value otherType\n\n        // null values for strings are just the null string\n        | JNull, TypeInfo.String -> unbox null\n        | JNull, TypeInfo.Unit -> unbox ()\n        | genericJson, TypeInfo.Object -> unbox (SimpleJson.toPlainObject genericJson)\n        // int64 as string -> parse it\n        | JString value, TypeInfo.Long -> unbox (int64 value)\n        | JString value, TypeInfo.Byte -> unbox (byte value)\n        | JNumber value, TypeInfo.Byte -> unbox (byte value)\n        | JNumber value, TypeInfo.SByte -> unbox (sbyte value)\n        | JString value, TypeInfo.SByte -> unbox (sbyte value)\n        // BigInt as string -> parse it\n        | JString value, TypeInfo.BigInt -> unbox (BigInteger.Parse value)\n        | JNumber value, TypeInfo.BigInt -> unbox (bigint (JS.Math.floor(value)))\n        // parse formatted date time\n        | JString value, TypeInfo.DateTime -> unbox (DateTime.Parse(value))\n        // parse formatted date time offset\n        | JString value, TypeInfo.DateTimeOffset -> unbox (DateTimeOffset.Parse(value))\n        | JNumber value, TypeInfo.DateTimeOffset ->\n            let seconds = int64 (JS.Math.floor(value))\n            unbox (DateTimeOffset.FromUnixTimeSeconds seconds)\n#if NET6_0_OR_GREATER\n        // TimeOnly, DateOnly\n        | JNumber value, TypeInfo.DateOnly -> unbox (DateOnly.FromDayNumber (int value))\n        | JString value, TypeInfo.DateOnly -> unbox (DateOnly.FromDayNumber (int value))\n        | JString value, TypeInfo.TimeOnly -> unbox (TimeOnly (int64 value))\n#endif\n\n        // deserialize union from objects\n        // { \"One\": 20 } or {\"One\": [20]} -> One of int\n        | JObject values, TypeInfo.Union (getTypes) ->\n            let (cases, unionType) = getTypes()\n            match Map.toList values with\n            | [ caseName, JArray values ] ->\n                cases\n                |> Array.tryFind (fun case -> case.CaseName = caseName)\n                |> function\n                    | None ->\n                        let caseNames = Array.map (fun case -> sprintf \" '%s' \" case.CaseName) cases\n                        let expectedCases = String.concat \", \" caseNames\n                        failwithf \"Case %s was not valid for type '%s', expected one of the cases [%s]\" caseName unionType.Name expectedCases\n                    | Some foundCase when Array.length foundCase.CaseTypes = 1 && arrayLike foundCase.CaseTypes.[0] ->\n                        let deserialized = fromJsonAs (JArray values) foundCase.CaseTypes.[0]\n                        FSharpValue.MakeUnion(foundCase.Info, [| deserialized |])\n                        |> unbox\n                    | Some foundCase when Array.length foundCase.CaseTypes = 1 && optional foundCase.CaseTypes.[0] ->\n                        let parsedOptional = unbox (fromJsonAs (JArray values) foundCase.CaseTypes.[0])\n                        FSharpValue.MakeUnion(foundCase.Info, [| parsedOptional |])\n                        |> unbox\n                    | Some foundCase ->\n                        if Array.length foundCase.CaseTypes = 1\n                            && not (arrayLike foundCase.CaseTypes.[0])\n                            && Array.length foundCase.CaseTypes <> List.length values\n                        then failwithf \"Expected case '%s' to have %d argument types but the JSON data only contained %d values\" foundCase.CaseName (Array.length foundCase.CaseTypes) (List.length values)\n                        let parsedValues =\n                            Array.ofList values\n                            |> Array.zip foundCase.CaseTypes\n                            |> Array.map (fun (valueType, value) -> fromJsonAs value valueType)\n                        FSharpValue.MakeUnion(foundCase.Info, parsedValues)\n                        |> unbox\n            | [ caseName, NonArray json ] ->\n                cases\n                |> Array.tryFind (fun case -> case.CaseName = caseName)\n                |> function\n                    | Some ({ CaseName = caseName; Info = caseInfo; CaseTypes = [| caseType |] }) ->\n                        FSharpValue.MakeUnion(caseInfo, [| unbox fromJsonAs json caseType |])\n                        |> unbox\n                    | _ ->\n                        let caseNames = Array.map (fun case -> sprintf \" '%s' \" case.CaseName) cases\n                        let expectedCases = String.concat \", \" caseNames\n                        failwithf \"Case %s was not valid for type '%s', expected one of the cases [%s]\" caseName unionType.Name expectedCases\n\n            // Specific for Fable 3\n            | otherwise when Map.containsKey \"tag\" values && Map.containsKey \"fields\" values && Map.count values = 2 ->\n                match Map.tryFind \"tag\" values, Map.tryFind \"fields\" values with\n                | Some (JNumber caseIndex), Some (JArray fieldValues) ->\n                    let foundCase = cases.[int caseIndex]\n                    let values =\n                        fieldValues\n                        |> Array.ofList\n                        |> Array.mapi (fun index value -> fromJsonAs value (foundCase.CaseTypes.[index]))\n\n                    FSharpValue.MakeUnion(foundCase.Info, values)\n                | _ ->\n                    failwithf \"Could not deserialize JSON(%s) into type %s\" (SimpleJson.toString (JObject values)) unionType.FullName\n\n            | otherwise when unionOfRecords typeInfo ->\n                let discriminators = [\"__typename\"; \"$typename\"; \"$type\" ]\n                let foundDiscriminatorKey =\n                    discriminators\n                    |> List.tryFind (fun keyword -> Map.containsKey keyword values)\n\n                match foundDiscriminatorKey with\n                | None ->\n                    failwithf \"Could not serialize the JSON object into the union of records of type %s because the JSON did not contain a known discriminator. Expected '__typename', '$typeName' or '$type'\" unionType.Name\n                | Some discriminatorKey ->\n                    let discriminatorValueJson = Map.find discriminatorKey values\n                    match discriminatorValueJson with\n                    | JString discriminatorValue ->\n                        let foundUnionCase =\n                            cases\n                            |> Seq.tryFind (fun case -> case.CaseName.ToUpperInvariant() = discriminatorValue.ToUpperInvariant())\n\n                        match foundUnionCase with\n                        | None ->\n                            failwithf \"Union of records of type '%s' does not have a matching case '%s'\" unionType.Name discriminatorValue\n                        | Some case ->\n                            // Assuming the case types is [recordType]\n                            // one element of types and the first element is a record\n                            // as satisfied by the unionOfRecords function\n                            let record = unbox (fromJsonAs (JObject values) (case.CaseTypes.[0]))\n                            FSharpValue.MakeUnion(case.Info, [| record |])\n                    | otherwise ->\n                        failwithf \"Union of records of type '%s' cannot be deserialized with the value of the discriminator key is not a string to match against a specific union case\" unionType.Name\n            | otherwise ->\n                // TODO!!! Better error messages here\n                let unexpectedJson = JS.JSON.stringify otherwise\n                let expectedType = JS.JSON.stringify cases\n                failwithf \"Expected JSON:\\n%s\\nto match the type\\n%s\" unexpectedJson expectedType\n        | JNull, TypeInfo.Option _ -> unbox None\n        | jsonValue, TypeInfo.Option optionalTypeDelayed when jsonValue <> JNull ->\n            let optionalType = optionalTypeDelayed()\n            let parsedOptional = unbox (fromJsonAs jsonValue optionalType)\n            unbox Some parsedOptional\n        | JString value, TypeInfo.Guid _ -> unbox (System.Guid.Parse(value))\n        // int64 as a number, convert it to int then to in64\n        | JNumber value , TypeInfo.Long _ -> unbox int64 (int value)\n        // int64 as the internal representation from Long.js\n        // then reconstruct it from the high/low (two integers) components\n        | JObject dict, TypeInfo.Long _ ->\n            let get key = Map.tryFind key dict\n            [ get \"low\"; get \"high\"; get \"unsigned\" ]\n            |> List.choose id\n            |> function\n                | [ JNumber low; JNumber high; JBool _ ] ->\n                    let lowBytes = BitConverter.GetBytes(int low)\n                    let highBytes = BitConverter.GetBytes(int high)\n                    let combinedBytes = Array.concat [ lowBytes; highBytes ]\n                    BitConverter.ToInt64(combinedBytes, 0)\n                    |> unbox\n                | _ -> failwithf \"Unable to construct int64 from object literal { low: int, high: int, unsigned: bool }\"\n        // convert a single case string to union\n        // \"One\" -> One, here is a special case where the case in quoted inside the string\n        | JString caseName, TypeInfo.Union getTypes when isQuoted caseName ->\n            let (caseTypes, unionType) = getTypes()\n            caseTypes\n            |> Array.tryFind (fun case -> case.CaseName = removeQuotes caseName)\n            |> function\n                | Some ({ Info = caseInfo }) -> unbox (FSharpValue.MakeUnion(caseInfo, [||]))\n                | None ->\n                    let caseNames = Array.map (fun case -> sprintf \" '%s' \" case.CaseName) caseTypes\n                    let expectedCases = String.concat \", \" caseNames\n                    failwithf \"Case %s was not valid for type '%s', expected one of the cases [%s]\" caseName unionType.Name expectedCases\n        // convert a single case string to union\n        // \"One\" -> One\n        | JString caseName, TypeInfo.Union getTypes ->\n            let (caseTypes, unionType) = getTypes()\n            caseTypes\n            |> Array.tryFind (fun case -> case.CaseName = caseName)\n            |> function\n                | Some ({ Info = caseInfo }) -> unbox (FSharpValue.MakeUnion(caseInfo, [||]))\n                | None ->\n                    let caseNames = Array.map (fun case -> sprintf \" '%s' \" case.CaseName) caseTypes\n                    let expectedCases = String.concat \", \" caseNames\n                    failwithf \"Case %s was not valid for type '%s', expected one of the cases [%s]\" caseName unionType.Name expectedCases\n        | JString serializedRecord, TypeInfo.Record getFields ->\n            fromJsonAs (SimpleJson.parse serializedRecord) typeInfo\n        // convert unions from arrays\n        // [\"One\", 20] -> One of int\n        | JArray caseValue, TypeInfo.Union getTypes ->\n            let (cases, unionType) = getTypes()\n            match caseValue with\n            // Union case without values\n            | [ JString caseName ] ->\n                cases\n                |> Array.tryFind (fun case -> case.CaseName = caseName)\n                |> function\n                    | Some ({ CaseName = caseName; Info = caseInfo; CaseTypes = caseInfoTypes }) ->\n                        // single case without values\n                        unbox (FSharpValue.MakeUnion(caseInfo, [||]))\n                    | None ->\n                        let caseNames = Array.map (fun case -> sprintf \" '%s' \" case.CaseName) cases\n                        let expectedCases = String.concat \", \" caseNames\n                        failwithf \"Case '%s' was not valid for type '%s', expected one of the cases [%s]\" caseName unionType.Name expectedCases\n            | JString caseName :: values ->\n                cases\n                |> Array.tryFind (fun case -> case.CaseName = caseName)\n                |> function\n                    | None ->\n                        let caseNames = Array.map (fun ({ CaseName = name }) -> name) cases\n                        let expectedCases = String.concat \", \" caseNames\n                        failwithf \"Case %s was not valid, expected one of [%s]\" caseName expectedCases\n                    | Some ({ CaseName = foundCaseName; Info = caseInfo; CaseTypes = types }) ->\n                        if Array.length types <> List.length values\n                        then failwithf \"The number of union case parameters for '%s' is different\" foundCaseName\n                        let parsedValues =\n                            Array.ofList values\n                            |> Array.zip types\n                            |> Array.map (fun (valueType, value) -> fromJsonAs value valueType)\n                        FSharpValue.MakeUnion(caseInfo, parsedValues)\n                        |> unbox\n            | otherwise ->\n                let unexpectedJson = JS.JSON.stringify otherwise\n                let expectedType = JS.JSON.stringify cases\n                failwithf \"Expected JSON:\\n%s\\nto match the type\\n%s\" unexpectedJson expectedType\n        // Arrays\n        | JArray values, TypeInfo.Array elementTypeDelayed ->\n            let elementType = elementTypeDelayed()\n            values\n            |> List.map (fun value -> unbox (fromJsonAs value elementType))\n            |> Array.ofList\n            |> unbox\n        // Lists\n        | JArray values, TypeInfo.List elementTypeDelayed ->\n            let elementType = elementTypeDelayed()\n            values\n            |> List.map (fun value -> unbox (fromJsonAs value elementType))\n            |> unbox\n\n        // Specific for Fable 3\n        | JObject linkedList, TypeInfo.List elementTypeDelayed ->\n            let elementType = elementTypeDelayed()\n            let flattenedList = flattenFable3Lists linkedList\n            flattenedList\n            |> List.map (fun value -> unbox (fromJsonAs value elementType))\n            |> unbox\n\n        | JArray values, TypeInfo.Set elementTypeDelayed ->\n            let elementType = elementTypeDelayed()\n            values\n            |> List.map (fun value -> unbox (fromJsonAs value elementType))\n            |> Set.ofList\n            |> unbox\n\n        | JArray values, TypeInfo.Seq elementTypeDelayed ->\n            let elementType = elementTypeDelayed()\n            let converted = List.map (fun value -> unbox (fromJsonAs value elementType)) values\n            unbox converted\n        // Tuples, become just arrays\n        | JArray array, TypeInfo.Tuple tupleTypesDelayed ->\n            let tupleTypes = tupleTypesDelayed()\n            array\n            |> Array.ofList\n            |> Array.zip tupleTypes\n            |> Array.map (fun (jsonType, jsonData) -> fromJsonAs jsonData jsonType)\n            |> unbox\n        // Records\n        | JObject dict, TypeInfo.Record getTypes ->\n            let fields, recordType = getTypes()\n            // Match the JSON object literal keys with their types\n            let recordValues =\n                let values = Map.toList dict\n                fields\n                |> Array.map (fun ({ FieldName = fieldName; FieldType = fieldType }) ->\n                    values\n                    |> List.tryFind (fun (key, value) -> fieldName = key)\n                    |> function\n                        | Some (key, value) -> unbox (fromJsonAs value fieldType)\n                        | None ->\n                            match fieldType with\n                            // field type is an option of something, just return None\n                            | TypeInfo.Option _ -> unbox None\n                            | _ ->\n                              // field type is required and it doens't exist in the JSON\n                              // then generate a nice error message\n                              let dictKeys =\n                                  Map.toList dict\n                                  |> List.map (fst >> sprintf \"'%s'\")\n                                  |> String.concat \", \"\n                                  |> sprintf \"[ %s ]\"\n                              let recordFields =\n                                  fields\n                                  |> Array.map (fun ({ FieldName = name; FieldType = innerFieldType }) ->\n                                      match innerFieldType with\n                                      | TypeInfo.Option _ -> sprintf \"optional('%s')\" name\n                                      | _ -> sprintf \"required('%s')\" name)\n                                  |> String.concat \", \"\n                                  |> sprintf \"[ %s ]\"\n                              failwithf \"Could not find the required key '%s' in the JSON object literal with keys %s to match with record type '%s' that has fields %s\" fieldName dictKeys recordType.Name recordFields)\n            unbox (FSharpValue.MakeRecord(recordType, recordValues))\n\n        | JArray tuples, TypeInfo.Map getTypes ->\n            let (keyType, valueType) = getTypes()\n            let pairs =\n                [ for keyValuePair in tuples do\n                    let tuple = fromJsonAs keyValuePair (TypeInfo.Tuple (let a = [| keyType; valueType |] in fun () -> a))\n                    yield tuple ]\n            match keyType with\n            | TypeInfo.Int32\n            | TypeInfo.String\n            | TypeInfo.Bool ->\n                pairs\n                |> unbox<(string * obj) list>\n                |> Map.ofList\n                |> unbox\n            | _ ->\n                pairs\n                |> unbox<(IStructuralComparable * obj) list>\n                |> Map.ofList\n                |> unbox\n\n        | JArray tuples, TypeInfo.Dictionary getTypes ->\n            let (keyType, valueType, originalType) = getTypes()\n            let pairs =\n                [ for keyValuePair in tuples do\n                    let tuple = fromJsonAs keyValuePair (TypeInfo.Tuple (fun () -> [| keyType; valueType |]))\n                    yield tuple ]\n\n            let output =\n                match keyType with\n                | TypeInfo.Union _ ->  Dictionary<Result<_, _>, _>()\n                | TypeInfo.Record _ -> Dictionary<{| dummy: int |}, _>() |> unbox\n                | _ -> Dictionary<IStructuralComparable, _>() |> unbox\n\n            for (key, value) in (unbox<(IStructuralComparable * obj) list> pairs) do output.Add(unbox key, value)\n            unbox output\n\n        | JObject dict, TypeInfo.Dictionary getTypes ->\n            let (keyType, valueType, originalType) = getTypes()\n            dict\n            |> Map.toList\n            |> List.map (fun (key, value) -> fromJsonAs (JString key) keyType, fromJsonAs value valueType )\n            |> fun pairs ->\n                let output =\n                    match keyType with\n                    | TypeInfo.Union _ -> Dictionary<Result<_, _>, _>()\n                    | TypeInfo.Record _ -> Dictionary<{| dummy: int |}, _>() |> unbox\n                    | _ -> Dictionary<IStructuralComparable, _>() |> unbox\n\n                for (key, value) in pairs do output.Add(unbox key, value)\n\n                unbox output\n\n        | JArray items, TypeInfo.HashSet getType ->\n            let elemType = getType()\n            let hashset =\n                match elemType with\n                | TypeInfo.Union _ -> HashSet<Result<_, _>>()\n                | TypeInfo.Record _ -> HashSet<{| dummy: int |}>() |> unbox\n                | _ -> HashSet<IStructuralComparable>() |> unbox\n\n            for item in items do\n                let deserialized = fromJsonAs item elemType\n                hashset.Add(unbox deserialized) |> ignore\n\n            unbox hashset\n\n        | JObject map, TypeInfo.Map getTypes ->\n            let (keyType, valueType) = getTypes()\n            // check whether the map is serialized to it's internal representation\n            // and convert that to back to a normal map from the data\n            match Map.tryFind \"comparer\" map, Map.tryFind \"tree\" map with\n            | Some (JObject comparer), Some (JArray tree) when Map.isEmpty comparer ->\n                match generateMap (JArray tree) with\n                | Some internalMap ->\n                    let pairs =\n                        flattenMap internalMap\n                        |> List.map (fun (key, value) ->\n                            let nextKey =\n                                if not (isQuoted key)\n                                then unbox (fromJsonAs (JString key) keyType)\n                                else unbox (fromJsonAs (SimpleJson.parseNative key) keyType)\n                            let nextValue = unbox (fromJsonAs value valueType)\n                            unbox<obj> nextKey, nextValue)\n                    match keyType with\n                    | TypeInfo.Int32\n                    | TypeInfo.String\n                    | TypeInfo.Bool ->\n                        pairs\n                        |> unbox<(string * obj) list>\n                        |> Map.ofList\n                        |> unbox\n                    | _ ->\n                        pairs\n                        |> unbox<(IStructuralComparable * obj) list>\n                        |> Map.ofList\n                        |> unbox\n\n                | None ->\n                    let inputJson = SimpleJson.toString (JArray tree)\n                    failwithf \"Could not generate map from JSON\\n %s\" inputJson\n\n            // Specific for Fable 3\n            | Some (JObject comparer), Some (JObject tree) when Map.isEmpty comparer ->\n                let flattenedMap = Map.ofList (flatteFable3Map tree)\n                fromJsonAs (JObject flattenedMap) typeInfo\n            | _ ->\n                // if comparer and tree are not present,\n                // assume we are parsing Fable 1 object literal\n                // and converting that to map\n                let pairs =\n                    map\n                    |> Map.toList\n                    |> List.map (fun (key, value) ->\n                        let nextKey =\n                            if not (isQuoted key)\n                            then\n                                if Converter.isPrimitive keyType || Converter.enumUnion keyType\n                                then\n                                    // for primitive type, just read them as string and parse\n                                    unbox (fromJsonAs (JString key) keyType)\n                                else\n                                    // server-side JSON can still be complex (for complex types)\n                                    // but doesn't have to be quoted, parse again here\n                                    unbox (fromJsonAs (SimpleJson.parseNative key) keyType)\n                            else\n                                unbox (fromJsonAs (SimpleJson.parseNative key) keyType)\n                        let nextValue = unbox (fromJsonAs value valueType)\n                        unbox<string> nextKey, nextValue)\n\n                match keyType with\n                | TypeInfo.Int32\n                | TypeInfo.String\n                | TypeInfo.Bool ->\n                    pairs\n                    |> unbox<(string * obj) list>\n                    |> Map.ofList\n                    |> unbox\n                | _ ->\n                    pairs\n                    |> unbox<(IStructuralComparable * obj) list>\n                    |> Map.ofList\n                    |> unbox\n        | _, TypeInfo.Any getType ->\n            let unknownType = getType()\n            failwithf \"Cannot convert %s to %s\" (SimpleJson.toString input) unknownType.FullName\n        | _ ->\n            failwithf \"Cannot convert %s to %s\" (SimpleJson.toString input) (JS.JSON.stringify typeInfo)\n\n    let fromJson<'t> json typeInfo =\n        unbox<'t> (fromJsonAs json typeInfo)\n\n    let quoteText (inputText: string) : string = importDefault \"./quote.js\"\n\n    let rec serialize value (typeInfo: TypeInfo) =\n        match typeInfo with\n        | TypeInfo.String ->\n            let content = unbox<string> value\n            if isNull content\n            then \"null\"\n            else quoteText content\n        | TypeInfo.Unit -> \"null\"\n        | TypeInfo.Float\n        | TypeInfo.Float32 ->\n            if Double.IsNaN(unbox value)\n            then quoteText \"NaN\"\n            else string (unbox<double> value)\n        | TypeInfo.Char -> quoteText (string (unbox<char> value))\n        | TypeInfo.Byte\n        | TypeInfo.SByte\n        | TypeInfo.UInt16\n        | TypeInfo.UInt32\n        | TypeInfo.Short\n        | TypeInfo.Enum _\n        | TypeInfo.TimeSpan\n        | TypeInfo.Int32 -> string (unbox<int> value)\n        | TypeInfo.UInt64\n        | TypeInfo.Long -> betweenQuotes (string (unbox<int64> value))\n        | TypeInfo.BigInt -> betweenQuotes (string (unbox<bigint> value))\n        | TypeInfo.Decimal -> betweenQuotes (string (unbox<decimal> value))\n        | TypeInfo.Bool -> if unbox<bool> value then \"true\" else \"false\"\n        | TypeInfo.Guid -> betweenQuotes ((unbox<Guid> value).ToString())\n        | TypeInfo.Uri -> betweenQuotes ((unbox<Uri> value).ToString())\n        | TypeInfo.DateTime -> betweenQuotes ((unbox<DateTime> value).ToString(\"O\"))\n        | TypeInfo.DateTimeOffset -> betweenQuotes ((unbox<DateTimeOffset> value).ToString(\"O\"))\n#if NET6_0_OR_GREATER\n        | TypeInfo.DateOnly -> string (unbox<DateOnly> value).DayNumber\n        | TypeInfo.TimeOnly -> betweenQuotes (string (unbox<TimeOnly> value).Ticks)\n#endif\n        | TypeInfo.Record getFields ->\n            let (fieldTypes, recordType) = getFields()\n            let serializedFields =\n                fieldTypes\n                |> Array.map (fun field ->\n                    let fieldValue = FSharpValue.GetRecordField(value, field.PropertyInfo)\n                    sprintf \"\\\"%s\\\": %s\" field.FieldName (serialize fieldValue field.FieldType)\n                )\n\n            \"{\" + String.concat \", \" serializedFields + \"}\"\n\n        | TypeInfo.ResizeArray getElementType ->\n            let elementType = getElementType()\n            let values =\n                value\n                |> unbox<ResizeArray<obj>>\n                |> Seq.map (fun element -> serialize element elementType)\n                |> String.concat \", \"\n\n            \"[\" + values + \"]\"\n\n        | TypeInfo.HashSet getElementType ->\n            let elementType = getElementType()\n            let values =\n                value\n                |> unbox<HashSet<obj>>\n                |> Seq.map (fun element -> serialize element elementType)\n                |> String.concat \", \"\n\n            \"[\" + values + \"]\"\n\n        | TypeInfo.Set getElementType ->\n            let elementType = getElementType()\n            let values =\n                value\n                |> unbox<Set<IComparable>>\n                |> Seq.map (fun element -> serialize element elementType)\n                |> String.concat \", \"\n\n            \"[\" + values + \"]\"\n\n        | TypeInfo.Array getElementType ->\n            let elementType = getElementType()\n            let values =\n                value\n                |> unbox<obj []>\n                |> Array.map (fun element -> serialize element elementType)\n                |> String.concat \", \"\n\n            \"[\" + values + \"]\"\n\n        | TypeInfo.List getElementType ->\n            let elementType = getElementType()\n            let values =\n                value\n                |> unbox<obj list>\n                |> List.map (fun element -> serialize element elementType)\n                |> String.concat \", \"\n\n            \"[\" + values + \"]\"\n\n        | TypeInfo.Seq getElementType ->\n            let elementType = getElementType()\n            let values =\n                value\n                |> unbox<obj seq>\n                |> Seq.toArray\n                |> Array.map (fun element -> serialize element elementType)\n                |> String.concat \", \"\n\n            \"[\" + values + \"]\"\n\n        | TypeInfo.Option getElementType ->\n            match unbox<obj option> value with\n            | None -> \"null\"\n            | Some existingValue -> serialize existingValue (getElementType())\n\n        | TypeInfo.Union getCases ->\n            let (unionCases, unionType) = getCases()\n            let (usedCase, fields) = FSharpValue.GetUnionFields(value, unionType)\n            let caseTypes =\n                unionCases\n                |> Array.find (fun case -> case.CaseName = usedCase.Name)\n                |> fun case -> case.CaseTypes\n\n            if enumUnion typeInfo || Array.isEmpty caseTypes then\n                betweenQuotes usedCase.Name\n            elif caseTypes.Length = 1 then\n                \"{\" + betweenQuotes usedCase.Name + \": \" + serialize fields.[0] caseTypes.[0] + \"}\"\n            else\n                let serializedFields =\n                    caseTypes\n                    |> Array.mapi (fun index caseType -> serialize fields.[index] caseType)\n                    |> String.concat \", \"\n\n                \"{\" + betweenQuotes usedCase.Name + \": \" + \"[\" + serializedFields + \"] }\"\n\n        | TypeInfo.Map getPairTypes ->\n            let (keyType, valueType) = getPairTypes()\n\n            let serializedValues =\n                value\n                |> unbox<Map<IComparable, obj>>\n                |> Map.toArray\n                |> Array.map (fun (key, value) ->\n                    let serializedKey = serialize key keyType\n                    let serializedValue = serialize value valueType\n\n                    if isPrimitive keyType || enumUnion keyType then\n                        if not (isQuoted serializedKey)\n                        then (quoteText serializedKey) + \": \" + serializedValue\n                        else serializedKey + \": \" + serializedValue\n                    else\n                        \"[\" + serializedKey + \", \" + serializedValue + \"]\"\n                )\n                |> String.concat \", \"\n\n            if isPrimitive keyType || enumUnion keyType\n            then \"{\" + serializedValues + \"}\"\n            else \"[\" + serializedValues + \"]\"\n\n        | TypeInfo.Dictionary getPairTypes ->\n            let (keyType, valueType, originalType) = getPairTypes()\n            let serializedValues =\n                value\n                |> unbox<Dictionary<IComparable, obj>>\n                |> Seq.map (fun pair ->\n                    let (key, value) = pair.Key, pair.Value\n                    let serializedKey = serialize key keyType\n                    let serializedValue = serialize value valueType\n\n                    if isPrimitive keyType || enumUnion keyType then\n                        if not (isQuoted serializedKey)\n                        then (betweenQuotes serializedKey) + \": \" + serializedValue\n                        else serializedKey + \": \" + serializedValue\n                    else\n                        \"[\" + serializedKey + \", \" + serializedValue + \"]\"\n                )\n                |> String.concat \", \"\n\n            if isPrimitive keyType || enumUnion keyType\n            then \"{\" + serializedValues + \"}\"\n            else \"[\" + serializedValues + \"]\"\n\n        | TypeInfo.Tuple getTupleTypes ->\n            let tupleTypes = getTupleTypes()\n\n            if tupleTypes.Length = 1 then\n                \"[\" + serialize value tupleTypes.[0] + \"]\"\n            else\n                let serializedValues =\n                    value\n                    |> unbox<obj array>\n                    |> Array.mapi (fun index element -> serialize element tupleTypes.[index])\n                    |> String.concat \", \"\n\n                \"[\" + serializedValues + \"]\"\n\n        | TypeInfo.Object ->\n            SimpleJson.stringify value\n\n        | TypeInfo.Any getType ->\n            // fallback to low-level serialization\n            SimpleJson.stringify value\n\n        | _ ->\n            \"null\"\n\n[<AutoOpenAttribute>]\nmodule ConverterExtensions =\n    type Json with\n\n        /// <summary>\n        /// Serialized the input value object into JSON, uses built-in JSON.stringify and should be used with Fable 2.x or earlier\n        /// </summary>\n        static member stringify (value: obj) : string =\n            if Convert.isUsingFable3\n            then JS.console.warn(\"It looks like you using the function Json.stringify from Fable.SimpleJson while also using Fable 3 (nagareyama). Please use Json.serialize instead which supports both Fable 3 and Fable 2.x\")\n            SimpleJson.stringify value\n\n        /// <summary>\n        /// Serialized the input value into JSON using Reflection. Compatible with Fable 2.x and Fable 3 (codename: nagareyama)\n        /// </summary>\n        static member inline serialize<'t> (value: 't) : string =\n            let typeInfo = TypeInfo.createFrom<'t>()\n            Convert.serialize value typeInfo\n\n        /// Parses the input string as JSON and tries to convert it as the given type argument\n        static member inline parseAs<'t> (input: string) : 't =\n            match SimpleJson.tryParse input with\n            | None -> failwith \"Couldn't parse the input JSON string because it seems to be invalid\"\n            | Some inputJson ->\n                let typeInfo = TypeInfo.createFrom<'t> ()\n                Convert.fromJson<'t> inputJson typeInfo\n\n        /// Parses the input string as JSON using native parsing and tries to convert it as the given type argument\n        static member inline parseNativeAs<'t> (input: string) : 't =\n            let inputJson = SimpleJson.parseNative input\n            let typeInfo = TypeInfo.createFrom<'t> ()\n            Convert.fromJson<'t> inputJson typeInfo\n\n        /// Tries to parse the input string as JSON and tries to convert it as the given type argument, returing a (hopefully) useful error message when it fails\n        static member inline tryParseAs<'t> (input: string) : Result<'t, string> =\n            try Ok (Json.parseAs<'t> input)\n            with | ex -> Error ex.Message\n\n        /// Tries to parse the input string as JSON using native parsing and tries to convert it as the given type argument\n        static member inline tryParseNativeAs<'t> (input: string) : Result<'t, string> =\n            try Ok (Json.parseNativeAs<'t> input)\n            with | ex -> Error ex.Message\n\n        /// Tries to convert parsed JSON object as the given type parameter argument, this method is used when you want to apply transformations to the JSON object before parsing\n        static member inline convertFromJsonAs<'t> (input: Json) : 't =\n            let typeInfo = TypeInfo.createFrom<'t> ()\n            Convert.fromJson<'t> input typeInfo\n\n        /// Tries to convert parsed JSON object as the given type parameter argument, this method is used when you want to apply transformations to the JSON object before parsing\n        static member inline tryConvertFromJsonAs<'t> (input: Json) : Result<'t, string> =\n            try Ok (Json.convertFromJsonAs<'t> input)\n            with | ex -> Error ex.Message\n","import { BigInteger$$$op_Inequality$$56F059C0 as BigInteger$0024$0024$0024op_Inequality$0024$002456F059C0, BigInteger$$$op_Equality$$56F059C0 as BigInteger$0024$0024$0024op_Equality$0024$002456F059C0, BigInteger$$$op_GreaterThanOrEqual$$56F059C0 as BigInteger$0024$0024$0024op_GreaterThanOrEqual$0024$002456F059C0, BigInteger$$$op_GreaterThan$$56F059C0 as BigInteger$0024$0024$0024op_GreaterThan$0024$002456F059C0, BigInteger$$$op_LessThanOrEqual$$56F059C0 as BigInteger$0024$0024$0024op_LessThanOrEqual$0024$002456F059C0, BigInteger$$$op_LessThan$$56F059C0 as BigInteger$0024$0024$0024op_LessThan$0024$002456F059C0, BigInteger$$$op_ExclusiveOr$$56F059C0 as BigInteger$0024$0024$0024op_ExclusiveOr$0024$002456F059C0, BigInteger$$$op_BitwiseOr$$56F059C0 as BigInteger$0024$0024$0024op_BitwiseOr$0024$002456F059C0, BigInteger$$$op_BitwiseAnd$$56F059C0 as BigInteger$0024$0024$0024op_BitwiseAnd$0024$002456F059C0, BigInteger$$$op_LeftShift$$62E082A2 as BigInteger$0024$0024$0024op_LeftShift$0024$002462E082A2, BigInteger$$$op_RightShift$$62E082A2 as BigInteger$0024$0024$0024op_RightShift$0024$002462E082A2, BigInteger$$$op_UnaryPlus$$Z665282C2 as BigInteger$0024$0024$0024op_UnaryPlus$0024$0024Z665282C2, BigInteger$$$op_UnaryNegation$$Z665282C2 as BigInteger$0024$0024$0024op_UnaryNegation$0024$0024Z665282C2, BigInteger$$$op_Modulus$$56F059C0 as BigInteger$0024$0024$0024op_Modulus$0024$002456F059C0, BigInteger$$$op_Division$$56F059C0 as BigInteger$0024$0024$0024op_Division$0024$002456F059C0, BigInteger$$$op_Multiply$$56F059C0 as BigInteger$0024$0024$0024op_Multiply$0024$002456F059C0, BigInteger$$$op_Subtraction$$56F059C0 as BigInteger$0024$0024$0024op_Subtraction$0024$002456F059C0, BigInteger$$$op_Addition$$56F059C0 as BigInteger$0024$0024$0024op_Addition$0024$002456F059C0, BigInteger$$get_IsOne as BigInteger$0024$0024get_IsOne, BigInteger$$get_IsZero as BigInteger$0024$0024get_IsZero, BigInteger$$get_Sign as BigInteger$0024$0024get_Sign, BigInteger$$get_ToDecimal as BigInteger$0024$0024get_ToDecimal, BigInteger$$get_ToDouble as BigInteger$0024$0024get_ToDouble, BigInteger$$get_ToSingle as BigInteger$0024$0024get_ToSingle, BigInteger$$get_ToUInt64 as BigInteger$0024$0024get_ToUInt64, BigInteger$$get_ToInt64 as BigInteger$0024$0024get_ToInt64, BigInteger$$get_ToUInt32 as BigInteger$0024$0024get_ToUInt32, BigInteger$$get_ToInt32 as BigInteger$0024$0024get_ToInt32, BigInteger$$get_ToUInt16 as BigInteger$0024$0024get_ToUInt16, BigInteger$$get_ToInt16 as BigInteger$0024$0024get_ToInt16, BigInteger$$get_ToByte as BigInteger$0024$0024get_ToByte, BigInteger$$get_ToSByte as BigInteger$0024$0024get_ToSByte, BigInteger$$$$002Ector$$Z524259A4 as BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259A4, BigInteger$$$$002Ector$$Z524259C1 as BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259C1, BigInteger$$$get_Two as BigInteger$0024$0024$0024get_Two, BigInteger$$$get_One as BigInteger$0024$0024$0024get_One, BigInteger$$$Abs$$Z665282C2 as BigInteger$0024$0024$0024Abs$0024$0024Z665282C2, BigInteger$$$Pow$$62E082A2 as BigInteger$0024$0024$0024Pow$0024$002462E082A2, BigInteger$$$GreatestCommonDivisor$$56F059C0 as BigInteger$0024$0024$0024GreatestCommonDivisor$0024$002456F059C0, BigInteger$$$DivRem$$56F059C0 as BigInteger$0024$0024$0024DivRem$0024$002456F059C0, BigInteger$$$Parse$$Z721C83C5 as BigInteger$0024$0024$0024Parse$0024$0024Z721C83C5, BigInteger$$$get_Zero as BigInteger$0024$0024$0024get_Zero, BigInteger } from \"./BigInt/z\";\nimport { fromInteger } from \"./Long.js\";\nimport { min, comparePrimitives, equals as equals$$1, structuralHash } from \"./Util.js\";\nimport { delay, unfold, rangeNumber } from \"./Seq.js\";\nimport { fold, head, skipWhile, find, ofSeq } from \"./List.js\";\nimport { List } from \"./Types.js\";\nimport { fill, reverse, ofList } from \"./Array.js\";\nexport function isBigInt(x) {\n  return x instanceof BigInteger;\n}\nexport function tryParse(str) {\n  try {\n    const res = BigInteger$0024$0024$0024Parse$0024$0024Z721C83C5(str);\n    return [true, res];\n  } catch (matchValue) {\n    return [false, BigInteger$0024$0024$0024get_Zero()];\n  }\n}\nexport function parse(arg00) {\n  return BigInteger$0024$0024$0024Parse$0024$0024Z721C83C5(arg00);\n}\nexport function divRem(arg00$$1, arg01) {\n  return BigInteger$0024$0024$0024DivRem$0024$002456F059C0(arg00$$1, arg01);\n}\nexport function greatestCommonDivisor(arg00$$2, arg01$$1) {\n  return BigInteger$0024$0024$0024GreatestCommonDivisor$0024$002456F059C0(arg00$$2, arg01$$1);\n}\nexport function pow(arg00$$3, arg01$$2) {\n  return BigInteger$0024$0024$0024Pow$0024$002462E082A2(arg00$$3, arg01$$2);\n}\nexport function abs(arg00$$4) {\n  return BigInteger$0024$0024$0024Abs$0024$0024Z665282C2(arg00$$4);\n}\nexport const zero = BigInteger$0024$0024$0024get_Zero();\nexport const one = BigInteger$0024$0024$0024get_One();\nexport const two = BigInteger$0024$0024$0024get_Two();\nexport function fromString(s) {\n  return BigInteger$0024$0024$0024Parse$0024$0024Z721C83C5(s);\n}\nexport function fromZero() {\n  return BigInteger$0024$0024$0024get_Zero();\n}\nexport function fromOne() {\n  return BigInteger$0024$0024$0024get_One();\n}\nexport function fromInt64(i) {\n  return BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259C1(i);\n}\nexport function fromInt32(i$$1) {\n  var value;\n\n  if (i$$1 > 2147483647) {\n    return BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259C1((value = i$$1, (fromInteger(value, false, 6))));\n  } else {\n    return BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259A4(i$$1);\n  }\n}\nexport function toSByte(x$$1) {\n  return BigInteger$0024$0024get_ToSByte(x$$1);\n}\nexport function toByte(x$$2) {\n  return BigInteger$0024$0024get_ToByte(x$$2);\n}\nexport function toInt16(x$$3) {\n  return BigInteger$0024$0024get_ToInt16(x$$3);\n}\nexport function toUInt16(x$$4) {\n  return BigInteger$0024$0024get_ToUInt16(x$$4);\n}\nexport function toInt32(x$$5) {\n  return BigInteger$0024$0024get_ToInt32(x$$5);\n}\nexport function toUInt32(x$$6) {\n  return BigInteger$0024$0024get_ToUInt32(x$$6);\n}\nexport function toInt64(x$$7) {\n  return BigInteger$0024$0024get_ToInt64(x$$7);\n}\nexport function toUInt64(x$$8) {\n  return BigInteger$0024$0024get_ToUInt64(x$$8);\n}\nexport function toSingle(x$$9) {\n  return BigInteger$0024$0024get_ToSingle(x$$9);\n}\nexport function toDouble(x$$10) {\n  return BigInteger$0024$0024get_ToDouble(x$$10);\n}\nexport function toDecimal(x$$11) {\n  return BigInteger$0024$0024get_ToDecimal(x$$11);\n}\nexport function sign(x$$12) {\n  return BigInteger$0024$0024get_Sign(x$$12);\n}\nexport function isZero(x$$13) {\n  return BigInteger$0024$0024get_IsZero(x$$13);\n}\nexport function isOne(x$$14) {\n  return BigInteger$0024$0024get_IsOne(x$$14);\n}\nexport function hash(x$$15) {\n  return structuralHash(x$$15);\n}\nexport function compare(x$$16, y) {\n  return x$$16.CompareTo(y);\n}\nexport function equals(x$$17, y$$1) {\n  return equals$$1(x$$17, y$$1);\n}\nexport function toString(x$$18) {\n  return String(x$$18);\n}\nexport const get_Zero = BigInteger$0024$0024$0024get_Zero();\nexport const get_One = BigInteger$0024$0024$0024get_One();\nexport function op_Addition(arg00$$5, arg01$$3) {\n  return BigInteger$0024$0024$0024op_Addition$0024$002456F059C0(arg00$$5, arg01$$3);\n}\nexport function op_Subtraction(arg00$$6, arg01$$4) {\n  return BigInteger$0024$0024$0024op_Subtraction$0024$002456F059C0(arg00$$6, arg01$$4);\n}\nexport function op_Multiply(arg00$$7, arg01$$5) {\n  return BigInteger$0024$0024$0024op_Multiply$0024$002456F059C0(arg00$$7, arg01$$5);\n}\nexport function op_Division(arg00$$8, arg01$$6) {\n  return BigInteger$0024$0024$0024op_Division$0024$002456F059C0(arg00$$8, arg01$$6);\n}\nexport function op_Modulus(arg00$$9, arg01$$7) {\n  return BigInteger$0024$0024$0024op_Modulus$0024$002456F059C0(arg00$$9, arg01$$7);\n}\nexport function op_UnaryNegation(arg00$$10) {\n  return BigInteger$0024$0024$0024op_UnaryNegation$0024$0024Z665282C2(arg00$$10);\n}\nexport function op_UnaryPlus(arg00$$11) {\n  return BigInteger$0024$0024$0024op_UnaryPlus$0024$0024Z665282C2(arg00$$11);\n}\nexport function op_RightShift(arg00$$12, arg01$$8) {\n  return BigInteger$0024$0024$0024op_RightShift$0024$002462E082A2(arg00$$12, arg01$$8);\n}\nexport function op_LeftShift(arg00$$13, arg01$$9) {\n  return BigInteger$0024$0024$0024op_LeftShift$0024$002462E082A2(arg00$$13, arg01$$9);\n}\nexport function op_BitwiseAnd(arg00$$14, arg01$$10) {\n  return BigInteger$0024$0024$0024op_BitwiseAnd$0024$002456F059C0(arg00$$14, arg01$$10);\n}\nexport function op_BitwiseOr(arg00$$15, arg01$$11) {\n  return BigInteger$0024$0024$0024op_BitwiseOr$0024$002456F059C0(arg00$$15, arg01$$11);\n}\nexport function op_ExclusiveOr(arg00$$16, arg01$$12) {\n  return BigInteger$0024$0024$0024op_ExclusiveOr$0024$002456F059C0(arg00$$16, arg01$$12);\n}\nexport function op_LessThan(arg00$$17, arg01$$13) {\n  return BigInteger$0024$0024$0024op_LessThan$0024$002456F059C0(arg00$$17, arg01$$13);\n}\nexport function op_LessThanOrEqual(arg00$$18, arg01$$14) {\n  return BigInteger$0024$0024$0024op_LessThanOrEqual$0024$002456F059C0(arg00$$18, arg01$$14);\n}\nexport function op_GreaterThan(arg00$$19, arg01$$15) {\n  return BigInteger$0024$0024$0024op_GreaterThan$0024$002456F059C0(arg00$$19, arg01$$15);\n}\nexport function op_GreaterThanOrEqual(arg00$$20, arg01$$16) {\n  return BigInteger$0024$0024$0024op_GreaterThanOrEqual$0024$002456F059C0(arg00$$20, arg01$$16);\n}\nexport function op_Equality(arg00$$21, arg01$$17) {\n  return BigInteger$0024$0024$0024op_Equality$0024$002456F059C0(arg00$$21, arg01$$17);\n}\nexport function op_Inequality(arg00$$22, arg01$$18) {\n  return BigInteger$0024$0024$0024op_Inequality$0024$002456F059C0(arg00$$22, arg01$$18);\n}\n\nfunction flipTwosComplement(currByte, lowBitFound) {\n  if (lowBitFound) {\n    return [(currByte ^ 255) & 255, true];\n  } else if (currByte === 0) {\n    return [0, false];\n  } else {\n    let firstBitIndex;\n    const list = ofSeq(rangeNumber(0, 1, 7));\n    firstBitIndex = find(function predicate(i$$2) {\n      return (currByte & 1 << i$$2) > 0;\n    }, list);\n    return [(currByte ^ 254 << firstBitIndex) & 255, true];\n  }\n}\n\nexport function toByteArray(value$$1) {\n  if (equals$$1(value$$1, zero)) {\n    return new Uint8Array([0]);\n  } else {\n    const isPositive = value$$1.CompareTo(zero) > 0;\n    const value$$2 = isPositive ? value$$1 : BigInteger$0024$0024$0024op_Multiply$0024$002456F059C0(BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259A4(-1), value$$1);\n    let mask32;\n    let i$$3;\n    i$$3 = fromInteger(4294967295, false, 6);\n    mask32 = fromInt64(i$$3);\n\n    const loop = function loop($accumBytes$$74, $consumeValue$$75, $lowBitFound$$1$$76) {\n      var value$$9, value$$10, value$$11;\n\n      loop: while (true) {\n        const accumBytes = $accumBytes$$74,\n              consumeValue = $consumeValue$$75,\n              lowBitFound$$1 = $lowBitFound$$1$$76;\n\n        if (consumeValue.CompareTo(zero) <= 0) {\n          let accumBytes$$1;\n\n          if (isPositive) {\n            accumBytes$$1 = skipWhile(function predicate$$1(b) {\n              return b === 0;\n            }, accumBytes);\n          } else {\n            accumBytes$$1 = skipWhile(function predicate$$2(b$$1) {\n              return b$$1 === 255;\n            }, accumBytes);\n          }\n\n          const isHighBitOne = (head(accumBytes$$1) & 128) !== 0;\n          const accumBytes$$2 = (isPositive ? isHighBitOne : false) ? new List(0, accumBytes$$1) : (!isPositive ? !isHighBitOne : false) ? new List(255, accumBytes$$1) : accumBytes$$1;\n          let array;\n          array = ofList(accumBytes$$2, Uint8Array);\n          return reverse(array, Uint8Array);\n        } else {\n          let currValue;\n          const x$$19 = BigInteger$0024$0024$0024op_BitwiseAnd$0024$002456F059C0(consumeValue, mask32);\n          currValue = toUInt32(x$$19);\n\n          if (isPositive) {\n            let b0;\n            b0 = currValue & 0xFF;\n            let b1;\n            const value$$5 = currValue >>> 8;\n            b1 = value$$5 & 0xFF;\n            let b2;\n            const value$$6 = currValue >>> 16;\n            b2 = value$$6 & 0xFF;\n            let b3;\n            const value$$7 = currValue >>> 24;\n            b3 = value$$7 & 0xFF;\n            $accumBytes$$74 = new List(b3, new List(b2, new List(b1, new List(b0, accumBytes))));\n            $consumeValue$$75 = BigInteger$0024$0024$0024op_RightShift$0024$002462E082A2(consumeValue, 32);\n            $lowBitFound$$1$$76 = false;\n            continue loop;\n          } else {\n            const patternInput = flipTwosComplement((currValue & 0xFF), lowBitFound$$1);\n            const patternInput$$1 = flipTwosComplement((value$$9 = currValue >>> 8, (value$$9 & 0xFF)), patternInput[1]);\n            const patternInput$$2 = flipTwosComplement((value$$10 = currValue >>> 16, (value$$10 & 0xFF)), patternInput$$1[1]);\n            const patternInput$$3 = flipTwosComplement((value$$11 = currValue >>> 24, (value$$11 & 0xFF)), patternInput$$2[1]);\n            $accumBytes$$74 = new List(patternInput$$3[0], new List(patternInput$$2[0], new List(patternInput$$1[0], new List(patternInput[0], accumBytes))));\n            $consumeValue$$75 = BigInteger$0024$0024$0024op_RightShift$0024$002462E082A2(consumeValue, 32);\n            $lowBitFound$$1$$76 = patternInput$$3[1];\n            continue loop;\n          }\n        }\n\n        break;\n      }\n    };\n\n    return loop(new List(), value$$2, false);\n  }\n}\nexport function fromByteArray(bytes) {\n  if (bytes == null) {\n    throw new Error(\"bytes\");\n  } else {\n    void null;\n  }\n\n  if (bytes.length === 0) {\n    return zero;\n  } else {\n    const isPositive$$1 = (bytes[bytes.length - 1] & 128) === 0;\n    const buffer = fill(new Uint8Array(4), 0, 4, 0);\n\n    const loop$$1 = function loop$$1($accumUInt32$$80, $currIndex$$81, $bytesRemaining$$82, $lowBitFound$$6$$83) {\n      loop$$1: while (true) {\n        const accumUInt32 = $accumUInt32$$80,\n              currIndex = $currIndex$$81,\n              bytesRemaining = $bytesRemaining$$82,\n              lowBitFound$$6 = $lowBitFound$$6$$83;\n\n        if (bytesRemaining === 0) {\n          let value$$14;\n          value$$14 = fold(function folder(acc, value$$12) {\n            var i$$4;\n            return BigInteger$0024$0024$0024op_Addition$0024$002456F059C0(BigInteger$0024$0024$0024op_LeftShift$0024$002462E082A2(acc, 32), (i$$4 = (fromInteger(value$$12, false, 6)), (fromInt64(i$$4))));\n          }, zero, accumUInt32);\n\n          if (isPositive$$1) {\n            return value$$14;\n          } else {\n            return BigInteger$0024$0024$0024op_Multiply$0024$002456F059C0(BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259A4(-1), value$$14);\n          }\n        } else {\n          const bytesToProcess = min(comparePrimitives, bytesRemaining, 4) | 0;\n\n          for (let i$$5 = 0; i$$5 <= bytesToProcess - 1; i$$5++) {\n            buffer[i$$5] = bytes[currIndex + i$$5];\n          }\n\n          if (isPositive$$1) {\n            fill(buffer, bytesToProcess, 4 - bytesToProcess, 0);\n            const value$$15 = (((buffer[0] | buffer[1] << 8 >>> 0) >>> 0 | buffer[2] << 16 >>> 0) >>> 0 | buffer[3] << 24 >>> 0) >>> 0;\n            $accumUInt32$$80 = new List(value$$15, accumUInt32);\n            $currIndex$$81 = currIndex + bytesToProcess;\n            $bytesRemaining$$82 = bytesRemaining - bytesToProcess;\n            $lowBitFound$$6$$83 = false;\n            continue loop$$1;\n          } else {\n            fill(buffer, bytesToProcess, 4 - bytesToProcess, 255);\n            const patternInput$$4 = flipTwosComplement(buffer[0], lowBitFound$$6);\n            const patternInput$$5 = flipTwosComplement(buffer[1], patternInput$$4[1]);\n            const patternInput$$6 = flipTwosComplement(buffer[2], patternInput$$5[1]);\n            const patternInput$$7 = flipTwosComplement(buffer[3], patternInput$$6[1]);\n            const value$$16 = (((patternInput$$4[0] | patternInput$$5[0] << 8 >>> 0) >>> 0 | patternInput$$6[0] << 16 >>> 0) >>> 0 | patternInput$$7[0] << 24 >>> 0) >>> 0;\n            $accumUInt32$$80 = new List(value$$16, accumUInt32);\n            $currIndex$$81 = currIndex + bytesToProcess;\n            $bytesRemaining$$82 = bytesRemaining - bytesToProcess;\n            $lowBitFound$$6$$83 = patternInput$$7[1];\n            continue loop$$1;\n          }\n        }\n\n        break;\n      }\n    };\n\n    return loop$$1(new List(), 0, bytes.length, false);\n  }\n}\nexport function makeRangeStepFunction(step, last) {\n  const stepComparedWithZero = step.CompareTo(zero) | 0;\n\n  if (stepComparedWithZero === 0) {\n    throw new Error(\"The step of a range cannot be zero\");\n  } else {\n    void null;\n  }\n\n  const stepGreaterThanZero = stepComparedWithZero > 0;\n  return function (x$$20) {\n    const comparedWithLast = x$$20.CompareTo(last) | 0;\n    return ((stepGreaterThanZero ? comparedWithLast <= 0 : false) ? true : !stepGreaterThanZero ? comparedWithLast >= 0 : false) ? [x$$20, BigInteger$0024$0024$0024op_Addition$0024$002456F059C0(x$$20, step)] : undefined;\n  };\n}\nexport function range(first, step$$1, last$$1) {\n  const stepFn = makeRangeStepFunction(step$$1, last$$1);\n  return delay(function () {\n    return unfold(stepFn, first);\n  });\n}","namespace Fable.SimpleJson\n\nopen System\nopen FSharp.Reflection\nopen Fable.Core\nopen System.Reflection\nopen System.Collections.Generic\n\n[<AutoOpen>]\nmodule Converter =\n    let (|PrimitiveType|_|) (primType: Type) =\n        match primType.FullName with\n        | \"System.String\" -> Some TypeInfo.String\n        | \"System.Char\" -> Some TypeInfo.Char\n        | \"System.Int16\" -> Some TypeInfo.Short\n        | \"System.Int32\" -> Some TypeInfo.Int32\n        | \"Microsoft.FSharp.Core.int64`1\"\n        | \"System.Int64\" -> Some TypeInfo.Long\n        | \"System.UInt16\" -> Some TypeInfo.UInt16\n        | \"System.UInt32\" -> Some TypeInfo.UInt32\n        | \"System.UInt64\" -> Some TypeInfo.UInt64\n        | \"System.DateTime\" -> Some TypeInfo.DateTime\n        | \"System.DateOnly\" -> Some TypeInfo.DateOnly\n        | \"System.TimeOnly\" -> Some TypeInfo.TimeOnly\n        | \"System.TimeSpan\" -> Some TypeInfo.TimeSpan\n        | \"System.DateTimeOffset\" -> Some TypeInfo.DateTimeOffset\n        | \"System.Boolean\" -> Some  TypeInfo.Bool\n        | \"System.Single\" -> Some TypeInfo.Float32\n        | \"System.Double\" -> Some TypeInfo.Float\n        | \"Microsoft.FSharp.Core.decimal`1\"\n        | \"System.Decimal\" -> Some TypeInfo.Decimal\n        | \"System.Numerics.BigInteger\" -> Some TypeInfo.BigInt\n        | \"Microsoft.FSharp.Core.Unit\" -> Some TypeInfo.Unit\n        | \"System.Guid\" -> Some TypeInfo.Guid\n        | \"System.Byte\" -> Some TypeInfo.Byte\n        | \"System.SByte\" -> Some TypeInfo.SByte\n        | \"System.Object\" -> Some TypeInfo.Object\n        | \"System.Uri\" -> Some TypeInfo.Uri\n        | _ -> None\n\n    let (|RecordType|_|) (t: Type) =\n        if FSharpType.IsRecord t\n        then\n            FSharpType.GetRecordFields t\n            |> Array.map (fun field -> field, field.Name, field.PropertyType)\n            |> Some\n        else None\n\n    let (|SetType|_|) (t: Type) =\n        if t.FullName.StartsWith \"Microsoft.FSharp.Collections.FSharpSet`1\"\n        then t.GetGenericArguments().[0] |> Some\n        else None\n\n    let (|Nullable|_|) (t: Type) =\n        if t.FullName.StartsWith \"System.Nullable`1\"\n        then t.GetGenericArguments().[0] |> Some\n        else None\n\n    let (|UnionType|_|) (t: Type) =\n        if FSharpType.IsUnion t\n        then\n            FSharpType.GetUnionCases t\n            |> Array.map (fun info ->\n                let caseName = info.Name\n                let caseTypes = info.GetFields() |> Array.map (fun prop -> prop.PropertyType)\n                caseName, info, caseTypes)\n            |> Some\n        else None\n\n    let (|MapType|_|) (t: Type) =\n        if (t.FullName.StartsWith \"Microsoft.FSharp.Collections.FSharpMap`2\")\n        then\n            let genArgs = t.GetGenericArguments()\n            Some (genArgs.[0], genArgs.[1])\n        else None\n\n    let (|ListType|_|) (t: Type) =\n        if (t.FullName.StartsWith \"Microsoft.FSharp.Collections.FSharpList`1\")\n        then t.GetGenericArguments().[0] |> Some\n        else None\n\n    let rec flattenFuncTypes (typeDef: Type) =\n        [| if FSharpType.IsFunction typeDef\n           then let (domain, range) = FSharpType.GetFunctionElements typeDef\n                yield! flattenFuncTypes domain\n                yield! flattenFuncTypes range\n           else yield typeDef |]\n\n    let (|FuncType|_|) (t: Type) =\n        if FSharpType.IsFunction t\n        then flattenFuncTypes t |> Some\n        else None\n\n    let (|ArrayType|_|) (t:Type) =\n        if t.IsArray\n        then t.GetElementType() |> Some\n        else None\n\n    let (|OptionType|_|) (t:Type) =\n        if (t.FullName.StartsWith \"Microsoft.FSharp.Core.FSharpOption`1\")\n        then t.GetGenericArguments().[0] |> Some\n        else None\n\n    let (|TupleType|_|) (t: Type) =\n        if FSharpType.IsTuple t\n        then FSharpType.GetTupleElements(t) |> Some\n        else None\n\n    let (|SeqType|_|) (t: Type) =\n        if t.FullName.StartsWith \"System.Collections.Generic.IEnumerable`1\"\n        then  t.GetGenericArguments().[0] |> Some\n        else None\n\n    let (|DictionaryType|_|) (t: Type) =\n        if t.FullName.StartsWith \"System.Collections.Generic.Dictionary\"\n        then\n          let genArgs = t.GetGenericArguments()\n          Some (genArgs.[0], genArgs.[1])\n        else\n          None\n\n    let (|ResizeArrayType|_|) (t: Type) =\n        if t.FullName.StartsWith \"System.Collections.Generic.List\"\n        then t.GetGenericArguments().[0] |> Some\n        else None\n\n    let (|HashSetType|_|) (t: Type) =\n        if t.FullName.StartsWith \"System.Collections.Generic.HashSet\"\n        then t.GetGenericArguments().[0] |> Some\n        else None\n\n    let (|AsyncType|_|) (t:Type) =\n        if t.FullName.StartsWith \"Microsoft.FSharp.Control.FSharpAsync`1\"\n        then  t.GetGenericArguments().[0] |> Some\n        else None\n\n    let (|PromiseType|_|) (t:Type) =\n        if t.FullName.StartsWith \"Fable.Core.JS.Promise`1\"\n        then t.GetGenericArguments().[0] |> Some\n        else None\n\n    let private lazyToDelayed (l:Lazy<_>) = fun () -> l.Value\n\n    let (|EnumType|_|) (t: Type) =\n        if t.IsEnum\n        then Enum.GetUnderlyingType(t) |> Some\n        else None\n\n    let rec private _createTypeInfo (resolvedType: Type) : Fable.SimpleJson.TypeInfo =\n        match resolvedType with\n        | PrimitiveType typeInfo -> typeInfo\n        | FuncType (types) -> TypeInfo.Func <| lazyToDelayed (lazy (Array.map createTypeInfo types))\n        | RecordType fields ->\n            let l = lazy (\n                let fields =\n                    [| for (field, fieldName, fieldType) in fields ->\n                        { PropertyInfo = field\n                          FieldName = fieldName;\n                          FieldType = createTypeInfo fieldType } |]\n                fields, resolvedType)\n            TypeInfo.Record (lazyToDelayed l)\n\n        | UnionType cases ->\n            let l = lazy (\n                [| for (caseName, caseInfo, caseTypes) in cases ->\n                    { CaseName = caseName;\n                      Info = caseInfo;\n                      CaseTypes = Array.map createTypeInfo caseTypes } |], resolvedType)\n            TypeInfo.Union (lazyToDelayed l)\n\n        | EnumType elemType -> TypeInfo.Enum (lazyToDelayed <| lazy (createTypeInfo elemType, resolvedType))\n        | ListType elemType -> TypeInfo.List (lazyToDelayed <| lazy (createTypeInfo elemType))\n        | ResizeArrayType elemType -> TypeInfo.ResizeArray (lazyToDelayed <| lazy (createTypeInfo elemType))\n        | HashSetType elemType -> TypeInfo.HashSet (lazyToDelayed <| lazy (createTypeInfo elemType))\n        | ArrayType elemType -> TypeInfo.Array (lazyToDelayed <| lazy (createTypeInfo elemType))\n        // Checking for tuples has to happen after checking for arrays\n        | TupleType types -> TypeInfo.Tuple (lazyToDelayed <| lazy (Array.map createTypeInfo types))\n        | OptionType elemType -> TypeInfo.Option (lazyToDelayed <| lazy (createTypeInfo elemType))\n        | Nullable elemType -> TypeInfo.Option (lazyToDelayed <| lazy (createTypeInfo elemType))\n        | SetType elemType -> TypeInfo.Set (lazyToDelayed <| lazy (createTypeInfo elemType))\n        | MapType (keyType, valueType) -> TypeInfo.Map (lazyToDelayed <| lazy (createTypeInfo keyType, createTypeInfo valueType))\n        | DictionaryType (keyType, valueType) -> TypeInfo.Dictionary (lazyToDelayed <| lazy (createTypeInfo keyType, createTypeInfo valueType, valueType))\n        | SeqType elemType -> TypeInfo.Seq (lazyToDelayed <| lazy (createTypeInfo elemType))\n        | AsyncType elemType -> TypeInfo.Async (lazyToDelayed <| lazy (createTypeInfo elemType))\n        | PromiseType elemType -> TypeInfo.Promise (lazyToDelayed <| lazy (createTypeInfo elemType))\n        | _ -> TypeInfo.Any (lazyToDelayed <| lazy (resolvedType))\n\n    and private typeInfoCache = Dictionary<Type,Fable.SimpleJson.TypeInfo>()\n\n    and createTypeInfo (resolvedType: Type) : Fable.SimpleJson.TypeInfo =\n        match typeInfoCache.TryGetValue resolvedType with\n        | true, ti -> ti\n        | false, _ ->\n            let ti = _createTypeInfo resolvedType\n            // see https://github.com/fable-compiler/Fable/issues/1871\n            // Type equality doesn't work for anonymous records - all anon records are considered equal.\n            // For anonymous records, the name is the empty string.\n            let notAnonymousRecord =\n                not (String.IsNullOrEmpty resolvedType.FullName)\n                && not (resolvedType.FullName.EndsWith(\"`1[]\"))\n                && not (resolvedType.FullName.EndsWith(\"`2[]\"))\n\n            if notAnonymousRecord then\n                typeInfoCache.[resolvedType] <- ti\n                ti\n            else\n                ti\n\n    type Fable.SimpleJson.TypeInfo with\n        static member inline createFrom<'t> () : Fable.SimpleJson.TypeInfo =\n            createTypeInfo typeof<'t>\n\n    /// returns whether a type is primitive\n    let isPrimitive = function\n        | TypeInfo.Unit\n        | TypeInfo.String\n        | TypeInfo.UInt16\n        | TypeInfo.UInt32\n        | TypeInfo.UInt64\n        | TypeInfo.Int32\n        | TypeInfo.Bool\n        | TypeInfo.Float32\n        | TypeInfo.Float\n        | TypeInfo.Decimal\n        | TypeInfo.Short\n        | TypeInfo.Long\n        | TypeInfo.Byte\n        | TypeInfo.DateTime\n        | TypeInfo.DateTimeOffset\n        | TypeInfo.DateOnly\n        | TypeInfo.TimeOnly\n        | TypeInfo.BigInt\n        | TypeInfo.Guid\n        | TypeInfo.Option _ -> true\n        | otherwise -> false\n\n    /// returns whether the discrimiated union type is like a enum\n    let enumUnion = function\n        | TypeInfo.Union getCases ->\n            getCases()\n            |> fst\n            |> Array.forall (fun case -> Array.isEmpty case.CaseTypes)\n        | otherwise -> false\n","export default function isBrowser() {\n    return typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n}",null,null,"namespace Fable.SimpleHttp\n\nopen System\nopen Browser\nopen Browser.Types\nopen Fable.Core\n\n#if !FABLE_COMPILER\nopen System.Net.Http\n#endif\n\nmodule Blob =\n    /// Creates a Blob from the given input string\n    [<Emit(\"new Blob([$0], { 'type':'text/plain' })\")>]\n    let fromText (value: string) : Blob = jsNative\n\n\nmodule File =\n    /// Creates a File from the given input string and file name\n    [<Emit(\"new File([$0], $1, { 'type':'text/plain' })\")>]\n    let fromText (value: string) (fileName: string) : File = jsNative\n\n\n/// Utility functions to work with blob and file APIs.\nmodule FileReader =\n    /// Asynchronously reads the blob data content as string\n    let readBlobAsText (blob: Blob) : Async<string> =\n        Async.FromContinuations <| fun (resolve, _, _) ->\n            let reader = FileReader.Create()\n            reader.onload <- fun _ ->\n                if reader.readyState = FileReaderState.DONE\n                then resolve (unbox reader.result)\n\n            reader.readAsText(blob)\n\n    /// Asynchronously reads the blob data content as string\n    let readFileAsText (file: File) : Async<string> =\n        Async.FromContinuations <| fun (resolve, _, _) ->\n            let reader = FileReader.Create()\n            reader.onload <- fun _ ->\n                if reader.readyState = FileReaderState.DONE\n                then resolve (unbox reader.result)\n\n            reader.readAsText(file)\n\nmodule FormData =\n\n    /// Creates a new FormData object\n    [<Emit(\"new FormData()\")>]\n    let create() : FormData = jsNative\n\n    /// Appends a key-value pair to the form data\n    let append (key:string) (value:string) (form : FormData) : FormData =\n        form.append(key, value)\n        form\n\n    /// Appends a file to the form data\n    let appendFile (key: string) (file: File) (form: FormData) : FormData =\n        form.append (key, file)\n        form\n\n    /// Appends a named file to the form data\n    let appendNamedFile (key: string) (fileName: string) (file: File) (form: FormData) : FormData =\n        form.append (key, file, fileName)\n        form\n\n    /// Appends a blog to the form data\n    let appendBlob (key: string) (blob: Blob) (form: FormData) : FormData =\n        form.append (key, blob)\n        form\n\n    /// Appends a blog to the form data\n    let appendNamedBlob (key: string) (fileName: string) (blob: Blob) (form: FormData) : FormData =\n        form.append (key, blob, fileName)\n        form\n\nmodule Headers =\n    let contentType value = Header(\"Content-Type\", value)\n    let accept value = Header(\"Accept\", value)\n    let acceptCharset value = Header(\"Accept-Charset\", value)\n    let acceptEncoding value = Header(\"Accept-Encoding\", value)\n    let acceptLanguage value = Header(\"Accept-Language\", value)\n    let acceptDateTime value = Header(\"Accept-Datetime\", value)\n    let authorization value = Header(\"Authorization\", value)\n    let cacheControl value = Header(\"Cache-Control\", value)\n    let connection value = Header(\"Connection\", value)\n    let cookie value = Header(\"Cookie\", value)\n    let contentMD5 value = Header(\"Content-MD5\", value)\n    let date value = Header(\"Date\", value)\n    let expect value = Header(\"Expect\", value)\n    let ifMatch value = Header(\"If-Match\", value)\n    let ifModifiedSince value = Header(\"If-Modified-Since\", value)\n    let ifNoneMatch value = Header(\"If-None-Match\", value)\n    let ifRange value = Header(\"If-Range\", value)\n    let IfUnmodifiedSince value = Header(\"If-Unmodified-Since\", value)\n    let maxForwards value = Header(\"Max-Forwards\", value)\n    let origin value = Header (\"Origin\", value)\n    let pragma value = Header(\"Pragma\", value)\n    let proxyAuthorization value = Header(\"Proxy-Authorization\", value)\n    let range value = Header(\"Range\", value)\n    let referer value = Header(\"Referer\", value)\n    let userAgent value = Header(\"User-Agent\", value)\n    let create key value = Header(key, value)\n\nmodule Http =\n\n    let private defaultRequest =\n        { url = \"\";\n          method = HttpMethod.GET\n          headers = []\n          withCredentials = false\n          overridenMimeType = None\n          overridenResponseType = None\n          timeout = None\n          content = BodyContent.Empty }\n\n    let private emptyResponse =\n        { statusCode = 0\n          responseText = \"\"\n          responseType = \"\"\n          responseUrl = \"\"\n          responseHeaders = Map.empty\n          content = ResponseContent.Text \"\" }\n\n    let private splitAt (delimiter: string) (input: string) : string [] =\n        if String.IsNullOrEmpty input then [| input |]\n        else input.Split([| delimiter |], StringSplitOptions.None)\n\n    let private serializeMethod = function\n        | HttpMethod.GET -> \"GET\"\n        | HttpMethod.POST -> \"POST\"\n        | HttpMethod.PATCH -> \"PATCH\"\n        | HttpMethod.PUT -> \"PUT\"\n        | HttpMethod.DELETE -> \"DELETE\"\n        | HttpMethod.OPTIONS -> \"OPTIONS\"\n        | HttpMethod.HEAD -> \"HEAD\"\n\n    /// Starts the configuration of the request with the specified url\n    let request (url: string) : HttpRequest =\n        { defaultRequest with url = url }\n\n    /// Sets the Http method of the request\n    let method httpVerb (req: HttpRequest) =\n        { req with method = httpVerb }\n\n    /// Appends a header to the request configuration\n    let header (singleHeader: Header) (req: HttpRequest) =\n        { req with headers = List.append req.headers [singleHeader] }\n\n    /// Appends a list of headers to the request configuration\n    let headers (values: Header list) (req: HttpRequest)  =\n        { req with headers = List.append req.headers values }\n\n    /// Enables cross-site credentials such as cookies\n    let withCredentials (enabled: bool) (req: HttpRequest) =\n        { req with withCredentials = enabled }\n\n    /// Enables Http request timeout\n    let withTimeout (timeoutInMilliseconds: int) (req: HttpRequest) =\n        { req with timeout = Some timeoutInMilliseconds}\n\n    /// Specifies a MIME type other than the one provided by the server to be used instead when interpreting the data being transferred in a request. This may be used, for example, to force a stream to be treated and parsed as \"text/xml\", even if the server does not report it as such.\n    let overrideMimeType (value: string) (req: HttpRequest) =\n        { req with overridenMimeType = Some value }\n\n    /// Change the expected response type from the server\n    let overrideResponseType (value: ResponseTypes) (req: HttpRequest) =\n        { req with overridenResponseType = Some value }\n\n    /// Sets the body content of the request\n    let content (bodyContent: BodyContent) (req: HttpRequest) : HttpRequest =\n        { req with content = bodyContent }\n\n    /// Sends the request to the server, this function does not throw\n    let send (req: HttpRequest) : Async<HttpResponse> =\n#if FABLE_COMPILER\n        Async.FromContinuations <| fun (resolve, reject, _) ->\n            let xhr = XMLHttpRequest.Create()\n            xhr.``open``(serializeMethod req.method, req.url)\n            xhr.onreadystatechange <- fun _ ->\n                if xhr.readyState = ReadyState.Done\n                then resolve {\n                    responseText =\n                        match xhr.responseType with\n                        | \"\" -> xhr.responseText\n                        | \"text\" -> xhr.responseText\n                        | _ -> \"\"\n\n                    statusCode = int xhr.status\n                    responseType = xhr.responseType\n                    content =\n                        match xhr.responseType with\n                        | (\"\" | \"text\") -> ResponseContent.Text xhr.responseText\n                        | \"arraybuffer\" -> ResponseContent.ArrayBuffer (unbox xhr.response)\n                        | \"blob\" -> ResponseContent.Blob (unbox xhr.response)\n                        | _ -> ResponseContent.Unknown xhr.response\n\n                    responseHeaders =\n                        xhr.getAllResponseHeaders()\n                        |> splitAt \"\\r\\n\"\n                        |> Array.choose (fun headerLine ->\n                            let parts = splitAt \":\" headerLine\n                            match List.ofArray parts with\n                            | key :: rest ->  Some (key.ToLower(), (String.concat \":\" rest).Trim())\n                            | otherwise -> None)\n                        |> Map.ofArray\n\n                    responseUrl = xhr.responseURL\n                }\n\n            for (Header(key, value)) in req.headers do\n                xhr.setRequestHeader(key, value)\n\n            xhr.withCredentials <- req.withCredentials\n\n            match req.overridenMimeType with\n            | Some mimeType -> xhr.overrideMimeType(mimeType)\n            | None -> ()\n\n            match req.overridenResponseType with\n            | Some ResponseTypes.Text -> xhr.responseType <- \"text\"\n            | Some ResponseTypes.Blob -> xhr.responseType <- \"blob\"\n            | Some ResponseTypes.ArrayBuffer -> xhr.responseType <- \"arraybuffer\"\n            | None -> ()\n\n            match req.timeout with\n            | Some timeout -> xhr.timeout <- timeout\n            | None -> ()\n\n            match req.content with \n            | BodyContent.Empty -> xhr.send()\n            | BodyContent.Text value -> xhr.send(value)\n            | BodyContent.Form formData -> xhr.send(formData)\n            | BodyContent.Binary blob -> xhr.send(blob)\n#else\n        async {\n            try\n                use requestMessage = new HttpRequestMessage()\n                requestMessage.RequestUri <- Uri(req.url)\n                requestMessage.Method <-\n                    match req.method with\n                    | HttpMethod.GET     -> HttpMethod.Get\n                    | HttpMethod.POST    -> HttpMethod.Post\n                    | HttpMethod.PUT     -> HttpMethod.Put\n                    | HttpMethod.PATCH   -> HttpMethod \"PATCH\"\n                    | HttpMethod.DELETE  -> HttpMethod.Delete\n                    | HttpMethod.HEAD    -> HttpMethod.Head\n                    | HttpMethod.OPTIONS -> HttpMethod.Options\n                req.headers\n                |> Seq.iter (fun (Header (key, value)) ->\n                    requestMessage.Headers.Add(key, value))\n                use content =\n                    match req.content with\n                    | BodyContent.Text text -> new StringContent(text)\n                    | BodyContent.Empty -> null\n                    | _ -> failwith \"Only BodyContent.Text is supported in the dotnet implementation\"\n                requestMessage.Content <- content\n\n                use client = new HttpClient()\n\n                match req.timeout with\n                | Some timeout -> client.Timeout <- TimeSpan.FromMilliseconds(timeout)\n                | None -> ()\n\n                let! response = client.SendAsync requestMessage |> Async.AwaitTask\n                let! responseBody = response.Content.ReadAsStringAsync() |> Async.AwaitTask\n\n                let headers =\n                    response.Headers\n                    |> Seq.choose (fun kv ->\n                        kv.Value\n                        |> Seq.tryLast\n                        |> Option.map (fun value -> kv.Key, value))\n                    |> Map.ofSeq\n\n                return\n                    { statusCode = int response.StatusCode\n                      responseText = responseBody\n                      responseType = \"text\"\n                      responseHeaders = headers\n                      responseUrl = req.url\n                      content = ResponseContent.Text responseBody }\n            with\n            // We're catching a lot here to mimic the behaviour of the JS\n            // implementation, which isn't able to expose the kind of error.\n            | :? ArgumentException ->\n                return emptyResponse // invalid uri\n            | :? HttpRequestException\n            | :? AggregateException as aggrEx when (aggrEx.InnerException :? HttpRequestException) ->\n                return emptyResponse // connection errors\n        }\n#endif\n\n    /// Safely sends a GET request and returns a tuple(status code * response text). This function does not throw.\n    let get url : Async<int * string> =\n        async {\n            let! response =\n                request url\n                |> method HttpMethod.GET\n                |> send\n            return response.statusCode, response.responseText\n        }\n\n    /// Safely sends a PUT request and returns a tuple(status code * response text). This function does not throw.\n    let put url (data: string) : Async<int * string> =\n        async {\n            let! response =\n                request url\n                |> method HttpMethod.PUT\n                |> content (BodyContent.Text data)\n                |> send\n            return response.statusCode, response.responseText\n        }\n\n    /// Safely sends a DELETE request and returns a tuple(status code * response text). This function does not throw.\n    let delete url : Async<int * string> =\n        async {\n            let! response =\n                request url\n                |> method HttpMethod.DELETE\n                |> send\n            return response.statusCode, response.responseText\n        }\n\n    /// Safely sends a PATCH request and returns a tuple(status code * response text). This function does not throw.\n    let patch url (data: string) : Async<int * string> =\n        async {\n            let! response =\n                request url\n                |> method HttpMethod.PATCH\n                |> content (BodyContent.Text data)\n                |> send\n            return response.statusCode, response.responseText\n        }\n\n    /// Safely sends a POST request and returns a tuple(status code * response text). This function does not throw.\n    let post url (data: string) : Async<int * string> =\n        async {\n            let! response =\n                request url\n                |> method HttpMethod.POST\n                |> content (BodyContent.Text data)\n                |> send\n            return response.statusCode, response.responseText\n        }\n","module Common\r\n\r\nopen Fable.Core\r\nopen Fable.Core.JsInterop\r\nopen Browser.Types\r\nopen Fable.React\r\nopen Imports\r\n\r\ntype DappTxResult<'msg> =\r\n    | Response of 'msg * TransactionResponse\r\n    | Confirmed of 'msg * ConfirmedTransactionResponse\r\n    | UserCancelled of 'msg\r\n    | UnknownError of 'msg * exn\r\n\r\n// --------------\r\n\r\ntype AsyncResult<'t> =\r\n    | Resolved of 't\r\n    | Unresolved\r\n\r\ntype StorageType =\r\n    | Unknown\r\n    | IPFS\r\n    | OnChain\r\n\r\ntype ImageFormat =\r\n    | Svg\r\n    | Jpg\r\n    | Gif\r\n    | Png\r\n    | WebP\r\n    | UnknownFormat\r\n\r\ntype VideoFormat = Mp4\r\n\r\ntype NFTDisplayRecord =\r\n    { display: string\r\n      format: string\r\n      storage: string\r\n      url: string\r\n      hasPreview: bool\r\n      hasW388: bool }\r\n\r\ntype NFTOwners =\r\n    { owners: string[] }\r\n\r\ntype NFT =\r\n    { token_id: string\r\n      token_uri: string\r\n      token_address: string\r\n      block_number: string\r\n      block_number_minted: string\r\n      name: string\r\n      symbol: string\r\n      metadata: string\r\n      display: NFTDisplayRecord\r\n      media_raw: string\r\n      title: string\r\n      description: string }\r\n\r\ntype Like =\r\n    { userAddress: string\r\n      userDisplay: string\r\n      userImage: string\r\n      userUrl: string\r\n      text: string\r\n      timestamp: int64\r\n      blockNumber: int64\r\n      transactionHash: string }\r\n\r\ntype LikeSlim =\r\n    { text: string }\r\n\r\ntype ProfileInfo =\r\n    { displayName: string\r\n      image: string }\r\n\r\ntype NFTResult =\r\n    { index: int\r\n      nft: NFT\r\n      likes: LikeSlim[]\r\n      likeCount: int\r\n      rarityRanking: float }\r\n\r\ntype NftAttribute =\r\n    { traitType: string\r\n      value: string\r\n      displayType: string }\r\n\r\ntype NFTResultFull =\r\n    { nft: NFT\r\n      attributes: NftAttribute[] }\r\n\r\ntype NFTCollection =\r\n    { token_address: string \r\n      name: string\r\n      symbol: string\r\n      ranking: int\r\n      description: string\r\n      bannerUrl: string\r\n      imageUrl: string }\r\n\r\ntype NFTCollectionResult =\r\n    { collection: NFTCollection\r\n      nfts: NFTResult[] }\r\n\r\ntype PagedResult<'t> =\r\n    { results: 't[]\r\n      cursor: string }\r\n\r\ntype NFTDetails =\r\n    { nft: NFT }\r\n\r\ntype TreeLink =\r\n    { name: string\r\n      url: string }\r\n\r\ntype TreeEditLink =\r\n    { key: string\r\n      index: int\r\n      editing: bool\r\n      name: string\r\n      url: string\r\n      nameField: string\r\n      urlField: string }\r\n\r\ntype TreeNft =\r\n    { token_address: string\r\n      token_id: string\r\n      display: bool }\r\n\r\ntype TreeData =\r\n    { profileNft: (string * string) option\r\n      name: string\r\n      bio: string\r\n      links: TreeLink[]\r\n      nfts: Map<string * string, bool>\r\n      colors: string[]\r\n      darkMode: bool }\r\n\r\ntype TreeEditData =\r\n    { profileNft: (string * string) option\r\n      nameField: string\r\n      bioField: string\r\n      hasChanges: bool\r\n      linkFields: TreeEditLink[]\r\n      nftFields: Map<string * string, bool>\r\n      colors: string[]\r\n      darkMode: bool }\r\n\r\ntype AccountData =\r\n    { selectedAccount: string\r\n      profileInfo: ProfileInfo option option\r\n      chainId: int }\r\n\r\ntype ProfileUpdate =\r\n    { address: string\r\n      ens: string\r\n      text: string }\r\n\r\ntype CommonModel =\r\n    { accountData: AccountData option }\r\n\r\ntype ChainConfig =\r\n    { infuraUrl: string\r\n      infuraWsUrl: string\r\n      chainId: int\r\n      chainName: string\r\n      web3treeContractAddress: string }\r\n\r\nlet (|ContainsKey|_|) key map = map |> Map.tryFind key\r\n\r\nlet isMobile =\r\n    \r\n    match !!Browser.Dom.window?navigator?userAgent with\r\n    | (x :string) when x.Contains(\"Android\") -> true\r\n    | x when x.Contains(\"webOS\") -> true\r\n    | x when x.Contains(\"iPhone\") -> true\r\n    | x when x.Contains(\"iPad\") -> true\r\n    | x when x.Contains(\"iPod\") -> true\r\n    | x when x.Contains(\"BlackBerry\") -> true\r\n    | x when x.Contains(\"IEMobile\") -> true\r\n    | x when x.Contains(\"Opera Mini\") -> true\r\n    | _ -> false\r\n\r\nlet inline modelViewer props children = domEl \"model-viewer\" props children\r\n\r\nmodule Emojis =\r\n\r\n    let fire = @\"\"\r\n\r\n    let emojis =\r\n        [\"fire\", \"emoji_u1f525\", \"🔥\"\r\n         \"heart\", \"emoji_u2764\", \"❤\"\r\n         \"smile\", \"emoji_u1f600\", \"😃\"\r\n         \"laugh\", \"emoji_u1f602\", \"😂\"\r\n         \"wink\", \"emoji_u1f609\", \"😉\"\r\n         \"cool\", \"emoji_u1f60e\", \"😎\"\r\n         \"nerd\", \"emoji_u1f913\", \"🤓\"\r\n         \"star-struck\", \"emoji_u1f60d\", \"🤩\"\r\n         \"in-love\", \"emoji_u1f970\", \"🥰\"\r\n         \"crazy\", \"emoji_u1f92a\", \"🤪\"\r\n         \"money\", \"emoji_u1f911\", \"🤑\"\r\n         \"surprised\", \"emoji_u1f62e\", \"😲\"\r\n         \"thumbs-up\", \"\", \"👍\"\r\n         \"100\", \"\", \"💯\"\r\n         \"hands-up\", \"\", \"🙌\"\r\n         \"top\", \"\", \"🔝\"\r\n         \"ghost\", \"emoji_u1f47b\", \"👻\"\r\n         \"alien\", \"emoji_u1f47d\", \"👽\"\r\n         \"space-invader\", \"\", \"👾\"\r\n         ]\r\n\r\n    let picByName = emojis |> List.map (fun (n, c, _) -> n, c) |> Map.ofList\r\n\r\n    let charByName = emojis |> List.map (fun (n, _, c) -> n, c) |> Map.ofList\r\n\r\nmodule TreeEditData =\r\n\r\n    let toTree (tree :TreeEditData) =\r\n        { profileNft = tree.profileNft\r\n          name = tree.nameField\r\n          bio = tree.bioField\r\n          links = tree.linkFields |> Array.map (fun l -> { name = l.name; url = l.url })\r\n          nfts = tree.nftFields\r\n          colors = tree.colors\r\n          darkMode = tree.darkMode }\r\n\r\nmodule TreeData =\r\n\r\n    open System.Text\r\n\r\n    let toMarkdown (tree :TreeData) =\r\n        let sb = new StringBuilder()\r\n        match tree.profileNft with\r\n        | Some (address, id) ->\r\n            sb.AppendLine(\"+ \" + address + \", \" + id) |> ignore\r\n        | _ -> ()\r\n        let sb =\r\n            sb.Append(\"#\")\r\n              .AppendLine(tree.name)\r\n              .AppendLine(tree.bio)\r\n              .AppendLine(\"***\")\r\n        for link in tree.links do\r\n            sb.AppendLine(sprintf \"[%s](%s)\" link.name link.url) |> ignore\r\n        let toHide = tree.nfts |> Map.toArray |> Array.map fst |> Array.groupBy fst\r\n        for (address, ids) in toHide do\r\n            sb.AppendLine(sprintf \"* %s\" address) |> ignore\r\n            for (_, id) in ids do\r\n                sb.AppendLine(sprintf \"** %s\" (id.ToString())) |> ignore\r\n        match tree.colors with\r\n        | [||] -> ()\r\n        | _ ->\r\n            let cstr = System.String.Join(\", \", tree.colors)\r\n            let mstr = if tree.darkMode then \"+\" else \"-\"\r\n            sb.AppendLine(sprintf \"%s %s\" mstr cstr) |> ignore\r\n        sb.ToString()\r\n\r\n    let fromMarkdown (markdown :string) =\r\n        let lines = markdown.Split('\\n') |> Array.filter (fun l -> not <| System.String.IsNullOrEmpty l)\r\n        // optional profile nft\r\n        let profileNft =\r\n            if lines.[0].StartsWith(\"+\") then\r\n                let split = lines.[0].Substring(1).Split(',')\r\n                Some (split.[0].Trim(), split.[1].Trim())\r\n            else\r\n                None\r\n        let headerLine = match profileNft with | None -> 0 | Some _ -> 1\r\n        let name = lines.[headerLine].TrimStart('#')\r\n        let bioEnd = lines |> Array.findIndex (fun l -> l = \"***\")\r\n        let bio = System.String.Join(\"\\n\", [| (headerLine + 1) .. bioEnd - 1 |] |> Array.map (fun i -> lines.[i]))\r\n        let links =\r\n            lines |> Array.choose (fun l ->\r\n                let regex = RegularExpressions.Regex(\"\"\"^\\[([\\w\\s\\d]+)\\]\\((https?:\\/\\/[\\w\\d./?=#@]+)\\)\"\"\" )\r\n                let m = regex.Matches(l)\r\n                if m.Count > 0 then Some (m.[0].Groups.[1].Value, m.[0].Groups.[2].Value) else None)\r\n                |> Array.map (fun (n, u) -> { name = n; url = u })\r\n        let rec addHide tokenAddress nfts (lines :string list) =\r\n            match lines with\r\n            | [] -> nfts\r\n            | (l::ls) ->\r\n                if l.StartsWith(\"**\") then\r\n                    let id = l.TrimStart('*').Trim()\r\n                    addHide tokenAddress (nfts |> Map.add (tokenAddress, id) true) ls\r\n                else\r\n                    if l.StartsWith(\"*\") then addHide (l.TrimStart('*').Trim()) nfts ls\r\n                    else addHide tokenAddress nfts ls\r\n        let remaining = lines |> Array.skip (bioEnd + 1) |> Array.toList\r\n        let darkMode, colors =\r\n            let last = lines |> Array.last\r\n            if last.StartsWith(\"-\") || last.StartsWith(\"+\") then\r\n                last.StartsWith(\"+\"), last.Substring(2).Split(',') |> Array.map (fun s -> s.Trim())\r\n            else false, [||]\r\n        { profileNft = profileNft\r\n          name = name\r\n          bio = bio\r\n          links = links\r\n          nfts = addHide \"\" Map.empty remaining\r\n          colors = colors\r\n          darkMode = darkMode }\r\n\r\nmodule ColorUtils =\r\n\r\n    let gradients =\r\n        [[\"#FF4E50\"; \"#F9D423\"], \"Dance To Forget\"\r\n         [\"#ee0979\"; \"#ff6a00\"], \"Ibiza Sunset\"\r\n         [\"#FC354C\"; \"#0ABFBC\"], \"Miaka\"\r\n         [\"#e14fad\"; \"#f9d423\"], \"Juicy Cake\"\r\n         [\"#FEAC5E\"; \"#C779D0\"; \"#4BC0C8\"], \"Atlas\"\r\n         [\"#DA22FF\"; \"#9733EE\"], \"Intuitive Purple\"\r\n         [\"#f953c6\"; \"#b91d73\"], \"Neuromancer\"\r\n         [\"#FC466B\"; \"#3F5EFB\"], \"Sublime Vivid\"\r\n         [\"#9796f0\"; \"#fbc7d4\"], \"Anamnisar\"\r\n         [\"#00dbde\"; \"#fc00ff\"], \"North Miracle\"\r\n         [\"#283048\"; \"#859398\"], \"Titanium\"\r\n         [\"#373B44\"; \"#4286f4\"], \"Dark Ocean\"\r\n         [\"#3a6186\"; \"#89253e\"], \"Love Couple\"\r\n         [\"#4ECDC4\"; \"#556270\"], \"Disco\"\r\n         [\"#2193b0\"; \"#6dd5ed\"], \"Cool Blues\"\r\n         [\"#c2e59c\"; \"#64b3f4\"], \"Green and Blue\"\r\n         [\"#16A085\"; \"#F4D03F\"], \"Harmonic Energy\"\r\n         [\"#FA8BFF\"; \"#2BD2FF\"; \"#2BFF88\"], \"Summer Glow\"\r\n         [\"#434343\"; \"#000000\"], \"Premium Dark\"\r\n         [\"#fdfbfb\"; \"#ebedee\"], \"Cloudy Knoxville\"\r\n         ]\r\n\r\n    let gradientArray =\r\n        gradients |> List.map (fun (cs, n) -> cs |> List.toArray, n) |> Array.ofList\r\n\r\n    let defaultColors = [|\"#283048\"; \"#859398\"|]\r\n\r\n    let fromRgb (r, g, b) =\r\n        let r = float r / 255.0\r\n        let g = float g / 255.0\r\n        let b = float b / 255.0\r\n        let mn = min (min r g) b\r\n        let mx = max (max r g) b\r\n        let d = mx - mn\r\n        let l = (mx + mn) / 2.0\r\n        if d <> 0.0 then\r\n            let s = if l < 0.5 then d / (mx + mn) else d / (2.0 - mx - mn)\r\n            let h = if r = mx then (g - b) / d else if g = mx then 2.0 + (b - r) / d else 4.0 + (r - g) / d\r\n            let h = h * 60.0\r\n            let h = if h < 0.0 then h + 360.0 else h\r\n            h, s, l\r\n        else 0.0, 0.0, l\r\n\r\n    let toRgb (h, s, l) =\r\n        let h = h / 60.0\r\n        match s with\r\n        | 0.0 -> let v = int (round (l * 255.0)) in v, v, v\r\n        | _ ->\r\n            let calc c t1 t2 =\r\n                let c = if c < 0.0 then c + 1.0 else if c > 1.0 then c - 1.0 else c\r\n                if 6.0 * c < 1.0 then t1 + (t2 - t1) * 6.0 * c\r\n                    else if 2.0 * c < 1.0 then t2\r\n                        else if 3.0 * c < 2.0 then t1 + (t2 - t1) * (2.0 / 3.0 - c) * 6.0 else t1\r\n            let t2 = if l < 0.5 then l * (1.0 + s) else (l + s) - (l * s)\r\n            let t1 = 2.0 * l - t2\r\n            let th = h / 6.0\r\n            let tr = th + (1.0 / 3.0)\r\n            let tg = th\r\n            let tb = th - (1.0 / 3.0)\r\n            let tr = calc tr t1 t2\r\n            let tg = calc tg t1 t2\r\n            let tb = calc tb t1 t2\r\n            int (round (tr * 255.0)), int (round (tg * 255.0)), int (round (tb * 255.0))\r\n\r\n    let fromHexStr (color :string) =\r\n        let r = System.Int32.Parse(color.Substring(1, 2), System.Globalization.NumberStyles.HexNumber)\r\n        let g = System.Int32.Parse(color.Substring(3, 2), System.Globalization.NumberStyles.HexNumber)\r\n        let b = System.Int32.Parse(color.Substring(5, 2), System.Globalization.NumberStyles.HexNumber)\r\n        r, g, b\r\n\r\n    let lighten (factor: float) (hexColor :string) =\r\n        let h, s, l = hexColor |> fromHexStr |> fromRgb\r\n        let r, g, b = toRgb (h, (s * (1.0 + factor)), (l * (1.0 + factor)))\r\n        sprintf \"rgb(%i, %i, %i)\" r g b\r\n\r\n    let isLight (colors :string seq) =\r\n        let averageLightness = colors |> Seq.map (fun c -> let _, _, l = c |> fromHexStr |> fromRgb in l) |> Seq.average\r\n        averageLightness > 0.85\r\n\r\n    let isDark (colors :string seq) =\r\n        let averageLightness = colors |> Seq.map (fun c -> let _, _, l = c |> fromHexStr |> fromRgb in l) |> Seq.average\r\n        averageLightness < 0.15\r\n\r\n    let isSlightlyLight (colors: string seq) =\r\n        let averageLightness = colors |> Seq.map (fun c -> let _, _, l = c |> fromHexStr |> fromRgb in l) |> Seq.average\r\n        averageLightness > 0.4\r\n\r\nmodule Config =\r\n\r\n    let private kovan =\r\n      { infuraUrl = \"https://kovan.infura.io/v3/2ba89d75124a4e0baf363346d70820fb\"\r\n        infuraWsUrl = \"wss://kovan.infura.io/ws/v3/2ba89d75124a4e0baf363346d70820fb\"\r\n        chainId = 42\r\n        chainName = \"Kovan\"\r\n        web3treeContractAddress = \"0x5f73F01a15efb3311605AFCbB7dDC60055dB941D\" }\r\n\r\n    let private mainnet =\r\n        { infuraUrl = \"https://mainnet.infura.io/v3/2ba89d75124a4e0baf363346d70820fb\"\r\n          infuraWsUrl = \"wss://mainnet.infura.io/ws/v3/2ba89d75124a4e0baf363346d70820fb\"\r\n          chainId = 1\r\n          chainName = \"Mainnet\"\r\n          web3treeContractAddress = \"0x96df6c12aabb9b0c9c968457a9834d9e9769ae51\" }\r\n\r\n    let network = mainnet\r\n\r\n    let alchemyHttps = \"https://eth-mainnet.alchemyapi.io/v2/ISwsu9zW_oF4jSNsJ00y6ldFN_rUDf8g\"\r\n\r\n    let nftPageSize = 6\r\n\r\n    let getBlockExplorerUrl txHash =\r\n        match network.chainId with\r\n        | 42 -> \"https://kovan.etherscan.io/tx/\" + txHash\r\n        | 1 -> \"https://etherscan.io/tx/\" + txHash\r\n\r\n    let siteUrl = \"https://web3tr.ee\"\r\n\r\n// Web3\r\n// ---------------\r\nlet getLibrary provider = new Web3Provider(provider)\r\n\r\nlet Injected :IWeb3Connector = new InjectedConnector({ supportedChainIds = [|Config.network.chainId|] }) :> IWeb3Connector\r\n\r\nlet CoinbaseWallet :IWeb3Connector = new WalletLinkConnector({ url = Config.network.infuraUrl; supportedChainIds = [|Config.network.chainId|]; appName = \"Web3Tree\" }) :> IWeb3Connector\r\n\r\nlet WalletConnect :IWeb3Connector = new WalletConnectConnector({ rpcUrl = Config.network.infuraUrl; bridge = \"https://bridge.walletconnect.org\"; qrcode = true }) :> IWeb3Connector\r\n\r\nlet web3treeAbi : obj = import \"default\" \"./web3tree-abi.js\"\r\n\r\nlet web3treeAbiHr :obj =\r\n    let inter = new Interface(web3treeAbi)\r\n    inter.format(formatTypes.full)\r\n\r\n// ----------------\r\n\r\nlet getStorageType (src :string) =\r\n    if src.StartsWith \"data:\" then OnChain\r\n    else\r\n        if src.StartsWith \"ipfs://\" then IPFS\r\n        else Unknown\r\n\r\nmodule Moralis =\r\n\r\n    open Fable.SimpleHttp\r\n    open Fable.SimpleJson\r\n\r\n    type PagedResult<'t> =\r\n        { total: int\r\n          page: int\r\n          page_size: int\r\n          cursor: string\r\n          result: 't[] }\r\n\r\n    type ProfileEvent =\r\n        { user: string\r\n          text: string\r\n          block_number: int64 }\r\n\r\n    type EventResults<'t> =\r\n        { results: 't[] }\r\n\r\n    //let getProfileEvents (account :string) =\r\n    //    let url =\r\n    //        \"https://oq4tkdwha9jz.usemoralis.com:2053/server/classes/profile?order=-block_number&limit=1&where=%7B%20%22user%22%20%3A%20%22\" + account.ToLower() + \"%22%20%7D\"\r\n    //    async {\r\n    //        let! response =\r\n    //            Http.request url\r\n    //                |> Http.method GET\r\n    //                |> Http.header (Headers.accept \"application/json\")\r\n    //                |> Http.header (Headers.create \"X-Parse-Application-Id\" \"mhAmYT6t2GjzJCMI0Jkl6nXAeTDui4x7ZQQXHvfi\")\r\n    //                |> Http.header (Headers.create \"X-Parse-Master-Key\" \"G5e2lnbxisjISbb2Qsglib6M4URQ5fJ30zONshpd\")\r\n    //                |> Http.send\r\n    //        let results : EventResults<ProfileEvent> = Json.parseAs response.responseText\r\n    //        return results\r\n    //        }\r\n\r\nmodule Server =\r\n\r\n    open Fable.SimpleJson\r\n    open Fable.SimpleHttp\r\n\r\n    let baseUrl = \"https://sociable.network\"\r\n\r\n    let postReceipt (receipt :obj) =\r\n        async {\r\n            let body = Json.stringify receipt\r\n            let! code, _ = Http.post (baseUrl + \"/api/receipt\") body\r\n            match code with\r\n            | 200 -> return ()\r\n            | _ -> return failwith \"error\"\r\n        }\r\n\r\n    let getLikes tokenAddress tokenId :Like[] Async =\r\n        async {\r\n            let! code, response = Http.get <| sprintf \"%s/api/likes/%s/%s\" baseUrl tokenAddress tokenId\r\n            match code with\r\n            | 200 -> return Json.parseAs response\r\n            | _ -> return [||]\r\n        }\r\n\r\n    let getProfileInfo address :ProfileInfo option Async =\r\n        async {\r\n            let! code, response = Http.get <| baseUrl + \"/api/profileinfo/\" + address\r\n            match code with\r\n            | 200 -> return Some (Json.parseAs response)\r\n            | 404 -> return None\r\n            | _ -> return failwith \"error\"\r\n        }\r\n\r\n    let getAddressForEns username =\r\n        async {\r\n            let! code, response = Http.get <| baseUrl + \"/api/address/\" + username\r\n            match code with\r\n            | 200 -> return Some response\r\n            | 404 -> return None\r\n            | _ -> return failwith \"error\"\r\n        }\r\n\r\n    let getAddressForUrl url =\r\n        async {\r\n            let! code, response = Http.get <| baseUrl + \"/api/map/\" + url\r\n            match code with\r\n            | 200 -> return Some response\r\n            | 404 -> return None\r\n            | _ -> return failwith \"error\"\r\n        }\r\n\r\n    let getUrlForAddress address =\r\n        async {\r\n            let! code, response = Http.get <| baseUrl + \"/api/map/\" + address\r\n            match code with\r\n            | 200 -> return Some response\r\n            | _ -> return failwith \"error\"\r\n        }\r\n\r\n    let getEns address =\r\n        async {\r\n            let! code, response = Http.get <| baseUrl + \"/api/ens/\" + address\r\n            match code with\r\n            | 200 when not <| System.String.IsNullOrEmpty response -> return Some response\r\n            | _ -> return None\r\n        }\r\n\r\n    let getColorsForAddress (address :string) =\r\n        let r = System.Int32.Parse(address.Substring(2, 2), System.Globalization.NumberStyles.HexNumber)\r\n        let colors, _ = ColorUtils.gradients |> List.item (r % ColorUtils.gradients.Length)\r\n        let darkMode = r % 2 = 0\r\n        colors |> List.toArray, darkMode\r\n\r\n    //let getTreeData address =\r\n    //    async {\r\n    //        let! response = Moralis.getProfileEvents address\r\n    //        match response.results.Length with\r\n    //        | 0 ->\r\n    //            // pick colour scheme at random from address\r\n    //            let colors, darkMode = getColorsForAddress address\r\n    //            return\r\n    //                { TreeData.name = \"\"\r\n    //                  profileNft = None\r\n    //                  bio = \"\"\r\n    //                  links = [||]\r\n    //                  nfts = Map.empty\r\n    //                  colors = colors\r\n    //                  darkMode = darkMode }\r\n    //        | _ ->\r\n    //            let latest = response.results |> Array.maxBy (fun e -> e.block_number)\r\n    //            let treeData = latest.text |> TreeData.fromMarkdown\r\n    //            match treeData.colors with\r\n    //            | [||] ->\r\n    //                let colors, darkMode = getColorsForAddress address\r\n    //                return { treeData with colors = colors; darkMode = darkMode }\r\n    //            | _ -> return treeData\r\n    //    }\r\n\r\n    let getTreeDataFromServer user =\r\n        async {\r\n            let! code, response = Http.get <| baseUrl + \"/api/profileupdate/\" + user\r\n            match code with\r\n            | 200 ->\r\n                let profileUpdate :ProfileUpdate = Json.parseNativeAs response\r\n                let tree =\r\n                    if System.String.IsNullOrEmpty profileUpdate.text then\r\n                        let colors, darkMode = getColorsForAddress profileUpdate.address\r\n                        { TreeData.name = \"\"\r\n                          profileNft = None\r\n                          bio = \"\"\r\n                          links = [||]\r\n                          nfts = Map.empty\r\n                          colors = colors\r\n                          darkMode = darkMode }\r\n                    else\r\n                        let treeData = profileUpdate.text |> TreeData.fromMarkdown\r\n                        match treeData.colors with\r\n                        | [||] ->\r\n                            let colors, darkMode = getColorsForAddress profileUpdate.address\r\n                            { treeData with colors = colors; darkMode = darkMode }\r\n                        | _ -> treeData\r\n                return Some (profileUpdate.address, profileUpdate.ens, tree)\r\n            | 404 ->\r\n                return None\r\n            | _ -> return failwith \"an error occurred getting profile update from server\"\r\n        }\r\n\r\n    let getNFTs account =\r\n        async {\r\n            let! code, response = Http.get <| baseUrl + \"/api/nfts?account=\" + account\r\n            match code with\r\n            | 200 ->\r\n                let nfts :PagedResult<NFTCollectionResult> = Json.parseNativeAs response\r\n                return nfts\r\n            | _ -> return { results = [||]; cursor = null }\r\n        }\r\n\r\n    let getNFT tokenAddress tokenId =\r\n        async {\r\n            let! code, response = Http.get <| sprintf \"%s/api/nft/%s/%s\" baseUrl tokenAddress tokenId\r\n            match code with\r\n            | 200 when not <| System.String.IsNullOrEmpty (response) ->\r\n                let nft :NFT = Json.parseNativeAs response\r\n                return Some nft\r\n            | _ -> return None\r\n        }\r\n\r\n    let getNFTDetails tokenAddress tokenId =\r\n        async {\r\n            let! code, response = Http.get <| sprintf \"%s/api/nftdetails/%s/%s\" baseUrl tokenAddress tokenId\r\n            match code with\r\n            | 200 when not <| System.String.IsNullOrEmpty (response) ->\r\n                let nft :NFTResultFull = Json.parseNativeAs response\r\n                return Some nft\r\n            | _ -> return None\r\n        }\r\n\r\n    let getNFTOwners tokenAddress tokenId =\r\n        async {\r\n            let! code, response = Http.get <| sprintf \"%s/api/nftowners/%s/%s\" baseUrl tokenAddress tokenId\r\n            match code with\r\n            | 200 when not <| System.String.IsNullOrEmpty (response) ->\r\n                let nft :NFTOwners = Json.parseNativeAs response\r\n                return Some nft\r\n            | _ -> return None\r\n        }\r\n\r\n    let getCollection tokenAddress =\r\n        async {\r\n            let! code, response = Http.get <| sprintf \"%s/api/collection/%s\" baseUrl tokenAddress\r\n            match code with\r\n            | 200 when not <| System.String.IsNullOrEmpty (response) ->\r\n                let nft :NFTCollection = Json.parseNativeAs response\r\n                return Some nft\r\n            | _ -> return None \r\n        }\r\n\r\n    //let getTreeAndProfileNft address =\r\n    //    async {\r\n    //        let! tree = getTreeData address\r\n    //        let! profileNft =\r\n    //            match tree.profileNft with\r\n    //            | None -> async { return None }\r\n    //            | Some (tokenAddress, tokenId) ->\r\n    //                getNFT tokenAddress tokenId\r\n    //        return tree, profileNft\r\n    //    }\r\n\r\nmodule Validate =\r\n\r\n    let linkName txt = if System.String.IsNullOrEmpty txt then false else true\r\n\r\n    let linkUrl txt = System.Text.RegularExpressions.Regex.IsMatch(txt, \"^(ht|f)tp(s?)\\:\\/\\/[0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*(:(0-9)*)*(\\/?)([a-zA-Z0-9\\@\\-\\.\\?\\,\\'\\/\\\\\\+&%\\$#_]*)?$\")\r\n","\r\n[<RequireQualifiedAccess>]\r\nmodule Promise\r\n\r\n#nowarn \"1182\" // Unused values\r\n\r\nopen System\r\nopen Fable.Core\r\nopen Fable.Core.JsInterop\r\n\r\n[<Emit(\"new Promise($0)\")>]\r\n/// <summary>\r\n/// Create a promise from a function\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// let write (path: string) (content: string) =\r\n///     Promise.create (fun resolve reject ->\r\n///         Node.Api.fs.writeFile(path, content, (fun res ->\r\n///             match res with\r\n///             | Some res -> reject (res :?> System.Exception)\r\n///             | None -> resolve ()\r\n///         ))\r\n///     )\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"f\">\r\n/// Function used to create the promise, it receives two other function parameters:\r\n///\r\n/// - <c>success</c> : called when the promise is resolved\r\n/// - <c>fail</c> : called when the promise is rejected\r\n/// </param>\r\n/// <typeparam name=\"'T\">Return type of the promise</typeparam>\r\n/// <returns>\r\n/// The promise created by the function\r\n/// </returns>\r\nlet create (f: ('T -> unit) -> (exn -> unit) -> unit): JS.Promise<'T> = jsNative\r\n\r\n[<Emit(\"new Promise(resolve => setTimeout(resolve, $0))\")>]\r\n\r\n/// <summary>\r\n/// Create a promise which wait <c>X</c> ms before resolving.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// // Do something\r\n/// doSomething ()\r\n/// // Sleep for 1 second\r\n/// |> Promise.sleep 1000\r\n/// // Do another thing\r\n/// |> Promise.map (fun _ ->\r\n///     doAnotherThing ()\r\n/// )\r\n/// |> Promise.map ...\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"ms\">Number of milliseconds to wait</param>\r\n/// <returns>A delayed promise</returns>\r\nlet sleep (ms: int): JS.Promise<unit> = jsNative\r\n\r\n[<Emit(\"Promise.resolve($0)\")>]\r\n/// <summary>\r\n/// Create a promise (in resolved state) with supplied value.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// Promise.lift {| Firstname = \"John\" |}\r\n/// |> Promise.map (fun user ->\r\n///     console.log $\"Hello, %s{user.Firstname}\"\r\n///     // Expected output: \"Hello, John\"\r\n/// )\r\n/// |> Promise.map ...\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"a\">Value to return</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\n/// <returns>Returns a promise returning the supplied value</returns>\r\nlet lift<'T> (a: 'T): JS.Promise<'T> = jsNative\r\n\r\n[<Emit(\"Promise.reject($0)\")>]\r\n/// <summary>\r\n/// Creates promise (in rejected state) with supplied reason.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// Promise.reject (Exception \"User not found\")\r\n/// |> Promise.map (fun _ ->\r\n///     // This promise is skipped\r\n/// )\r\n/// |> Promise.catch (fun error ->\r\n///     console.error $\"An error ocurred: %s{error.Message}\"\r\n///     // Expected output: \"An error ocurred: User not found\"\r\n/// )\r\n/// |> Promise.map ...\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"reason\">Reason to return</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\n/// <returns>Return a promise in a rejected state</returns>\r\nlet reject<'T> (reason: exn) : JS.Promise<'T> = jsNative\r\n\r\n[<Emit(\"$1.then($0)\")>]\r\n/// <summary>\r\n/// Bind a value into a promise of a new type.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// Promise.lift {| Firstname = \"John\" |}\r\n/// |> Promise.bind (fun user ->\r\n///     // Do something with user and returns a promise\r\n///     Promise.create (fun resolve reject ->\r\n///         resolve $\"Hello, %s{user.Firstname}\"\r\n///     )\r\n/// )\r\n/// |> Promise.map (fun message ->\r\n///     console.log message\r\n///     // Expected output: \"Hello, John\"\r\n/// )\r\n/// |> Promise.map ...\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"a\">\r\n/// A function that takes the value of type <c>T1</c> and transforms it into a promise of type <c>T2</c>.\r\n/// </param>\r\n/// <param name=\"pr\">The input promise</param>\r\n/// <typeparam name=\"'T1\"></typeparam>\r\n/// <typeparam name=\"'T2\"></typeparam>\r\n/// <returns>A promise of the output type of the binder.</returns>\r\nlet bind (a: 'T1 -> JS.Promise<'T2>) (pr: JS.Promise<'T1>): JS.Promise<'T2> = jsNative\r\n\r\n[<Emit(\"$1.then($0)\")>]\r\n/// <summary>\r\n/// Map a value into another type, the result will be wrapped in a promise for you.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// Promise.lift {| Firstname = \"John\" |}\r\n/// |> Promise.map (fun user ->\r\n///     user.Firstname\r\n/// ) // Returns a Promise&lt;string&gt; with the value \"John\"\r\n/// |> Promise.map ...\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"a\">A function to apply to the result of the input promise.</param>\r\n/// <param name=\"pr\">The input promise</param>\r\n/// <typeparam name=\"'T1\"></typeparam>\r\n/// <typeparam name=\"'T2\"></typeparam>\r\n/// <returns>A promise after applying the mapping function</returns>\r\nlet map (a: 'T1 -> 'T2) (pr: JS.Promise<'T1>): JS.Promise<'T2> = jsNative\r\n\r\n[<Emit(\"void ($1.then($0))\")>]\r\n/// <summary>\r\n/// Call a function with the result of a promise and stop the promise chain.\r\n///\r\n/// This is equivalent to <c>Promise.map ... |> ignore</c>\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// fetchUser ()\r\n/// |> Promise.iter (fun user ->\r\n///     console.log \"User firstname is user.Firstname\"\r\n/// ) // unit\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"a\">A function to apply to the result of the input promise</param>\r\n/// <param name=\"pr\">The input promise</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\nlet iter (a: 'T -> unit) (pr: JS.Promise<'T>): unit = jsNative\r\n\r\n\r\n/// <summary>\r\n/// This is an identity function, it calls the given function and return the promise value untouched.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// fetchUser ()\r\n/// |> Promise.tap (fun user ->\r\n///     // Do something\r\n///     console.log \"The user has been received\"\r\n/// )\r\n/// |> Promise.map (fun user ->\r\n///     // user value is available here untouched\r\n/// )\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"fn\">A function to call after receiving the receiving of the input promise</param>\r\n/// <param name=\"a\">The input promise</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\n/// <returns>A promise of the same type as the input promise</returns>\r\nlet tap (fn: 'T -> unit) (a: JS.Promise<'T>): JS.Promise<'T> =\r\n    a |> map (fun x -> fn x; x)\r\n\r\n[<Emit(\"$1.catch($0)\")>]\r\n/// <summary>\r\n/// Handle an errored promise allowing you pass a return value.\r\n///\r\n/// This version of <c>catch</c> expects a function returning just <c>'T</c>, as opposed to <c>Promise&lt;'T&gt;</c>. If you need to return <c>Promise&lt;'T&gt;</c>, use <c>catchBind</c>.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// Promise.create (fun resolve reject ->\r\n///     reject (System.Exception \"User not found\")\r\n/// )\r\n/// |> Promise.catch (fun error ->\r\n///     // Log the error\r\n///     console.error error\r\n///     // Do something to recover from the error\r\n///     Error error.Message\r\n/// )\r\n/// |> Promise.map ...\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"fail\">Function to call if the input promise fail</param>\r\n/// <param name=\"pr\">The input promise</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\n/// <returns>A promise which result of the call of fail</returns>\r\nlet catch (fail: exn -> 'T) (pr: JS.Promise<'T>): JS.Promise<'T> = jsNative\r\n\r\n[<Emit(\"$1.catch($0)\")>]\r\n/// <summary>\r\n/// Handle an errored promise allowing to call a promise.\r\n///\r\n/// This version of <c>catch</c> expects a function returning <c>Promise&lt;'T&gt;</c> as opposed to just <c>'T</c>. If you need to return just 'T, use <c>catch</c>.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// Promise.create (fun resolve reject ->\r\n///     reject (System.Exception \"User not found\")\r\n/// )\r\n/// |> Promise.catchBind (fun error ->\r\n///     // Recover from the error, here we call another promise and returns it's result\r\n///     logErrorToTheServer error\r\n/// )\r\n/// |> Promise.map ...\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"fail\">Function to call if the input promise fail</param>\r\n/// <param name=\"pr\">The input promise</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\n/// <returns>A promise which is the result of the fail function</returns>\r\nlet catchBind (fail: exn -> JS.Promise<'T>) (pr: JS.Promise<'T>): JS.Promise<'T> = jsNative\r\n\r\n[<Emit(\"void ($1.catch($0))\")>]\r\n/// <summary>\r\n/// Used to catch errors at the end of a promise chain.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// Promise.create (fun resolve reject ->\r\n///     reject (System.Exception \"User not found\")\r\n/// )\r\n/// |> Promise.map (fun _ ->\r\n///     // ...\r\n/// )\r\n/// |> Promise.map (fun _ ->\r\n///     // ...\r\n/// )\r\n/// |> Promise.catchEnd (fun error ->\r\n///     // ...\r\n/// ) // Returns unit\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"fail\">Fuction to call if the input promise fail</param>\r\n/// <param name=\"pr\">The input promise</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\nlet catchEnd (fail: exn -> unit) (pr: JS.Promise<'T>): unit = jsNative\r\n\r\n[<Emit(\"$2.then($0).catch($1)\")>]\r\n/// <summary>\r\n/// A combination of <c>map</c> and <c>catch</c>, this function applies the <c>success</c> continuation when the input promise resolves successfully, or <c>fail</c> continuation when the input promise fails.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// somePromise\r\n/// |> Promise.either\r\n///     (fun x -> string x)\r\n///     (fun err -> Promise.lift err.Message)\r\n/// |> Promise.map ...\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"success\">Function to call if the input promise succeeds</param>\r\n/// <param name=\"fail\">Function to call if the input promise fail</param>\r\n/// <param name=\"pr\">The input promise</param>\r\n/// <typeparam name=\"'T1\"></typeparam>\r\n/// <typeparam name=\"'T2\"></typeparam>\r\n/// <returns>A new promise which is the result of calling <c>success</c> if <c>pr</c> succeedes, or of <c>fail</c> if <c>pr</c> failed</returns>\r\nlet either (success: 'T1 -> 'T2) (fail: exn -> 'T2) (pr: JS.Promise<'T1>): JS.Promise<'T2> = jsNative\r\n\r\n[<Emit(\"$2.then($0).catch($1)\")>]\r\n/// <summary>\r\n/// A combination of <c>bind</c> and <c>catchBind</c>, this function applies the <c>success</c> continuation when the input promise resolves successfully, or <c>fail</c> continuation when the input promise fails.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// somePromise\r\n/// |> Promise.eitherBind\r\n///     (fun x -> string x |> Promise.lift)\r\n///     (fun err -> Promise.lift err.Message)\r\n/// |> Promise.map ...\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"success\">Binder function to call if the input promise succeeds</param>\r\n/// <param name=\"fail\">Binder function to call if the input promise fail</param>\r\n/// <param name=\"pr\">The input promise</param>\r\n/// <typeparam name=\"'T1\"></typeparam>\r\n/// <typeparam name=\"'T2\"></typeparam>\r\n/// <returns>A new promise which is the result of calling <c>success</c> if <c>pr</c> succeedes, or of <c>fail</c> if <c>pr</c> failed</returns>\r\nlet eitherBind (success: 'T1 -> JS.Promise<'T2>) (fail: exn -> JS.Promise<'T2>) (pr: JS.Promise<'T1>): JS.Promise<'T2> = jsNative\r\n\r\n[<Emit(\"void ($2.then($0).catch($1))\")>]\r\n/// <summary>\r\n/// Same as <c>Promise.either</c> but stopping the promise execution.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// somePromise\r\n/// |> Promise.eitherEnd\r\n///     (fun x -> string x)\r\n///     (fun err -> Promise.lift err.Message)\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"success\">Binder function to call if the input promise succeeds</param>\r\n/// <param name=\"fail\">Binder function to call if the input promise fail</param>\r\n/// <param name=\"pr\">The input promise</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\nlet eitherEnd (success: 'T -> unit) (fail: exn -> unit) (pr: JS.Promise<'T>): unit = jsNative\r\n\r\n[<Emit(\"void $0\")>]\r\n/// <summary>\r\n/// Start a promise.\r\n///\r\n/// Fake starting a promise. It is faking it because promise are hot meaning they execute directly after their creation.\r\n///\r\n/// <c>Promise.start</c> is equivalent to <c>promise |> ignore</c>\r\n///\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// myPromise\r\n/// |> Promise.start\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"pr\">The input promise</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\nlet start (pr: JS.Promise<'T>): unit = jsNative\r\n\r\n[<Emit(\"$1.catch($0)\")>]\r\n/// <summary>\r\n/// Same as <c>Promise.start</c> but forcing you to handle the rejected state.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// myPromise\r\n/// |> Promise.tryStart\r\n///     (fun error ->\r\n///         // Do something on error\r\n///     )\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"fail\">Function to apply if the promise fail</param>\r\n/// <param name=\"pr\">The input promise</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\nlet tryStart (fail: exn -> unit) (pr: JS.Promise<'T>): unit = jsNative\r\n\r\n[<Emit(\"Promise.all($0)\")>]\r\n/// <summary>\r\n/// Takes a sequence of promises as an input, and returns a single <c>Promise</c> that resolves to an array of the results of the input promises.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// let p1 =\r\n///     promise {\r\n///         do! Promise.sleep 100\r\n///         return 1\r\n///     }\r\n/// let p2 =\r\n///     promise {\r\n///         do! Promise.sleep 200\r\n///         return 2\r\n///     }\r\n/// let p3 =\r\n///     promise {\r\n///         do! Promise.sleep 300\r\n///         return 3\r\n///     }\r\n///\r\n/// Promise.Parallel [p1; p2; p3]\r\n/// |> Promise.map (fun res ->\r\n///     // res = [|1; 2; 3 |]\r\n/// )\r\n/// |> Promise.map ...\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"pr\">A list of promise to wait for</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\n/// <returns>Return a new promise returning an array containing all the promise result</returns>\r\nlet Parallel (pr: seq<JS.Promise<'T>>): JS.Promise<'T[]> = jsNative\r\n\r\n[<Emit(\"Promise.all($0)\")>]\r\n/// <summary>\r\n/// Takes a sequence of promises as an input, and returns a single <c>Promise</c> that resolves to an array of the results of the input promises.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// let p1 =\r\n///     promise {\r\n///         do! Promise.sleep 100\r\n///         return 1\r\n///     }\r\n/// let p2 =\r\n///     promise {\r\n///         do! Promise.sleep 200\r\n///         return 2\r\n///     }\r\n/// let p3 =\r\n///     promise {\r\n///         do! Promise.sleep 300\r\n///         return 3\r\n///     }\r\n///\r\n/// Promise.all [p1; p2; p3]\r\n/// |> Promise.map (fun res ->\r\n///     // res = [|1; 2; 3 |]\r\n/// )\r\n/// |> Promise.map ...\r\n/// </code>\r\n/// </example>\r\n///\r\n/// Note: If you need to return mixed types you can use boxing and unboxing\r\n///\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// let users =\r\n///     promise {\r\n///         let! users = fetchUsers ()\r\n///         return box users\r\n///     }\r\n/// let posts =\r\n///     promise {\r\n///         let! posts = fetchPosts ()\r\n///         return box posts\r\n///     }\r\n///\r\n/// Promise.all [p1; p2]\r\n/// |> Promise.map (fun res ->\r\n///     let users = unbox&lt;User list&gt; res.[0]\r\n///     let posts = unbox&lt;Post list&gt; res.[1]\r\n///     // ...\r\n/// )\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"pr\">A list of promise to wait for</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\n/// <returns>Return a new promise returning an array containing all the promise result</returns>\r\nlet all (pr: seq<JS.Promise<'T>>): JS.Promise<'T[]> = jsNative\r\n\r\n\r\n/// <summary>\r\n/// Map the <c>Promise</c> result into a <c>Result</c> type.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n// Success example\r\n/// Promise.lift 42\r\n/// |> Promise.result\r\n/// |> Promise.map (fun value ->\r\n///     // value = Ok 42\r\n/// )\r\n///\r\n/// // Fail example\r\n/// Promise.reject \"Invalid value\"\r\n/// |> Promise.result\r\n/// |> Promise.map (fun value ->\r\n///     // value = Error \"Invalid value\"\r\n/// )\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"a\">The input promise</param>\r\n/// <typeparam name=\"'T\"></typeparam>\r\n/// <returns>A promise returning <c>Ok</c> if the input promise succeed, <c>Error</c> if the input promise failed</returns>\r\nlet result (a: JS.Promise<'T>): JS.Promise<Result<'T, exn>> =\r\n    either Ok Error a\r\n\r\n/// <summary>\r\n/// Evaluates to `myPromise |> Promise.map (Result.map fn)`\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// Promise.lift 42\r\n/// |> Promise.result\r\n/// |> Promise.mapResult (fun value ->\r\n///     value + 10\r\n/// )\r\n/// |> Promise.map (fun value ->\r\n///     // value = Ok 52\r\n/// )\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"fn\">The mapping function</param>\r\n/// <param name=\"a\">The input promise</param>\r\n/// <typeparam name=\"'T1\"></typeparam>\r\n/// <typeparam name=\"'T2\"></typeparam>\r\n/// <typeparam name=\"'E\"></typeparam>\r\n/// <returns>A promise returning the result of applying the mapping function to the input promise result</returns>\r\nlet mapResult (fn: 'T1 -> 'T2) (a: JS.Promise<Result<'T1, 'E>>): JS.Promise<Result<'T2, 'E>> =\r\n    a |> map (Result.map fn)\r\n\r\n\r\n/// <summary>\r\n/// Transform the success part of a result promise into another promise.\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// let multiplyBy2 (value : int) =\r\n///     Promise.create (fun resolve reject ->\r\n///         resolve (value * 2)\r\n///     )\r\n///\r\n/// Promise.lift 42\r\n/// |> Promise.result\r\n/// |> Promise.bindResult (fun value ->\r\n///     multiplyBy2 value\r\n/// )\r\n/// |> Promise.map (fun value ->\r\n///     // value = Ok 84\r\n/// )\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"fn\">The binder function</param>\r\n/// <param name=\"a\">The input promise</param>\r\n/// <typeparam name=\"'T1\"></typeparam>\r\n/// <typeparam name=\"'T2\"></typeparam>\r\n/// <typeparam name=\"'E\"></typeparam>\r\n/// <returns>Returns a new promise applying to the binder function to it if the input promise succeed</returns>\r\nlet bindResult (fn: 'T1 -> JS.Promise<'T2>) (a: JS.Promise<Result<'T1, 'E>>): JS.Promise<Result<'T2, 'E>> =\r\n    a |> bind (fun a ->\r\n        match a with\r\n        | Ok a ->\r\n            fn a |> map Ok\r\n        | Error e ->\r\n            lift (Error e))\r\n\r\n/// <summary>\r\n/// Evaluates to <c>myPromise |> Promise.map (Result.map fn)</c>\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// Promise.reject -1\r\n/// |> Promise.result\r\n/// |> Promise.mapResultError (fun value ->\r\n///     $\"%s{value} is not a valid value\"\r\n/// )\r\n/// |> Promise.map (fun value ->\r\n///     // value = Error \"-1 is not a valid value\"\r\n/// )\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\n/// <param name=\"fn\">A mapper function</param>\r\n/// <param name=\"a\">The input promise</param>\r\n/// <typeparam name=\"'E1\"></typeparam>\r\n/// <typeparam name=\"'E2\"></typeparam>\r\n/// <typeparam name=\"'T\"></typeparam>\r\n/// <returns>A promise returning the result of applying the mapper function to the input promise in case of error, otherwise the result of the input promise as it is</returns>\r\nlet mapResultError (fn: 'E1 -> 'E2) (a: JS.Promise<Result<'T, 'E1>>): JS.Promise<Result<'T, 'E2>> =\r\n    a |> map (Result.mapError fn)\r\n\r\n/// <summary>\r\n/// A builder to provide promise Computation Expression support.\r\n///\r\n/// The CE is available via <c>promise { ... }</c>\r\n/// <example>\r\n/// <code lang=\"fsharp\">\r\n/// let double (value : int) =\r\n///     promise {\r\n///         return value * 2\r\n///     }\r\n/// </code>\r\n/// </example>\r\n/// </summary>\r\ntype PromiseBuilder() =\r\n    [<Emit(\"$1.then($2)\")>]\r\n    member _.Bind(p: JS.Promise<'T1>, f: 'T1 -> JS.Promise<'T2>): JS.Promise<'T2> = jsNative\r\n\r\n    [<Emit(\"$1.then(() => $2)\")>]\r\n    member _.Combine(p1: JS.Promise<unit>, p2: JS.Promise<'T>): JS.Promise<'T> = jsNative\r\n\r\n    member _.For(seq: seq<'T>, body: 'T -> JS.Promise<unit>): JS.Promise<unit> =\r\n        // (lift (), seq)\r\n        // ||> Seq.fold (fun p a ->\r\n        //     bind (fun () -> body a) p)\r\n        let mutable p = lift ()\r\n        for a in seq do\r\n            p <- p |> bind (fun () -> body a)\r\n        p\r\n\r\n    [<Emit(\"$1.then($2)\")>]\r\n    member _.For(p: JS.Promise<'T1>, f: 'T1 -> JS.Promise<'T2>): JS.Promise<'T2> = jsNative\r\n\r\n    member this.While(guard: unit -> bool, p: JS.Promise<unit>): JS.Promise<unit> =\r\n        if guard()\r\n        then bind (fun () -> this.While(guard, p)) p\r\n        else lift()\r\n\r\n    [<Emit(\"Promise.resolve($1)\")>]\r\n    member _.Return(a: 'T): JS.Promise<'T> = jsNative\r\n\r\n    [<Emit(\"$1\")>]\r\n    member _.ReturnFrom(p: JS.Promise<'T>): JS.Promise<'T> = jsNative\r\n\r\n    [<Emit(\"Promise.resolve()\")>]\r\n    member _.Zero(): JS.Promise<unit> = jsNative\r\n\r\n    member _.TryFinally(p: JS.Promise<'T>, compensation: unit -> unit): JS.Promise<'T> =\r\n        either (fun (x: 'T) -> compensation(); x) (fun er -> compensation(); raise er) p\r\n\r\n    [<Emit(\"$1.catch($2)\")>]\r\n    member _.TryWith(p: JS.Promise<'T>, catchHandler: exn -> JS.Promise<'T>): JS.Promise<'T> = jsNative\r\n\r\n    // Delay must generate a cold promise-like object that re-runs every time it's called,\r\n    // so we cannot use the JS Promise constructor which is stateful\r\n    member _.Delay(generator: unit -> JS.Promise<'T>): JS.Promise<'T> =\r\n        !!createObj[\r\n            \"then\" ==> fun onSuccess onError ->\r\n                try generator().``then``(onSuccess, onError)\r\n                with er ->\r\n                    if isNull(box onError) then reject er\r\n                    else\r\n                        try onError er |> lift\r\n                        with er -> reject er\r\n            \"catch\" ==> fun onError ->\r\n                try generator().catch(onError)\r\n                with er ->\r\n                    try onError er |> lift\r\n                    with er -> reject er\r\n        ]\r\n\r\n    // Make sure we call `then` because this may be used with \"cold\" fake promises generated by Delay\r\n    member _.Run(p:JS.Promise<'T>): JS.Promise<'T> = p.``then``(id)\r\n\r\n    member this.Using<'T1, 'T2 when 'T1 :> IDisposable>(resource: 'T1, binder: 'T1 -> JS.Promise<'T2>): JS.Promise<'T2> =\r\n        this.TryFinally(binder(resource), fun () -> resource.Dispose())\r\n\r\n    [<Emit(\"Promise.all([$1, $2])\")>]\r\n    member _.MergeSources(a: JS.Promise<'T1>, b: JS.Promise<'T2>): JS.Promise<'T1 * 'T2> = jsNative\r\n\r\n    [<Emit(\"Promise.all([$1, $2, $3])\")>]\r\n    member _.MergeSources3(a: JS.Promise<'T1>, b: JS.Promise<'T2>, c: JS.Promise<'T3>): JS.Promise<'T1 * 'T2 * 'T3> = jsNative\r\n\r\n    [<Emit(\"Promise.all([$1, $2, $3, $4])\")>]\r\n    member _.MergeSources4(a: JS.Promise<'T1>, b: JS.Promise<'T2>, c: JS.Promise<'T3>, d: JS.Promise<'T4>): JS.Promise<'T1 * 'T2 * 'T3 * 'T4> = jsNative\r\n\r\n    [<Emit(\"Promise.all([$1, $2, $3, $4, $5])\")>]\r\n    member _.MergeSources5(a: JS.Promise<'T1>, b: JS.Promise<'T2>, c: JS.Promise<'T3>, d: JS.Promise<'T4>, e: JS.Promise<'T5>): JS.Promise<'T1 * 'T2 * 'T3 * 'T4 * 'T5> = jsNative\r\n\r\n    [<Emit(\"Promise.all([$1, $2, $3, $4, $5, $6])\")>]\r\n    member _.MergeSources6(a: JS.Promise<'T1>, b: JS.Promise<'T2>, c: JS.Promise<'T3>, d: JS.Promise<'T4>, e: JS.Promise<'T5>, f: JS.Promise<'T6>): JS.Promise<'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6> = jsNative\r\n\r\n//    member _.BindReturn(y: JS.Promise<'T1>, f) = map f y\r\n\r\n    [<Emit(\"Promise.all([$1,$2]).then(([a,b]) => $3(a,b))\")>]\r\n    [<CustomOperation(\"andFor\", IsLikeZip=true)>]\r\n    member _.Merge(a: JS.Promise<'T1>, b: JS.Promise<'T2>, [<ProjectionParameter>] resultSelector : 'T1 -> 'T2 -> 'R): JS.Promise<'R> = jsNative\r\n","[<AutoOpen>]\r\nmodule PromiseImpl\r\n\r\nlet promise = Promise.PromiseBuilder()","namespace Fable.React\r\n\r\nopen Fable.Core\r\nopen Fable.Core.JsInterop\r\nopen Browser\r\nopen Props\r\n\r\n#if !FABLE_COMPILER\r\ntype HTMLNode =\r\n    | Text of string\r\n    | RawText of string\r\n    | Node of string * IProp seq * ReactElement seq\r\n    | List of ReactElement seq\r\n    | Empty\r\nwith interface ReactElement\r\n\r\ntype ServerElementType =\r\n    | Tag\r\n    | Fragment\r\n    | Component\r\n\r\ntype ReactElementTypeWrapper<'P> =\r\n    | Comp of obj\r\n    | Fn of ('P -> ReactElement)\r\n    | HtmlTag of string\r\n    interface ReactElementType<'P>\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule ServerRendering =\r\n    let [<Literal>] private ChildrenName = \"children\"\r\n\r\n    let private createServerElementPrivate(tag: obj, props: obj, children: ReactElement seq, elementType: ServerElementType) =\r\n        match elementType with\r\n        | ServerElementType.Tag ->\r\n            HTMLNode.Node (string tag, props :?> IProp seq, children) :> ReactElement\r\n        | ServerElementType.Fragment ->\r\n            HTMLNode.List children :> ReactElement\r\n        | ServerElementType.Component ->\r\n            let tag = tag :?> System.Type\r\n            let comp = System.Activator.CreateInstance(tag, props)\r\n            let childrenProp = tag.GetProperty(ChildrenName)\r\n            childrenProp.SetValue(comp, children |> Seq.toArray)\r\n            let render = tag.GetMethod(\"render\")\r\n            render.Invoke(comp, null) :?> ReactElement\r\n\r\n    let private createServerElementByFnPrivate(f, props, children) =\r\n        let propsType = props.GetType()\r\n        let props =\r\n            if propsType.GetProperty (ChildrenName) |> isNull then\r\n                props\r\n            else\r\n                let values = ResizeArray<obj> ()\r\n                let properties = propsType.GetProperties()\r\n                for p in properties do\r\n                    if p.Name = ChildrenName then\r\n                        values.Add (children |> Seq.toArray)\r\n                    else\r\n                        values.Add (FSharp.Reflection.FSharpValue.GetRecordField(props, p))\r\n                FSharp.Reflection.FSharpValue.MakeRecord(propsType, values.ToArray()) :?> 'P\r\n        f props\r\n\r\n    // In most cases these functions are inlined (mainly for Fable optimizations)\r\n    // so we create a proxy to avoid inlining big functions every time\r\n\r\n    let createServerElement(tag: obj, props: obj, children: ReactElement seq, elementType: ServerElementType) =\r\n        createServerElementPrivate(tag, props, children, elementType)\r\n\r\n    let createServerElementByFn(f, props, children) =\r\n        createServerElementByFnPrivate(f, props, children)\r\n#endif\r\n\r\n[<RequireQualifiedAccess>]\r\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\r\nmodule ReactElementType =\r\n    let inline ofComponent<'comp, 'props, 'state when 'comp :> Component<'props, 'state>> : ReactElementType<'props> =\r\n#if FABLE_REPL_LIB\r\n        failwith \"Cannot create React components from types in Fable REPL\"\r\n#else\r\n#if FABLE_COMPILER\r\n        jsConstructor<'comp> |> unbox\r\n#else\r\n        Comp (typeof<'comp>) :> _\r\n#endif\r\n#endif\r\n\r\n    let inline ofFunction<'props> (f: 'props -> ReactElement): ReactElementType<'props> =\r\n#if FABLE_COMPILER\r\n        f |> unbox\r\n#else\r\n        Fn f :> _\r\n#endif\r\n\r\n    let inline ofHtmlElement<'props> (name: string): ReactElementType<'props> =\r\n#if FABLE_COMPILER\r\n        unbox name\r\n#else\r\n        HtmlTag name :> ReactElementType<'props>\r\n#endif\r\n\r\n    /// Create a ReactElement to be rendered from an element type, props and children\r\n    let inline create<'props> (comp: ReactElementType<'props>) (props: 'props) (children: ReactElement seq): ReactElement =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.createElement(comp, props, children)\r\n#else\r\n        match (comp :?> ReactElementTypeWrapper<'props>) with\r\n        | Comp obj -> ServerRendering.createServerElement(obj, props, children, ServerElementType.Component)\r\n        | Fn f -> ServerRendering.createServerElementByFn(f, props, children)\r\n        | HtmlTag obj -> ServerRendering.createServerElement(obj, props, children, ServerElementType.Tag)\r\n#endif\r\n\r\n    /// React.memo is a higher order component. It’s similar to React.PureComponent but for function components instead of classes.\r\n    /// If your function component renders the same result given the same props, you can wrap it in a call to React.memo.\r\n    /// React will skip rendering the component, and reuse the last rendered result.\r\n    /// By default it will only shallowly compare complex objects in the props object. If you want control over the comparison, you can use `memoWith`.\r\n    let memo<'props> (render: 'props -> ReactElement) =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.memo(render, unbox null)\r\n#else\r\n        ofFunction render\r\n#endif\r\n\r\n    /// React.memo is a higher order component. It’s similar to React.PureComponent but for function components instead of classes.\r\n    /// If your function renders the same result given the \"same\" props (according to `areEqual`), you can wrap it in a call to React.memo.\r\n    /// React will skip rendering the component, and reuse the last rendered result.\r\n    /// By default it will only shallowly compare complex objects in the props object. If you want control over the comparison, you can use `memoWith`.\r\n    /// This version allow you to control the comparison used instead of the default shallow one by provide a custom comparison function.\r\n    let memoWith<'props> (areEqual: 'props -> 'props -> bool) (render: 'props -> ReactElement) =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.memo(render, areEqual)\r\n#else\r\n        ofFunction render\r\n#endif\r\n\r\n\r\n[<AutoOpen>]\r\nmodule Helpers =\r\n    [<System.Obsolete(\"Use ReactBindings.React.createElement\")>]\r\n    let inline createElement(comp: obj, props: obj, [<ParamList>] children: ReactElement seq): ReactElement =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.createElement(comp, props, children)\r\n#else\r\n        HTMLNode.Empty :> _\r\n#endif\r\n\r\n    /// Instantiate a component from a type inheriting React.Component\r\n    /// Example: `ofType<MyComponent,_,_> { myProps = 5 } []`\r\n    let inline ofType<'T,'P,'S when 'T :> Component<'P,'S>> (props: 'P) (children: ReactElement seq): ReactElement =\r\n        ReactElementType.create ReactElementType.ofComponent<'T,_,_> props children\r\n\r\n    [<System.Obsolete(\"Use ofType\")>]\r\n    let inline com<'T,'P,'S when 'T :> Component<'P,'S>> (props: 'P) (children: ReactElement seq): ReactElement =\r\n        ofType<'T, 'P, 'S> props children\r\n\r\n    let inline ofFunction<'P> (f: 'P -> ReactElement) (props: 'P) (children: ReactElement seq): ReactElement =\r\n        ReactElementType.create (ReactElementType.ofFunction f) props children\r\n\r\n    /// Instantiate an imported React component. The first two arguments must be string literals, \"default\" can be used for the first one.\r\n    /// Example: `ofImport \"Map\" \"leaflet\" { x = 10; y = 50 } []`\r\n    let inline ofImport<'P> (importMember: string) (importPath: string) (props: 'P) (children: ReactElement seq): ReactElement =\r\n#if FABLE_REPL_LIB\r\n        failwith \"Cannot import React components in Fable REPL\"\r\n#else\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.createElement(import importMember importPath, props, children)\r\n#else\r\n        failwith \"Cannot import React components in .NET\"\r\n#endif\r\n#endif\r\n\r\n#if FABLE_COMPILER\r\n    [<Emit(\"typeof $0 === 'function'\")>]\r\n    let private isFunction (x: obj): bool = jsNative\r\n\r\n    [<Emit(\"typeof $0 === 'object' && !$0[Symbol.iterator]\")>]\r\n    let private isNonEnumerableObject (x: obj): bool = jsNative\r\n#endif\r\n\r\n    /// Normal structural F# comparison, but ignores top-level functions (e.g. Elmish dispatch).\r\n    /// Can be used e.g. with the `FunctionComponent.Of` `memoizeWith` parameter.\r\n    let equalsButFunctions (x: 'a) (y: 'a) =\r\n#if FABLE_COMPILER\r\n        if obj.ReferenceEquals(x, y) then\r\n            true\r\n        elif isNonEnumerableObject x && not(isNull(box y)) then\r\n            let keys = JS.Constructors.Object.keys x\r\n            let length = keys.Count\r\n            let mutable i = 0\r\n            let mutable result = true\r\n            while i < length && result do\r\n                let key = keys.[i]\r\n                i <- i + 1\r\n                let xValue = x?(key)\r\n                result <- isFunction xValue || xValue = y?(key)\r\n            result\r\n        else\r\n            (box x) = (box y)\r\n#else\r\n        // Server rendering, won't be actually used\r\n        // Avoid `x = y` because it will force 'a to implement structural equality\r\n        false\r\n#endif\r\n\r\n    /// Comparison similar to default React.memo, but ignores functions (e.g. Elmish dispatch).\r\n    /// Performs a memberwise comparison where value types and strings are compared by value,\r\n    /// and other types by reference.\r\n    /// Can be used e.g. with the `FunctionComponent.Of` `memoizeWith` parameter.\r\n    let memoEqualsButFunctions (x: 'a) (y: 'a) =\r\n#if FABLE_COMPILER\r\n        if obj.ReferenceEquals(x, y) then\r\n            true\r\n        elif isNonEnumerableObject x && not(isNull(box y)) then\r\n            let keys = JS.Constructors.Object.keys x\r\n            let length = keys.Count\r\n            let mutable i = 0\r\n            let mutable result = true\r\n            while i < length && result do\r\n                let key = keys.[i]\r\n                i <- i + 1\r\n                let xValue = x?(key)\r\n                result <- isFunction xValue || obj.ReferenceEquals(xValue, y?(key))\r\n            result\r\n        else\r\n            false\r\n#else\r\n        // Server rendering, won't be actually used\r\n        // Avoid `x = y` because it will force 'a to implement structural equality\r\n        false\r\n#endif\r\n\r\n    [<System.Obsolete(\"Use FunctionComponent.Of with memoizeWith\")>]\r\n    let memoBuilder<'props> (name: string) (render: 'props -> ReactElement) : 'props -> ReactElement =\r\n#if FABLE_COMPILER\r\n        render?displayName <- name\r\n#endif\r\n        let memoType = ReactElementType.memo render\r\n        fun props ->\r\n            ReactElementType.create memoType props []\r\n\r\n    [<System.Obsolete(\"Use FunctionComponent.Of with memoizeWith\")>]\r\n    let memoBuilderWith<'props> (name: string) (areEqual: 'props -> 'props -> bool) (render: 'props -> ReactElement) : 'props -> ReactElement =\r\n#if FABLE_COMPILER\r\n        render?displayName <- name\r\n#endif\r\n        let memoType = ReactElementType.memoWith areEqual render\r\n        fun props ->\r\n            ReactElementType.create memoType props []\r\n\r\n    [<System.Obsolete(\"Use ReactElementType.create\")>]\r\n    let inline from<'P> (com: ReactElementType<'P>) (props: 'P) (children: ReactElement seq): ReactElement =\r\n        ReactElementType.create com props children\r\n\r\n    /// Alias of `ofString`\r\n    let inline str (s: string): ReactElement =\r\n#if FABLE_COMPILER\r\n        unbox s\r\n#else\r\n        HTMLNode.Text s :> ReactElement\r\n#endif\r\n\r\n    /// Cast a string to a React element (erased in runtime)\r\n    let inline ofString (s: string): ReactElement =\r\n        str s\r\n        \r\n    /// The equivalent of `sprintf (...) |> str`\r\n    let inline strf format =\r\n        Printf.kprintf str format\r\n\r\n    /// Cast an option value to a React element (erased in runtime)\r\n    let inline ofOption (o: ReactElement option): ReactElement =\r\n        match o with Some o -> o | None -> null // Option.toObj(o)\r\n\r\n    [<System.Obsolete(\"Use ofOption\")>]\r\n    let opt (o: ReactElement option): ReactElement =\r\n        ofOption o\r\n\r\n    /// Cast an int to a React element (erased in runtime)\r\n    let inline ofInt (i: int): ReactElement =\r\n#if FABLE_COMPILER\r\n        unbox i\r\n#else\r\n        HTMLNode.RawText (string i) :> ReactElement\r\n#endif\r\n\r\n    /// Cast a float to a React element (erased in runtime)\r\n    let inline ofFloat (f: float): ReactElement =\r\n#if FABLE_COMPILER\r\n        unbox f\r\n#else\r\n        HTMLNode.RawText (string f) :> ReactElement\r\n#endif\r\n\r\n    /// Returns a list **from .render() method**\r\n    let inline ofList (els: ReactElement list): ReactElement =\r\n#if FABLE_COMPILER\r\n        unbox(List.toArray els)\r\n#else\r\n        HTMLNode.List els :> ReactElement\r\n#endif\r\n\r\n    /// Returns an array **from .render() method**\r\n    let inline ofArray (els: ReactElement array): ReactElement =\r\n#if FABLE_COMPILER\r\n        unbox els\r\n#else\r\n        HTMLNode.List els :> ReactElement\r\n#endif\r\n\r\n    /// A ReactElement when you don't want to render anything (null in javascript)\r\n    let nothing: ReactElement =\r\n#if FABLE_COMPILER\r\n        null\r\n#else\r\n        HTMLNode.Empty :> ReactElement\r\n#endif\r\n\r\n    /// Instantiate a DOM React element\r\n    let inline domEl (tag: string) (props: IHTMLProp seq) (children: ReactElement seq): ReactElement =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.createElement(tag, keyValueList CaseRules.LowerFirst props, children)\r\n#else\r\n        ServerRendering.createServerElement(tag, (props |> Seq.cast<IProp>), children, ServerElementType.Tag)\r\n#endif\r\n\r\n    /// Instantiate a DOM React element (void)\r\n    let inline voidEl (tag: string) (props: IHTMLProp seq) : ReactElement =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.createElement(tag, keyValueList CaseRules.LowerFirst props, [])\r\n#else\r\n        ServerRendering.createServerElement(tag, (props |> Seq.cast<IProp>), [], ServerElementType.Tag)\r\n#endif\r\n\r\n    /// Instantiate an SVG React element\r\n    let inline svgEl (tag: string) (props: IProp seq) (children: ReactElement seq): ReactElement =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.createElement(tag, keyValueList CaseRules.LowerFirst props, children)\r\n#else\r\n        ServerRendering.createServerElement(tag, (props |> Seq.cast<IProp>), children, ServerElementType.Tag)\r\n#endif\r\n\r\n    /// Instantiate a React fragment\r\n    let inline fragment (props: IFragmentProp seq) (children: ReactElement seq): ReactElement =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.createElement(ReactBindings.React.Fragment, keyValueList CaseRules.LowerFirst props, children)\r\n#else\r\n        ServerRendering.createServerElement(typeof<Fragment>, (props |> Seq.cast<IProp>), children, ServerElementType.Fragment)\r\n#endif\r\n\r\n    /// Accepts a context value to be passed to consuming components that are descendants of this Provider.\r\n    /// One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.\r\n    /// Important: In SSR, this is ignored, and the DEFAULT value is consumed!\r\n    /// More info at https://reactjs.org/docs/context.html#contextprovider\r\n    let inline contextProvider (ctx: IContext<'T>) (value: 'T) (children: ReactElement seq): ReactElement =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.createElement(ctx?Provider, createObj [\"value\" ==> value], children)\r\n#else\r\n        fragment [] children\r\n#endif\r\n\r\n    /// Consumes a context value, either from the nearest parent in the tree, or from the default value.\r\n    /// Important: in SSR, this will always consume the context DEFAULT value!\r\n    /// More info at https://reactjs.org/docs/context.html#contextconsumer\r\n    let inline contextConsumer (ctx: IContext<'T>) (children: 'T -> ReactElement): ReactElement =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.createElement(ctx?Consumer, null, [!!children])\r\n#else\r\n        let ctx = ctx :?> ISSRContext<_>\r\n        fragment [] [children(ctx.DefaultValue)]\r\n#endif\r\n\r\n    /// Creates a Context object. When React renders a component that subscribes to this Context\r\n    /// object it will read the current context value from the closest matching Provider above it\r\n    /// in the tree. More info at https://reactjs.org/docs/context.html#reactcreatecontext\r\n    let inline createContext (defaultValue: 'T): IContext<'T> =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.createContext(defaultValue)\r\n#else\r\n        upcast { new ISSRContext<_> with member __.DefaultValue = defaultValue }\r\n#endif\r\n\r\n    /// To be used in constructors of class components\r\n    /// (for function components use `useRef` hook)\r\n    let inline createRef (initialValue: 'T): IRefValue<'T> =\r\n#if FABLE_COMPILER\r\n        ReactBindings.React.createRef(initialValue)\r\n#else\r\n        { new IRefValue<_> with\r\n            member __.current with get() = initialValue and set _ = () }\r\n#endif\r\n\r\n    // Class list helpers\r\n    let classBaseList baseClass classes =\r\n        classes\r\n        |> Seq.choose (fun (name, condition) ->\r\n            if condition && not(System.String.IsNullOrEmpty(name)) then Some name\r\n            else None)\r\n        |> Seq.fold (fun state name -> state + \" \" + name) baseClass\r\n        |> ClassName\r\n\r\n    let classList classes = classBaseList \"\" classes\r\n\r\n    /// Finds a DOM element by its ID and mounts the React element there\r\n    /// Important: Not available in SSR\r\n    let inline mountById (domElId: string) (reactEl: ReactElement): unit =\r\n#if FABLE_COMPILER\r\n        ReactDom.render(reactEl, document.getElementById(domElId))\r\n#else\r\n        failwith \"mountById is not available for SSR\"\r\n#endif\r\n    /// Finds the first DOM element matching a CSS selector and mounts the React element there\r\n    /// Important: Not available in SSR\r\n    let inline mountBySelector (domElSelector: string) (reactEl: ReactElement): unit =\r\n#if FABLE_COMPILER\r\n        ReactDom.render(reactEl, document.querySelector(domElSelector))\r\n#else\r\n        failwith \"mountBySelector is not available for SSR\"\r\n#endif\r\n","module Utils\r\n\r\nopen Fable.Core\r\nopen Fable.Core.JsInterop\r\nopen Fable.React\r\nopen Fable.React.Props\r\nopen Common\r\nopen Browser.Dom\r\n\r\nlet onClickDispatch dispatch msg = OnClick (fun _ -> dispatch msg)\r\n\r\nlet mdiIcon name = i [ClassName <| \"mdi mdi-\" + name] []\r\n\r\nlet mdiIconLrg name = i [ClassName <| \"mdi mdi-24px mdi-\" + name] []\r\n\r\nlet getMimeType format =\r\n    match format with\r\n    | \"mp4\" -> \"video/mp4\"\r\n    | _ -> \"unknown\"\r\n\r\nlet emoji emoji = span [ClassName \"emoji\"] [str emoji]\r\n\r\nlet emojisFromText (text :string) =\r\n    text.Split(' ') |> Array.choose (fun name ->\r\n        Emojis.charByName |> Map.tryFind name |> Option.map (fun c -> span [ClassName <| \"emoji emoji-\" + name] [str c]))\r\n            |> Array.toList\r\n\r\nlet strf string = str (sprintf string)\r\n\r\nlet niceAddress (address :string) =\r\n    address.Substring(0, 6) + \" ... \" + address.Substring(36)\r\n\r\nlet niceTimestamp (timestamp :int64) =\r\n    let date = System.DateTimeOffset.FromUnixTimeSeconds(timestamp).DateTime\r\n    let now = System.DateTime.UtcNow\r\n    let ago = (now - date)\r\n    match ago with\r\n    | _ when ago.TotalMinutes < 1.0 -> sprintf \"%is\" (int ago.TotalSeconds)\r\n    | _ when ago.TotalHours < 1.0 -> sprintf \"%im\" (int ago.TotalMinutes)\r\n    | _ when ago.TotalDays < 1.0 -> sprintf \"%ih\" (int ago.TotalHours)\r\n    | _ when ago.TotalDays < 7.0 -> sprintf \"%id\" (int ago.TotalDays)\r\n    | _ -> sprintf \"%iw\" (int (ago.TotalDays / 7.0))\r\n\r\nlet isNullOrEmpty = System.String.IsNullOrEmpty\r\n\r\nlet jazziconForAddress width (address :string) =\r\n    let seed = System.Int32.Parse(address.Substring(2, 8), System.Globalization.NumberStyles.HexNumber)\r\n    Imports.ReactJazzicon.jazzicon [Imports.ReactJazzicon.Diameter width; Imports.ReactJazzicon.Seed seed] []\r\n\r\nlet bigLoading = div [ClassName \"big-loading\"] [div [ClassName \"lds-dual-ring\"] []]\r\n\r\nlet errorView = div [ClassName \"error-view\"] [str \"Something went wrong, please try again later\"]\r\n\r\nlet getSimpleGradient (hexColors :string[]) = sprintf \"linear-gradient(to right, %s)\" (System.String.Join(\", \", hexColors))\r\n\r\nlet getBackToBackGradient (hexColors :string[]) =\r\n    let colors = Array.append hexColors (hexColors |> Array.truncate (hexColors.Length - 1) |> Array.rev)\r\n    getSimpleGradient colors\r\n\r\nlet getGradientBackgroundStyle (hexColors :string[]) isDarkMode className =\r\n    let color2 = hexColors.[0] |> ColorUtils.fromHexStr\r\n    let color1 = hexColors |> Array.last |> ColorUtils.fromHexStr\r\n    let (bh, bs, _) = color2 |> ColorUtils.fromRgb\r\n    let backgroundColor = ColorUtils.toRgb (bh, bs * 0.3, if isDarkMode then 0.1 else 0.97)\r\n    let linearGradient direction color1 start1 color2 start2 =\r\n        let (r1, g1, b1, a1) = color1\r\n        let (r2, g2, b2, a2) = color2\r\n        sprintf \"linear-gradient(%s, rgba(%i, %i, %i, %f) %f%%, rgba(%i, %i, %i, %f) %f%%)\"\r\n            direction r1 g1 b1 a1 start1 r2 g2 b2 a2 start2\r\n    let radialGradient (x, y) color1 start1 color2 start2 =\r\n        let (r1, g1, b1, a1) = color1\r\n        let (r2, g2, b2, a2) = color2\r\n        sprintf \"radial-gradient(ellipse at %f%% %f%%, rgba(%i, %i, %i, %f) %f%%, rgba(%i, %i, %i, %f) %f%%)\"\r\n            x y r1 g1 b1 a1 start1 r2 g2 b2 a2 start2\r\n    let (rback, gback, bback) = backgroundColor\r\n    let (r1, g1, b1) = color1\r\n    let (r2, g2, b2) = color2\r\n    let fadeBottom = linearGradient \"to bottom\" (rback, gback, bback, 1.0) 0.0 (255, 255, 255, 0.0) 90.0\r\n    let fadeTop = linearGradient \"to top\" (rback, gback, bback, 1.0) 0.0 (255, 255, 255, 0.0) 90.0\r\n    let bro, tlo =\r\n        if isDarkMode then 0.65, 0.35 else 0.3, 0.35\r\n    let radBotRight = radialGradient (100.0, 75.0) (r1, g1, b1, bro) 0.0 (rback, gback, bback, 0.2) 85.0\r\n    let radTopLeft = radialGradient (0.0, 25.0) (r2, g2, b2, tlo) 0.0 (rback, gback, bback, 0.3) 65.0\r\n    let backgroundColorStr = sprintf \"rgb(%i, %i, %i)\" rback gback bback\r\n    let centerFade = if isDarkMode then \"rgba(22, 22, 22, 0.9)\" else \"rgba(244, 244, 244, 0.9)\"\r\n    style [] [str (sprintf \".%s { background-size: 100vw 100vh; background-color: %s; background-image: linear-gradient(to right, rgba(0, 0, 0, 0) 25%%, %s 40%%, %s 60%%, rgba(0, 0, 0, 0) 75%%), %s, %s, %s, %s; background-blend-mode: normal, normal, normal, normal, normal }\" className backgroundColorStr backgroundColorStr centerFade fadeBottom fadeTop radBotRight radTopLeft)]\r\n\r\nlet getFormatName =\r\n    function\r\n    | \"svg\" -> \"SVG\"\r\n    | \"png\" -> \"PNG\"\r\n    | \"gif\" -> \"GIF\"\r\n    | \"jpg\" -> \"JPEG\"\r\n    | \"webp\" -> \"WebP\"\r\n    | _ -> \"Image\"\r\nlet getStorageName =\r\n    function\r\n    | \"onchain\" -> \"On-chain\"\r\n    | \"ipfs\" -> \"IPFS\"\r\n    | _ -> \"Server\"\r\nlet getVideoFormatName =\r\n    function\r\n    | \"mp4\" -> \"MP4\"\r\n    | _ -> \"Video\"\r\n\r\nlet getMediaText =\r\n    function\r\n    | { display = \"image\"; storage = \"onchain\" } -> \" On-chain Image\"\r\n    | { display = \"image\"; format = _; storage = \"ipfs\" } -> \" Image on IPFS\"\r\n    | { display = \"video\"; format = _; storage = \"ipfs\" } -> \" Video on IPFS\"\r\n    | { display = \"video\" } -> \"Video\"\r\n    | { display = \"image\" } -> \"Image\"\r\n    | _ -> \"\"\r\n\r\nlet getMediaElement display =\r\n    let txt = getMediaText display\r\n    match display with\r\n    | { storage = \"onchain\" } ->\r\n        [span [ClassName \"emoji mode-aware-text\"] [str \"🔗\"]; span [] [str txt]]\r\n    | { storage = \"ipfs\" } ->\r\n        [span [ClassName \"emoji mode-aware-text\"] [str \"🌎\"]; span [] [str txt]]\r\n    | _ -> [span [] [str txt]]\r\n\r\nlet useScrollTo () =\r\n    let ref :IRefValue<Browser.Types.Element option> = Hooks.useRef None\r\n    let shouldScrollTo = Hooks.useState false\r\n    Hooks.useEffect(fun () ->\r\n        match ref.current with\r\n        | Some element when shouldScrollTo.current ->\r\n            element?scrollIntoView()\r\n            shouldScrollTo.update(false)\r\n        | _ -> ())\r\n    ref, fun () -> shouldScrollTo.update(true)\r\n","module ViewComponents\r\n\r\nopen Fable.Core\r\nopen Fable.Core.JsInterop\r\nopen Fable.React\r\nopen Fable.React.Props\r\nopen Common\r\nopen System.Globalization\r\nopen Imports.ReactMarkdown\r\nopen Imports.ReactJazzicon\r\nopen Imports\r\nopen Utils\r\nopen Feliz.UseDeferred\r\nopen Browser.Dom\r\nopen Browser.Types\r\nopen System.Collections.Generic\r\nopen Web3TreeDapp\r\n\r\n// Page Modal\r\n// --------\r\ntype PageModalProps =\r\n    { active: bool; children: ReactElement list }\r\n\r\nlet PageModal =\r\n    FunctionComponent.Of ((fun (props :PageModalProps) ->\r\n        div [classBaseList \"page-modal\" [\"active\", props.active]] props.children\r\n    ), \"PageModal\", equalsButFunctions)\r\n\r\n// Connect Modal\r\n// -----------\r\n\r\ntype ConnectModalControls =\r\n    { show: unit -> unit\r\n      hide: unit -> unit }\r\n\r\nlet connectModalControlsContext :IContext<ConnectModalControls option> = createContext None\r\n\r\ntype ConnectModalProps =\r\n    { active: bool }\r\n\r\nlet ConnectModal =\r\n    FunctionComponent.Of((fun (props :ConnectModalProps) ->\r\n        let web3 = useWeb3React()\r\n        let modalControls :ConnectModalControls option = Hooks.useContext connectModalControlsContext\r\n        PageModal\r\n            { active = props.active\r\n              children =\r\n                [div [ClassName \"connect-modal\"]\r\n                    [h1 [] [span [] [str \"Connect a wallet\"]; a [OnClick (fun _ -> modalControls.Value.hide())] [mdiIcon \"close\"]]\r\n                     button [OnClick (fun _ -> web3.activate(Injected); modalControls.Value.hide()); ClassName \"button\"] [div [] [str \"Metamask\"]; div [] [img [Src \"/img/metamask.png\"]]]\r\n                     button [OnClick (fun _ -> web3.activate(WalletConnect); modalControls.Value.hide()); ClassName \"button\"] [div [] [str \"Wallet Connect\"]; div [] [img [Src \"/img/walletConnect.svg\"]]]\r\n                     button [OnClick (fun _ -> web3.activate(CoinbaseWallet); modalControls.Value.hide()); ClassName \"button\"] [div [] [str \"Coinbase Wallet\"]; div [] [img [Src \"/img/coinbaseWallet.svg\"]]]]]}\r\n    ), \"ConnectModal\", equalsButFunctions)\r\n\r\n// Connect Button\r\n// ---------\r\ntype ConnectButtonProps =\r\n    { className: string; children: ReactElement list }\r\n\r\nlet ConnectButton =\r\n    FunctionComponent.Of((fun (props :ConnectButtonProps) ->\r\n        let modalControls :ConnectModalControls option = Hooks.useContext connectModalControlsContext\r\n        button [OnClick (fun _ -> match modalControls with | None -> () | Some controls -> controls.show()); ClassName props.className] (props.children)\r\n    ), \"ConnectButton\", equalsButFunctions)\r\n","namespace Feliz\n\nopen System\nopen System.ComponentModel\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen Browser.Types\n\nmodule internal ReactInterop =\n    let useDebugValueWithFormatter<'t>(value: 't, formatter: 't -> string) : unit = import \"useDebugValue\" \"./ReactInterop.js\"\n    let useEffect (effect: obj) : unit =  import \"useEffect\" \"./ReactInterop.js\"\n    let useEffectWithDeps (effect:  obj) (deps: obj) : unit = import \"useEffectWithDeps\" \"./ReactInterop.js\"\n    let useLayoutEffect (effect: obj) : unit =  import \"useLayoutEffect\" \"./ReactInterop.js\"\n    let useLayoutEffectWithDeps (effect:  obj) (deps: obj) : unit = import \"useLayoutEffectWithDeps\" \"./ReactInterop.js\"\n\n[<EditorBrowsable(EditorBrowsableState.Never);Erase>]\n[<RequireQualifiedAccess>]\nmodule Helpers =\n    let inline optDispose (disposeOption: #IDisposable option) =\n        { new IDisposable with member _.Dispose () = disposeOption |> Option.iter (fun d -> d.Dispose()) }\n\ntype internal Internal() =\n    static let propsWithKey (withKey: ('props -> string) option) props =\n        match withKey with\n        | Some f ->\n            props?key <- f props\n            props\n        | None -> props\n    static member\n        functionComponent\n        (\n            renderElement: 'props -> ReactElement,\n            ?name: string,\n            ?withKey: 'props -> string\n        )\n        : 'props -> Fable.React.ReactElement =\n            name |> Option.iter (fun name -> renderElement?displayName <- name)\n            #if FABLE_COMPILER_3\n            Browser.Dom.console.warn(\"Feliz: using React.functionComponent in Fable 3 is obsolete, please consider using the [<ReactComponent>] attribute instead which makes Feliz output better Javascript code that is compatible with react-refresh\")\n            #endif\n            fun props ->\n                let props = props |> propsWithKey withKey\n                Interop.reactApi.createElement(renderElement, props)\n    static member\n        memo\n        (\n            renderElement: 'props -> ReactElement,\n            ?name: string,\n            ?areEqual: 'props -> 'props -> bool,\n            ?withKey: 'props -> string\n        )\n        : 'props -> Fable.React.ReactElement =\n            let memoElementType = Interop.reactApi.memo(renderElement, (defaultArg areEqual (unbox null)))\n            name |> Option.iter (fun name -> renderElement?displayName <- name)\n            fun props ->\n                let props = props |> propsWithKey withKey\n                Interop.reactApi.createElement(memoElementType, props)\n\ntype React =\n    /// Creates a disposable instance by providing the implementation of the dispose member.\n    static member createDisposable(dispose: unit -> unit) =\n        { new IDisposable with member _.Dispose() = dispose() }\n\n    /// The `React.fragment` component lets you return multiple elements in your `render()` method without creating an additional DOM element.\n    static member inline fragment xs = Fable.React.Helpers.fragment [] xs\n\n    /// The `React.fragment` component lets you return multiple elements in your `render()` method without creating an additional DOM element.\n    static member inline keyedFragment(key: int, xs) = Fable.React.Helpers.fragment [ !!(\"key\", key) ] xs\n    /// The `React.fragment` component lets you return multiple elements in your `render()` method without creating an additional DOM element.\n    static member inline keyedFragment(key: string, xs) = Fable.React.Helpers.fragment [ !!(\"key\", key) ] xs\n    /// The `React.fragment` component lets you return multiple elements in your `render()` method without creating an additional DOM element.\n    static member inline keyedFragment(key: System.Guid, xs) = Fable.React.Helpers.fragment [ !!(\"key\", string key) ] xs\n    /// Placeholder empty React element to be used when importing external React components with the [<ReactComponent>] attribute.\n    static member inline imported() = Html.none\n    /// The `useState` hook that creates a state variable for React function components from an initialization function.\n    [<Hook>]\n    static member useState<'t>(initializer: unit -> 't) = Interop.reactApi.useState<unit -> 't,'t>(initializer)\n\n    /// Accepts a reducer and returns the current state paired with a dispatch.\n    [<Hook>]\n    static member useReducer(update, initialState) = Interop.reactApi.useReducer update initialState\n\n    /// The `useEffect` hook that creates a disposable effect for React function components.\n    /// This effect has no dependencies which means the effect is re-executed on every re-render.\n    /// To make the effect run once (for example you subscribe once to web sockets) then provide an empty array\n    /// for the dependencies: `React.useEffect(disposableEffect, [| |])`.\n    [<Hook>]\n    static member useEffect(effect: unit -> #IDisposable) : unit = ReactInterop.useEffect(effect)\n    /// The `useEffect` hook that creates a disposable effect for React function components.\n    /// This effect has no dependencies which means the effect is re-executed on every re-render.\n    /// To make the effect run once (for example you subscribe once to web sockets) then provide an empty array\n    /// for the dependencies: `React.useEffect(disposableEffect, [| |])`.\n    [<Hook>]\n    static member inline useEffect(effect: unit -> #IDisposable option) = React.useEffect(effect >> Helpers.optDispose)\n    /// The `useEffect` hook that creates a disposable effect for React function components.\n    /// This effect takes an array of *dependencies*.\n    /// Whenever any of these dependencies change, the effect is re-executed. To execute the effect only once,\n    /// you have to explicitly provide an empty array for the dependencies: `React.useEffect(effect, [| |])`.\n    [<Hook>]\n    static member useEffect(effect: unit -> #IDisposable, dependencies: obj []) : unit = ReactInterop.useEffectWithDeps effect dependencies\n    /// The `useEffect` hook that creates a disposable effect for React function components.\n    /// This effect takes an array of *dependencies*.\n    /// Whenever any of these dependencies change, the effect is re-executed. To execute the effect only once,\n    /// you have to explicitly provide an empty array for the dependencies: `React.useEffect(effect, [| |])`.\n    [<Hook>]\n    static member inline useEffect(effect: unit -> #IDisposable option, dependencies: obj []) = React.useEffect(effect >> Helpers.optDispose, dependencies)\n\n    /// The `useLayoutEffect` hook that creates a disposable effect for React function components.\n    /// This effect has no dependencies which means the effect is re-executed on every re-render.\n    /// To make the effect run once (for example you subscribe once to web sockets) then provide an empty array\n    /// for the dependencies: `React.useLayoutEffect(disposableEffect, [| |])`.\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\n    [<Hook>]\n    static member useLayoutEffect(effect: unit -> #IDisposable) : unit = ReactInterop.useLayoutEffect(effect)\n    /// The `useLayoutEffect` hook that creates a disposable effect for React function components.\n    /// This effect has no dependencies which means the effect is re-executed on every re-render.\n    /// To make the effect run once (for example you subscribe once to web sockets) then provide an empty array\n    /// for the dependencies: `React.useLayoutEffect(disposableEffect, [| |])`.\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\n    [<Hook>]\n    static member inline useLayoutEffect(effect: unit -> #IDisposable option) = React.useLayoutEffect(effect >> Helpers.optDispose)\n    /// The `useLayoutEffect` hook that creates a disposable effect for React function components.\n    /// This effect takes an array of *dependencies*.\n    /// Whenever any of these dependencies change, the effect is re-executed. To execute the effect only once,\n    /// you have to explicitly provide an empty array for the dependencies: `React.useLayoutEffect(effect, [| |])`.\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\n    [<Hook>]\n    static member useLayoutEffect(effect: unit -> #IDisposable, dependencies: obj []) : unit = ReactInterop.useLayoutEffectWithDeps effect dependencies\n    /// The `useLayoutEffect` hook that creates a disposable effect for React function components.\n    /// This effect takes an array of *dependencies*.\n    /// Whenever any of these dependencies change, the effect is re-executed. To execute the effect only once,\n    /// you have to explicitly provide an empty array for the dependencies: `React.useLayoutEffect(effect, [| |])`.\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\n    [<Hook>]\n    static member inline useLayoutEffect(effect: unit -> #IDisposable option, dependencies: obj []) =\n        React.useLayoutEffect(effect >> Helpers.optDispose, dependencies)\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\n    /// This effect is executed on every (re)render\n    [<Hook>]\n    static member useLayoutEffect(effect: unit -> unit) =\n        ReactInterop.useLayoutEffect\n            (fun _ ->\n                effect()\n                React.createDisposable(ignore))\n\n    /// The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.\n    [<Hook>]\n    static member useLayoutEffect(effect: unit -> unit, dependencies: obj []) =\n        ReactInterop.useLayoutEffectWithDeps\n            (fun _ ->\n                effect()\n                React.createDisposable(ignore))\n            dependencies\n\n    [<Hook>]\n    static member inline useLayoutEffectOnce(effect: unit -> unit) =\n         React.useLayoutEffect(effect, [| |])\n\n    [<Hook>]\n    static member inline useLayoutEffectOnce(effect: unit -> #IDisposable) =\n        React.useLayoutEffect(effect, [| |])\n\n    [<Hook>]\n    static member inline useLayoutEffectOnce(effect: unit -> #IDisposable option) =\n        React.useLayoutEffect(effect, [| |])\n\n    /// React hook to define and use an effect only once when a function component renders for the first time.\n    /// This is an alias for `React.useEffect(effect, [| |])` which explicitly provides an empty array for the dependencies of the effect which means the effect will only run once.\n    [<Hook>]\n    static member useEffectOnce(effect: unit -> unit) =\n        React.useEffect(effect, [| |])\n\n    /// React hook to define and use a disposable effect only once when a function component renders for the first time.\n    /// This is an alias for `React.useEffect(effect, [| |])` which explicitly provides an empty array for the dependencies of the effect which means the effect will only run once.\n    [<Hook>]\n    static member useEffectOnce(effect: unit -> #IDisposable) =\n        React.useEffect(effect, [| |])\n    /// React hook to define and use a disposable effect only once when a function component renders for the first time.\n    /// This is an alias for `React.useEffect(effect, [| |])` which explicitly provide an empty array for the dependencies of the effect which means the effect will only run once.\n    [<Hook>]\n    static member useEffectOnce(effect: unit -> #IDisposable option) =\n        React.useEffect(effect >> Helpers.optDispose, [| |])\n\n    /// The `useEffect` hook that creates an effect for React function components.\n    /// This effect is executed *every time* the function component re-renders.\n    ///\n    /// To make the effect run only once, write: `React.useEffect(effect, [| |])` which explicitly states\n    /// that this effect has no dependencies and should only run once on initial render.\n    [<Hook>]\n    static member useEffect(effect: unit -> unit) : unit =\n        ReactInterop.useEffect\n            (fun _ ->\n                effect()\n                React.createDisposable(ignore))\n\n    /// The `useEffect` hook that creates an effect for React function components. This effect takes an array of *dependencies*.\n    /// Whenever any of these dependencies change, the effect is re-executed. To execute the effect only once,\n    /// you have to explicitly provide an empty array for the dependencies: `React.useEffect(effect, [| |])`.\n    [<Hook>]\n    static member useEffect(effect: unit -> unit, dependencies: obj []) : unit =\n        ReactInterop.useEffectWithDeps\n            (fun _ ->\n                effect()\n                React.createDisposable(ignore))\n            dependencies\n\n    /// Can be used to display a label for custom hooks in React DevTools.\n    [<Hook>]\n    static member useDebugValue(value: string) =\n        ReactInterop.useDebugValueWithFormatter(value, id)\n\n    /// Can be used to display a label for custom hooks in React DevTools.\n    [<Hook>]\n    static member useDebugValue(value: 't, formatter: 't -> string) =\n        ReactInterop.useDebugValueWithFormatter(value, formatter)\n\n    /// <summary>\n    /// The `useCallback` hook. Returns a memoized callback. Pass an inline callback and an array of dependencies.\n    /// `useCallback` will return a memoized version of the callback that only changes if one of the dependencies has changed.\n    /// </summary>\n    /// <param name='callbackFunction'>A callback function to be memoized.</param>\n    /// <param name='dependencies'>An array of dependencies upon which the callback function depends.\n    /// If not provided, defaults to empty array, representing dependencies that never change.</param>\n    [<Hook>]\n    static member useCallback(callbackFunction: 'a -> 'b, ?dependencies: obj array) =\n        Interop.reactApi.useCallback callbackFunction (defaultArg dependencies [||])\n\n    /// Returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component.\n    ///\n    /// Essentially, useRef is like a container that can hold a mutable value in its .current property.\n    [<Hook>]\n    static member useRef(initialValue) = Interop.reactApi.useRef(initialValue)\n\n    /// A specialized version of React.useRef() that creates a reference to an input element.\n    ///\n    /// Useful for controlling the internal properties and methods of that element, for example to enable focus().\n    [<Hook>]\n    static member useInputRef() : IRefValue<HTMLInputElement option> = React.useRef(None)\n\n    /// A specialized version of React.useRef() that creates a reference to a button element.\n    [<Hook>]\n    static member useButtonRef() : IRefValue<HTMLButtonElement option> = React.useRef(None)\n\n    /// A specialized version of React.useRef() that creates a reference to a generic HTML element.\n    ///\n    /// Useful for controlling the internal properties and methods of that element, for integration with third-party libraries that require a Html element.\n    [<Hook>]\n    static member useElementRef() : IRefValue<HTMLElement option> = React.useRef(None)\n\n    /// <summary>\n    /// The `useMemo` hook. Returns a memoized value. Pass a \"create\" function and an array of dependencies.\n    /// `useMemo` will only recompute the memoized value when one of the dependencies has changed.\n    /// </summary>\n    /// <param name='createFunction'>A create function returning a value to be memoized.</param>\n    /// <param name='dependencies'>An array of dependencies upon which the create function depends.\n    /// If not provided, defaults to empty array, representing dependencies that never change.</param>\n    [<Hook>]\n    static member useMemo(createFunction: unit -> 'a, ?dependencies: obj array) =\n        Interop.reactApi.useMemo createFunction (defaultArg dependencies [||])\n\n    //\n    // React.functionComponent\n    //\n\n    /// <summary>\n    /// Creates a React function component from a function that accepts a \"props\" object and renders a result.\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\n    /// </summary>\n    /// <param name='render'>A render function that returns an element.</param>\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\n    static member functionComponent(render: 'props -> ReactElement, ?withKey: 'props -> string) =\n        Internal.functionComponent(render, ?withKey=withKey)\n\n    /// <summary>\n    /// Creates a React function component from a function that accepts a \"props\" object and renders a result.\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\n    /// </summary>\n    /// <param name='name'>The component name to display in the React dev tools.</param>\n    /// <param name='render'>A render function that returns an element.</param>\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\n    static member functionComponent(name: string, render: 'props -> ReactElement, ?withKey: 'props -> string) =\n        Internal.functionComponent(render, name, ?withKey=withKey)\n\n    /// <summary>\n    /// Creates a React function component from a function that accepts a \"props\" object and renders a result.\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\n    /// </summary>\n    /// <param name='render'>A render function that returns a list of elements.</param>\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\n    static member functionComponent(render: 'props -> #seq<ReactElement>, ?withKey: 'props -> string) =\n        Internal.functionComponent(render >> React.fragment, ?withKey=withKey)\n\n    /// <summary>\n    /// Creates a React function component from a function that accepts a \"props\" object and renders a result.\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\n    /// </summary>\n    /// <param name='render'>A render function that returns a list of elements.</param>\n    /// <param name='name'>The component name to display in the React dev tools.</param>\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\n    static member functionComponent(name: string, render: 'props -> #seq<ReactElement>, ?withKey: 'props -> string) =\n        Internal.functionComponent(render >> React.fragment, name, ?withKey=withKey)\n\n    //\n    // React.memo\n    //\n\n    /// <summary>\n    /// `React.memo` memoizes the result of a function component. Given the same props, React will skip rendering the component, and reuse the last rendered result.\n    /// By default it will only shallowly compare complex objects in the props object. For more control, a custom `areEqual` function can be provided.\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\n    /// </summary>\n    /// <param name='render'>A render function or a React.functionComponent.</param>\n    /// <param name='areEqual'>A custom comparison function to use instead of React's default shallow compare.</param>\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\n    static member memo(render: 'props -> ReactElement, ?withKey: 'props -> string, ?areEqual: 'props -> 'props -> bool) =\n        Internal.memo(render, ?areEqual=areEqual, ?withKey=withKey)\n\n    /// <summary>\n    /// `React.memo` memoizes the result of a function component. Given the same props, React will skip rendering the component, and reuse the last rendered result.\n    /// By default it will only shallowly compare complex objects in the props object. For more control, a custom `areEqual` function can be provided.\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\n    /// </summary>\n    /// <param name='name'>The component name to display in the React dev tools.</param>\n    /// <param name='render'>A render function or a React.functionComponent.</param>\n    /// <param name='areEqual'>A custom comparison function to use instead of React's default shallow compare.</param>\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\n    static member memo(name: string, render: 'props -> ReactElement, ?withKey: 'props -> string, ?areEqual: 'props -> 'props -> bool) =\n        Internal.memo(render, name, ?areEqual=areEqual, ?withKey=withKey)\n\n    /// <summary>\n    /// `React.memo` memoizes the result of a function component. Given the same props, React will skip rendering the component, and reuse the last rendered result.\n    /// By default it will only shallowly compare complex objects in the props object. For more control, a custom `areEqual` function can be provided.\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\n    /// </summary>\n    /// <param name='render'>A render function that returns a list of elements.</param>\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\n    /// <param name='areEqual'>A custom comparison function to use instead of React's default shallow compare.</param>\n    static member memo(render: 'props -> #seq<ReactElement>, ?withKey: 'props -> string, ?areEqual: 'props -> 'props -> bool) =\n        Internal.memo(render >> React.fragment, ?areEqual=areEqual, ?withKey=withKey)\n\n    /// <summary>\n    /// `React.memo` memoizes the result of a function component. Given the same props, React will skip rendering the component, and reuse the last rendered result.\n    /// By default it will only shallowly compare complex objects in the props object. For more control, a custom `areEqual` function can be provided.\n    /// A component key can be provided in the props object, or a custom `withKey` function can be provided.\n    /// </summary>\n    /// <param name='name'>The component name to display in the React dev tools.</param>\n    /// <param name='render'>A render function that returns a list of elements.</param>\n    /// <param name='withKey'>A function to derive a component key from the props.</param>\n    /// <param name='areEqual'>A custom comparison function to use instead of React's default shallow compare.</param>\n    static member memo(name: string, render: 'props -> #seq<ReactElement>, ?withKey: 'props -> string, ?areEqual: 'props -> 'props -> bool) =\n        Internal.memo(render >> React.fragment, name, ?areEqual=areEqual, ?withKey=withKey)\n\n    //\n    // React.useContext\n    //\n\n    /// <summary>\n    /// Creates a Context object. When React renders a component that subscribes to this Context object\n    /// it will read the current context value from the closest matching Provider above it in the tree.\n    /// </summary>\n    /// <param name='name'>The component name to display in the React dev tools.</param>\n    /// <param name='defaultValue'>A default value that is only used when a component does not have a matching Provider above it in the tree.</param>\n    static member createContext<'a>(?name: string, ?defaultValue: 'a) =\n        let contextObject = Interop.reactApi.createContext (defaultArg defaultValue Fable.Core.JS.undefined<'a>)\n        name |> Option.iter (fun name -> contextObject?displayName <- name)\n        contextObject\n\n    /// <summary>\n    /// A Provider component that allows consuming components to subscribe to context changes.\n    /// </summary>\n    /// <param name='contextObject'>A context object returned from a previous React.createContext call.</param>\n    /// <param name='contextValue'>The context value to be provided to descendant components.</param>\n    /// <param name='child'>A child element.</param>\n    static member contextProvider(contextObject: Fable.React.IContext<'a>, contextValue: 'a, child: ReactElement) : ReactElement =\n        Interop.reactApi.createElement(contextObject?Provider, createObj [\"value\" ==> contextValue], [child])\n    /// <summary>\n    /// A Provider component that allows consuming components to subscribe to context changes.\n    /// </summary>\n    /// <param name='contextObject'>A context object returned from a previous React.createContext call.</param>\n    /// <param name='contextValue'>The context value to be provided to descendant components.</param>\n    /// <param name='children'>A sequence of child elements.</param>\n    static member contextProvider(contextObject: Fable.React.IContext<'a>, contextValue: 'a, children: #seq<ReactElement>) : ReactElement =\n        Interop.reactApi.createElement(contextObject?Provider, createObj [\"value\" ==> contextValue], children)\n\n    /// <summary>\n    /// A Consumer component that subscribes to context changes.\n    /// </summary>\n    /// <param name='contextObject'>A context object returned from a previous React.createContext call.</param>\n    /// <param name='render'>A render function that returns an element.</param>\n    static member contextConsumer(contextObject: Fable.React.IContext<'a>, render: 'a -> ReactElement) : ReactElement =\n        Interop.reactApi.createElement(contextObject?Consumer, null, [!!render])\n    /// <summary>\n    /// A Consumer component that subscribes to context changes.\n    /// </summary>\n    /// <param name='contextObject'>A context object returned from a previous React.createContext call.</param>\n    /// <param name='render'>A render function that returns a sequence of elements.</param>\n    static member contextConsumer(contextObject: Fable.React.IContext<'a>, render: 'a -> #seq<ReactElement>) : ReactElement =\n        Interop.reactApi.createElement(contextObject?Consumer, null, [!!(render >> React.fragment)])\n\n    /// <summary>\n    /// The `useContext` hook. Accepts a context object (the value returned from React.createContext) and returns the current context value for that context.\n    /// The current context value is determined by the value prop of the nearest Provider component above the calling component in the tree.\n    /// </summary>\n    /// <param name='contextObject'>A context object returned from a previous React.createContext call.</param>\n    [<Hook>]\n    static member useContext(contextObject: Fable.React.IContext<'a>) = Interop.reactApi.useContext contextObject\n\n    /// <summary>\n    /// Creates a callback that keeps the same reference during the entire lifecycle of the component while having access to\n    /// the current value of the dependencies on every call.\n    ///\n    /// This hook should only be used for (like a dispatch) functions that are not used to provide information during render.\n    ///\n    /// This is not a complete replacement for the `useCallback` hook. It returns a callback that does not need explicit\n    /// dependency declarations and never causes a re-render.\n    /// </summary>\n    /// <param name='callback'>The function call.</param>\n    [<Hook>]\n    static member useCallbackRef(callback: ('a -> 'b)) =\n        let lastRenderCallbackRef = React.useRef(callback)\n\n        let callbackRef =\n            React.useCallback((fun (arg: 'a) ->\n                lastRenderCallbackRef.current(arg)\n            ), [||])\n\n        React.useLayoutEffect(fun () ->\n            // render is commited - it's safe to update the callback\n            lastRenderCallbackRef.current <- callback\n        )\n\n        callbackRef\n\n    /// <summary>\n    /// Just like React.useState except that the updater function uses the previous state of the state variable as input and allows you to compute the next value using it.\n    /// This is useful in cases where defining helpers functions inside the definition of a React function component would actually cache the initial value (because they become closures) during first render as opposed to using the current value after multiple render cycles.\n    ///\n    /// Use this instead of React.useState when your state variable is a list, an array, a dictionary, a map or other complex structures.\n    /// </summary>\n    static member useStateWithUpdater (initial: 't) : ('t * (('t -> 't) -> unit)) = import \"useState\" \"react\"\n\n    /// <summary>\n    /// Forwards a given ref, allowing you to pass it further down to a child.\n    /// </summary>\n    /// <param name='render'>A render function that returns an element.</param>\n    static member forwardRef(render: ('props * IRefValue<'t> -> ReactElement)) : ('props * IRefValue<'t> -> ReactElement) =\n        let forwardRefType = Interop.reactApi.forwardRef(Func<'props,IRefValue<'t>,ReactElement> (fun props ref -> render(props,ref)))\n        fun (props, ref) ->\n            let propsObj = props |> JsInterop.toPlainJsObj\n            propsObj?ref <- ref\n            Interop.reactApi.createElement(forwardRefType, propsObj)\n\n    /// <summary>\n    /// Forwards a given ref, allowing you to pass it further down to a child.\n    /// </summary>\n    /// <param name='name'>The component name to display in the React dev tools.</param>\n    /// <param name='render'>A render function that returns an element.</param>\n    static member forwardRef(name: string, render: ('props * IRefValue<'t> -> ReactElement)) : ('props * IRefValue<'t> -> ReactElement) =\n        let forwardRefType = Interop.reactApi.forwardRef(Func<'props,IRefValue<'t>,ReactElement> (fun props ref -> render(props,ref)))\n        render?displayName <- name\n        fun (props, ref) ->\n            let propsObj = props |> JsInterop.toPlainJsObj\n            propsObj?ref <- ref\n            Interop.reactApi.createElement(forwardRefType, propsObj)\n\n    /// <summary>\n    /// Highlights potential problems in an application by enabling additional checks\n    /// and warnings for descendants. As well as double rendering function components.\n    ///\n    /// This *does not do anything* in production mode. You do not need to hide it\n    /// with compiler directives.\n    /// </summary>\n    /// <param name='children'>The elements that will be rendered with additional\n    /// checks and warnings.</param>\n    static member strictMode(children: ReactElement list) =\n        Interop.reactApi.createElement(Interop.reactApi.StrictMode, None, children)\n\n    /// <summary>\n    /// Lets you define a component that is loaded dynamically. Which helps with code splitting.\n    /// </summary>\n    /// <param name='dynamicImport'>\n    ///  The dynamicImport of the component.\n    ///\n    ///  Such as `let asyncComponent : JS.Promise[unit -> ReactElement] = JsInterop.importDynamic \"./CodeSplitting.fs\"`.\n    ///\n    ///  Where you would then pass in `asyncComponent`.\n    /// </param>\n    /// <param name=\"props\">The props to be passed to the component.</param>\n    static member lazy'<'t,'props>(dynamicImport: JS.Promise<'t>, props: 'props) =\n        Interop.reactApi.createElement(Interop.reactApi.lazy'(fun () -> dynamicImport),props)\n    /// <summary>\n    /// Lets you define a component that is loaded dynamically. Which helps with code\n    /// splitting.\n    /// </summary>\n    /// <param name='dynamicImport'>\n    /// The dynamicImport of the component.\n    ///\n    /// Such as `let asyncComponent : JS.Promise[unit -> ReactElement] = JsInterop.importDynamic \"./CodeSplitting.fs\"`.\n    ///\n    /// Where you would then pass in `fun () -> asyncComponent`.\n    /// </param>\n    /// <param name=\"props\">The props to be passed to the component.</param>\n    static member lazy'<'t,'props>(dynamicImport: unit -> JS.Promise<'t>, props: 'props) =\n        Interop.reactApi.createElement(Interop.reactApi.lazy'(dynamicImport),props)\n\n    /// <summary>\n    /// Lets you specify a loading indicator whenever a child element is not yet ready\n    /// to render.\n    ///\n    /// Currently this is only usable with `React.lazy'`.\n    /// </summary>\n    /// <param name='children'>The elements that will be rendered within the suspense block.</param>\n    static member suspense(children: ReactElement list) =\n        Interop.reactApi.createElement(Interop.reactApi.Suspense, {| fallback = Html.none |} |> JsInterop.toPlainJsObj, children)\n    /// <summary>\n    /// Lets you specify a loading indicator whenever a child element is not yet ready\n    /// to render.\n    ///\n    /// Currently this is only usable with `React.lazy'`.\n    /// </summary>\n    /// <param name='children'>The elements that will be rendered within the suspense block.</param>\n    /// <param name='fallback'>The element that will be rendered while the children are loading.</param>\n    static member suspense(children: ReactElement list, fallback: ReactElement) =\n        Interop.reactApi.createElement(Interop.reactApi.Suspense, {| fallback = fallback |} |> JsInterop.toPlainJsObj, children)\n\n    /// <summary>\n    /// Allows you to override the behavior of a given ref.\n    ///\n    /// </summary>\n    /// <param name='ref'>The ref you want to override.</param>\n    /// <param name='createHandle'>A function that returns a new ref with changed behavior.</param>\n    [<Hook>]\n    static member useImperativeHandle(ref: IRefValue<'t>, createHandle: unit -> 't) =\n        Interop.reactApi.useImperativeHandleNoDeps ref createHandle\n\n    /// <summary>\n    /// Lets you specify a loading indicator whenever a child element is not yet ready\n    /// to render.\n    ///\n    /// Currently this is only usable with `React.lazy'`.\n    /// </summary>\n    /// <param name='ref'>The ref you want to override.</param>\n    /// <param name='createHandle'>A function that returns a new ref with changed behavior.</param>\n    /// <param name='dependencies'>An array of dependencies upon which the imperative handle function depends.</param>\n    [<Hook>]\n    static member useImperativeHandle(ref: IRefValue<'t>, createHandle: unit -> 't, dependencies: obj []) =\n        Interop.reactApi.useImperativeHandle ref createHandle dependencies\n\n    /// <summary>\n    /// Creates a CancellationToken that is cancelled when a component is unmounted.\n    /// </summary>\n    [<Hook>]\n    static member inline useCancellationToken () =\n        let cts = React.useRef(new System.Threading.CancellationTokenSource())\n        let token = React.useRef(cts.current.Token)\n\n        React.useEffectOnce(fun () ->\n            React.createDisposable(fun () ->\n                cts.current.Cancel()\n                cts.current.Dispose()\n            )\n        )\n\n        token\n\n[<AutoOpen>]\nmodule ReactOverloadMagic =\n    type React with\n        /// Creates a disposable instance by merging multiple IDisposables.\n        static member inline createDisposable([<ParamArray>] disposables: #IDisposable []) =\n            React.createDisposable(fun () ->\n                disposables\n                |> Array.iter (fun d -> d.Dispose())\n            )\n        /// Creates a disposable instance by merging multiple IDisposable options.\n        static member inline createDisposable([<ParamArray>] disposables: #IDisposable option []) =\n            React.createDisposable(fun () ->\n                disposables\n                |> Array.iter (Option.iter (fun d -> d.Dispose()))\n            )\n        /// Creates a disposable instance by merging multiple IDisposable refs.\n        static member inline createDisposable([<ParamArray>] disposables: IRefValue<#IDisposable> []) =\n            React.createDisposable(fun () ->\n                disposables\n                |> Array.iter (fun d -> d.current.Dispose())\n            )\n\n        /// Creates a disposable instance by merging multiple IDisposable refs.\n        static member inline createDisposable([<ParamArray>] disposables: IRefValue<#IDisposable option> []) =\n            React.createDisposable(fun () ->\n                disposables\n                |> Array.iter (fun d -> d.current |> Option.iter (fun d -> d.Dispose()))\n            )\n\n        /// The `useState` hook that creates a state variable for React function components.\n        [<Hook>]\n        static member useState<'t>(initial: 't) = Interop.reactApi.useState<'t,'t>(initial)\n\n\n        [<Hook>]\n        static member useStateWithUpdater<'t>(initializer: unit -> 't): ('t * (('t -> 't) -> unit)) = import \"useState\" \"react\"\n","import {\n    useEffect as useEffectReact,\n    useLayoutEffect as useLayoutEffectReact,\n    useDebugValue as useDebugValueReact } from 'react'\n\nexport const useEffect = getDisposable => {\n    useEffectReact(() => {\n        const disposable = getDisposable()\n        return () => {\n            disposable.Dispose();\n        }\n    })\n}\n\nexport const useEffectWithDeps = (getDisposable, deps) => {\n    useEffectReact(() => {\n        const disposable = getDisposable()\n        return () => {\n            disposable.Dispose();\n        }\n    }, deps)\n}\n\nexport const useLayoutEffect = getDisposable => {\n    useLayoutEffectReact(() => {\n        const disposable = getDisposable()\n        return () => {\n            disposable.Dispose();\n        }\n    })\n}\n\nexport const useLayoutEffectWithDeps = (getDisposable, deps) => {\n    useLayoutEffectReact(() => {\n        const disposable = getDisposable()\n        return () => {\n            disposable.Dispose();\n        }\n    }, deps)\n}\n\nexport const useDebugValue = (value, formatter) => useDebugValueReact(value, formatter)","module Home.View\r\n\r\nopen Fable.Core\r\nopen Fable.Core.JsInterop\r\nopen Fable.React\r\nopen Fable.React.Props\r\nopen Types\r\nopen Common\r\nopen Global\r\nopen System.Globalization\r\nopen Imports\r\nopen Utils\r\nopen ViewComponents\r\nopen Browser\r\n\r\nlet connect (web3 :UseWeb3ReactHook) dispatch =\r\n    match web3.active with\r\n    | false ->\r\n        [div [ClassName \"connect\"]\r\n            [ConnectButton { className = \"button big-connect\"; children = [str \"Connect\"] }\r\n             p [] [str \"Connect your account to edit your page\"]]\r\n         ]\r\n    | true ->\r\n        []\r\n\r\nlet Carousel =\r\n    FunctionComponent.Of ((fun () ->\r\n        let index = Hooks.useState 0\r\n        let elems =\r\n            let getElem (traitValues :string[]) =\r\n                div [ClassName \"nft-detail\"]\r\n                    [img [Src \"/img/image_missing_borderless.svg\"]\r\n                     div [ClassName \"traits\"]\r\n                        [p [ClassName \"trait\"] [str \"Background\"]\r\n                         p [ClassName \"trait-value\"] [str traitValues.[0]]\r\n                         p [ClassName \"trait\"] [str \"Hair\"]\r\n                         p [ClassName \"trait-value\"] [str traitValues.[1]]\r\n                         p [ClassName \"trait\"] [str \"Eyes\"]\r\n                         p [ClassName \"trait-value\"] [str traitValues.[2]]\r\n                         p [ClassName \"trait\"] [str \"Facial Hair\"]\r\n                         p [ClassName \"trait-value\"] [str traitValues.[3]]\r\n                         p [ClassName \"trait\"] [str \"Accessory\"]\r\n                         p [ClassName \"trait-value\"] [str traitValues.[4]]\r\n                         p [ClassName \"trait\"] [str \"Blockchain Power\"]\r\n                         p [ClassName \"trait-value\"] [str traitValues.[5]]]]\r\n            [|\r\n                getElem [| \"Transparent Rainbow\"; \"Untied Bow\"; \"Night-vision Shades\"; \"Hairless Beard\"; \"Silent Headphones\"; \"Reorder Blocks\" |]\r\n                getElem [| \"5-Sided Squares\"; \"4-Dimensional Hat\"; \"Invisible Eyepatch\"; \"Foot-long Stubble\"; \"Static Watch\"; \"Infinite Hash Power\" |]\r\n                getElem [| \"1-Colour Gradient\"; \"Invisible Bangs\"; \"Opaque Glasses\"; \"None with Some\"; \"Full-body Bikini\"; \"Double Spend\" |]\r\n                getElem [| \"Pointy Circles\"; \"Shaved Ponytail\"; \"Three-eyed Cyclops\"; \"Hairless Beard\"; \"Bottomless Handbag\"; \"Universal Signature\" |]\r\n                getElem [| \"Sky-blue Yellow\"; \"Short-backed Mullet\"; \"Night-vision Shades\"; \"Invisible Moustache\"; \"Fishnet Umbrella\"; \"Double Spend\" |]\r\n            |]\r\n        let prev = if index.current = 0 then elems.Length - 1 else index.current - 1\r\n        let next = if index.current = elems.Length - 1 then 0 else index.current + 1\r\n        let elemsWrapped =\r\n            elems |> Array.mapi (fun i elem ->\r\n                div [classList [\"active\", i = index.current; \"prev\", i = prev; \"next\", i = next]] [elem])\r\n        Hooks.useEffect (fun () ->\r\n            window.setTimeout((fun () ->\r\n                if index.current = elems.Length - 1 then index.update 0 else index.update (index.current + 1)\r\n                ), 3000) |> ignore)\r\n        div [ClassName \"carousel-wrapper\"]\r\n            [div [ClassName \"carousel\"] elemsWrapped]))\r\n\r\nlet HomePage =\r\n    FunctionComponent.Of ((fun (props : {| dispatch: Msg -> unit |}) ->\r\n        div [ClassName \"has-text-centered container main\"]\r\n            [img [Src \"/img/image_missing_borderless.svg\"]\r\n             h1 [] [str \"Offchain NFT\"]\r\n             h2 [] [str \"A limited collection of 2040 totally unique on-chain NFTs, passed through an advanced smart contract algorithm to simulate the visual results of most off-chain NFTs in the year 2040\"]\r\n             div [ClassName \"hero\"]\r\n                (Array.init 50 (fun _ -> div [] [img [Src \"/img/image_missing_borderless.svg\"]]))\r\n             div [ClassName \"minting\"; Id \"minting\"]\r\n                [h3 [] [str \"Minting\"]\r\n                 img [Src \"/img/minting.svg\"]\r\n                 p [] [str \"To mint an Offchain NFT, send any NFT of your choice (you can use \"; a [Href \"https://https://opensea.io/\"; Target \"_blank\"] [str \"OpenSea\"]; str \" or \"; a [Href \"https://www.myetherwallet.com/\"; Target \"_blank\"] [str \"MyEtherWallet\"]; str \" for example) to:\"]\r\n                 p [] [b [] [str \"offchainnft.eth\"]; str \" (\"; a [Href \"https://etherscan.io/address/0x39866b07989c680278eaeebebbe41b062342de5a\"; Target \"_blank\"] [str \"0x39866b07989c680278eaeebebbe41b062342de5a\"]; str \")\"]\r\n                 ]\r\n             div [ClassName \"art\"; Id \"art\"]\r\n                [h3 [] [str \"The Art\"]\r\n                 Carousel ()]\r\n             div [ClassName \"faq\"; Id \"faq\"]\r\n                [h3 [] [str \"FAQ\"]\r\n                 p [ClassName \"question\"] [str \"How much does it cost to mint?\"]\r\n                 p [ClassName \"answer\"] [str \"Offchain NFTs are totally free, but you must burn a (preferably off-chain) NFT to mint one. It can be any NFT you like, but you will gain more respect from the community the more noteworthy your burn.\"]\r\n                 p [ClassName \"question\"] [str \"How do I mint one?\"]\r\n                 p [ClassName \"answer\"] [str \"Send any NFT you like to \"; b [] [str \"offchainnft.eth\"]; str \" (\"; a [Href \"https://etherscan.io/address/0x39866b07989c680278eaeebebbe41b062342de5a\"; Target \"_blank\"] [str \"0x39866b07989c680278eaeebebbe41b062342de5a\"]; str \") and an Offchain NFT will be sent back to you in the same transaction. To send an NFT you can use \"; a [Href \"https://opensea.io/\"; Target \"_blank\"] [str \"OpenSea\"]; str \" or \"; a [Href \"https://www.myetherwallet.com/\"; Target \"_blank\"] [str \"MyEtherWallet\"]]\r\n                 p [ClassName \"question\"] [str \"Is this a scam?\"]\r\n                 p [ClassName \"answer\"] [str \"Absolutely not. The NFT you send cannot be accessed by us and there are no fees involved anywere. The smart contract logic is public and is available \"; a [Href \"https://etherscan.io/address/0x39866b07989c680278eaeebebbe41b062342de5a\"; Target \"_blank\"] [str \"here\"]; str \". If you are worried, send a very low value NFT.\"]\r\n                 p [ClassName \"question\"] [str \"Why did you create this?\"]\r\n                 p [ClassName \"answer\"] [\r\n                    str \"We created this to raise awareness about on-chain NFTs and to have some fun. We are a group of on-chain NFT enthusiasts and all have our own collections: \"\r\n                    ul []\r\n                        [li [] [a [Href \"https://blockheads.network\"; Target \"_blank\"] [str \"Blockheads\"]]\r\n                         li [] [a [Href \"https://goodblocks.io\"; Target \"_blank\"] [str \"goodblocks\"]]\r\n                         li [] [a [Href \"https://www.mutytes.com\"; Target \"_blank\"] [str \"Mutytes\"]]]]]\r\n             div [ClassName \"roadmap\"; Id \"roadmap\"]\r\n                [h3 [] [str \"Roadmap\"]\r\n                 p [ClassName \"roadmap-icon\"] [i [ClassName \"mdi mdi-circle-multiple\"] []]\r\n                 p [ClassName \"roadmap-title\"] [str \"Offchain Coin\"]\r\n                 p [ClassName \"roadmap-desc\"] [str \"We will release a custom token where the balances of that token are held entirely off-chain, stored in individual wallets. Be your own bank and print as much of the coin as you want should you get in financial difficulty.\"]\r\n                 p [ClassName \"roadmap-icon\"] [i [ClassName \"mdi mdi-account-group\"] []]\r\n                 p [ClassName \"roadmap-title\"] [str \"Offchain Social Network\"]\r\n                 p [ClassName \"roadmap-desc\"] [str \"We will release a social networking application that solves the content moderation problem by applying our custom 100% censorship of content algorithm.\"]\r\n                 p [ClassName \"roadmap-icon\"] [i [ClassName \"mdi mdi-virtual-reality\"] []]\r\n                 p [ClassName \"roadmap-title\"] [str \"Offchain Metaverse\"]\r\n                 p [ClassName \"roadmap-desc\"] [str \"Every Offchain NFT will receive a parcel of land in an off-chain metaverse. We will use our algorithms to simulate a custom virtual world as it would be in 2040 for a centralised server that went offline in 2034.\"]\r\n                 p [ClassName \"roadmap-icon\"] [i [ClassName \"mdi mdi-rocket-launch\"] []]\r\n                 p [ClassName \"roadmap-title\"] [str \"Moonshot - Offchain Blockchain\"]\r\n                 p [ClassName \"roadmap-desc\"] [str \"We will launch our own blockchain. In order to maximise performance (we care about scalability to tackle real world problems) we will have a single validator. We aim to process at least 1000000 transactions per second using this model and will therefore become the premier L1.\"]\r\n                 ]\r\n             footer []\r\n                [div [ClassName \"social-icons\"]\r\n                    [div [] [a [Href \"https://opensea.io/collection/offchain-nft\"; Target \"_blank\"] [img [Src \"/img/opensea-custom.svg\"]]]\r\n                     div [] [a [Href \"https://twitter.com/OffchainNFT\"; Target \"_blank\"] [img [Src \"/img/twitter-custom.svg\"]]]\r\n                     div [] [a [Href \"https://discord.gg/GNz5vdvHaD\"; Target \"_blank\"] [img [Src \"/img/discord-custom.svg\"]]]]]\r\n             ]\r\n   ), \"HomePage\", equalsButFunctions)\r\n\r\nlet root model common dispatch =\r\n    div []\r\n        [nav [ClassName \"navbar is-fixed-top\"; Role \"navigation\"; AriaLabel \"main navigation\"]\r\n            [div [ClassName \"container\"]\r\n                [div [ClassName \"navbar-brand\"] [a [ClassName \"navbar-item\"; Href \"/\"] [img [Src \"/img/image_missing_borderless.svg\"]; str \" Offchain NFT\"]]\r\n                 div [ClassName \"navbar-menu\"]\r\n                    [div [ClassName \"navbar-end\"]\r\n                        [a [ClassName \"navbar-item\"; Href \"#art\"] [str \"The Art\"]\r\n                         a [ClassName \"navbar-item\"; Href \"#faq\"] [str \"FAQ\"]\r\n                         a [ClassName \"navbar-item\"; Href \"#roadmap\"] [str \"Roadmap\"]]]]]\r\n         HomePage {| dispatch = dispatch |}]\r\n","namespace Elmish\n\n\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule internal Option =\n\n    let tuple a b =\n        match (a,b) with\n        | Some a, Some b -> Some (a,b)\n        | _ -> None\n\n    let ofFunc f arg =\n        try\n            Some (f arg)\n        with _ ->\n            None","(** UrlParser\n------\nThis port of the Elm library helps you turn URLs into nicely structured data.\nIt is designed to be used with `Navigation` module to help folks create\nsingle-page applications (SPAs) where you manage browser navigation yourself.\n*)\n\nmodule Elmish.UrlParser\n\n\n(**\n#### Types\n*)\n\ntype State<'v> =\n  { visited : string list\n    unvisited : string list\n    args : Map<string,string>\n    value : 'v }\n\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule internal State =\n  let mkState visited unvisited args value =\n        { visited = visited\n          unvisited = unvisited\n          args = args\n          value = value }\n\n  let map f { visited = visited; unvisited = unvisited; args = args; value = value } =\n        { visited = visited\n          unvisited = unvisited\n          args = args\n          value = f value }\n\n\n/// Turn URLs like `/blog/42/cat-herding-techniques` into nice data.\ntype Parser<'a,'b> = State<'a> -> State<'b> list\n\n\n(**\n#### Parse segments\nCreate a custom path segment parser. You can use it to define something like “only CSS files” like this:\n```\n    let css =\n      custom \"CSS_FILE\" <| fun segment ->\n        if String.EndsWith \".css\" then\n          Ok segment\n        else\n          Error \"Does not end with .css\"\n```\n*)\nlet custom tipe (stringToSomething: string->Result<_,_>) : Parser<_,_> =\n    let inner { visited = visited; unvisited = unvisited; args = args; value = value } =\n        match unvisited with\n        | [] -> []\n        | next :: rest ->\n            match stringToSomething next with\n            | Ok nextValue ->\n                [ State.mkState (next :: visited) rest args (value nextValue) ]\n\n            | Error msg ->\n                []\n    inner\n\n\n(** Parse a segment of the path as a `string`.\n```\n    parse str location\n```\n<pre>\n    /alice/  ==>  Some \"alice\"\n    /bob     ==>  Some \"bob\"\n    /42/     ==>  Some \"42\"\n</pre>\n*)\nlet str state =\n    custom \"string\" Ok state\n\n\n(** Parse a segment of the path as an `int`.\n```\n    parse i32 location\n```\n<pre>\n    /alice/  ==>  None\n    /bob     ==>  None\n    /42/     ==>  Some 42\n</pre>\n*)\nlet i32 state =\n    custom \"i32\" (System.Int32.TryParse >> function true, value -> Ok value | _ -> Error \"Can't parse int\" ) state\n\n\n(** Parse a segment of the path if it matches a given string.\n```\n    s \"blog\"  // can parse /blog/\n              // but not /glob/ or /42/ or anything else\n```\n*)\nlet s str : Parser<_,_> =\n    let inner { visited = visited; unvisited = unvisited; args = args; value = value } =\n        match unvisited with\n        | [] -> []\n        | next :: rest ->\n            if next = str then\n                [ State.mkState (next :: visited) rest args value ]\n            else\n                []\n    inner\n\n\n\n(**\n#### Combining parsers\nParse a path with multiple segments.\n\n```\n    parse (s \"blog\" </> i32) location\n```\n<pre>\n    /blog/35/  ==>  Some 35\n    /blog/42   ==>  Some 42\n    /blog/     ==>  None\n    /42/       ==>  None\n</pre>\n```\n    parse (s \"search\" </> str) location\n```\n<pre>\n    /search/cats/  ==>  Some \"cats\"\n    /search/frog   ==>  Some \"frog\"\n    /search/       ==>  None\n    /cats/         ==>  None\n</pre>\n*)\nlet inline (</>) (parseBefore: Parser<_,_>) (parseAfter: Parser<_,_>) =\n  fun state ->\n    List.collect parseAfter (parseBefore state)\n\n\n(** Transform a path parser.\n```\n    type Comment = { author : string; id : int }\n    rawComment =\n      s \"user\" </> str </> s \"comments\" </> i32\n    comment =\n      map (fun a id -> { author = a; id = id }) rawComment\n    parse comment location\n```\n<pre>\n    /user/bob/comments/42  ==>  Some { author = \"bob\"; id = 42 }\n    /user/tom/comments/35  ==>  Some { author = \"tom\"; id = 35 }\n    /user/sam/             ==>  None\n</pre>\n*)\nlet map (subValue: 'a) (parse: Parser<'a,'b>) : Parser<'b->'c,'c> =\n    let inner { visited = visited; unvisited = unvisited; args = args; value = value } =\n        List.map (State.map value)\n        <| parse { visited = visited\n                   unvisited = unvisited\n                   args = args\n                   value = subValue }\n    inner\n\n\n\n(** Try a bunch of different path parsers.\n```\n    type Route\n      = Search of string\n      | Blog of int\n      | User of string\n      | Comment of string*int\n    route =\n      oneOf\n        [ map Search  (s \"search\" </> str)\n          map Blog    (s \"blog\" </> i32)\n          map User    (s \"user\" </> str)\n          map (fun u c -> Comment (u,c)) (s \"user\" </> str </> \"comments\" </> i32) ]\n    parse route location\n```\n<pre>\n    /search/cats           ==>  Some (Search \"cats\")\n    /search/               ==>  None\n    /blog/42               ==>  Some (Blog 42)\n    /blog/cats             ==>  None\n    /user/sam/             ==>  Some (User \"sam\")\n    /user/bob/comments/42  ==>  Some (Comment \"bob\" 42)\n    /user/tom/comments/35  ==>  Some (Comment \"tom\" 35)\n    /user/                 ==>  None\n</pre>\n*)\nlet oneOf parsers state =\n    List.collect (fun parser -> parser state) parsers\n\n\n(** A parser that does not consume any path segments.\n```\n    type BlogRoute = Overview | Post of int\n    blogRoute =\n      oneOf\n        [ map Overview top\n          map Post  (s \"post\" </> i32) ]\n    parse (s \"blog\" </> blogRoute) location\n```\n<pre>\n    /blog/         ==>  Some Overview\n    /blog/post/42  ==>  Some (Post 42)\n</pre>\n*)\nlet top state=\n    [state]\n\n\n\n(**\n#### Query parameters\nTurn query parameters like `?name=tom&age=42` into nice data.\n\n*)\n\ntype QueryParser<'a,'b> = State<'a> -> State<'b> list\n\n\n(** Parse some query parameters.\n```\n    type Route = BlogList (Option string) | BlogPost Int\n    route =\n      oneOf\n        [ map BlogList (s \"blog\" <?> stringParam \"search\")\n          map BlogPost (s \"blog\" </> i32) ]\n    parse route location\n```\n<pre>\n    /blog/              ==>  Some (BlogList None)\n    /blog/?search=cats  ==>  Some (BlogList (Some \"cats\"))\n    /blog/42            ==>  Some (BlogPost 42)\n</pre>\n*)\nlet inline (<?>) (parser: Parser<_,_>) (queryParser:QueryParser<_,_>) : Parser<_,_> =\n    fun state ->\n        List.collect queryParser (parser state)\n\n(** Create a custom query parser. You could create parsers like these:\n```\n    val jsonParam : string -> Decoder a -> QueryParser (Option a -> b) b\n    val enumParam : string -> Map<string,a> -> QueryParser (Option a -> b) b\n```\n*)\nlet customParam (key: string) (func: string option -> _) : QueryParser<_,_> =\n    let inner { visited = visited; unvisited = unvisited; args = args; value = value } =\n        [ State.mkState visited unvisited args (value (func (Map.tryFind key args))) ]\n    inner\n\n\n(** Parse a query parameter as a `string`.\n```\n    parse (s \"blog\" <?> stringParam \"search\") location\n```\n<pre>\n    /blog/              ==>  Some (Overview None)\n    /blog/?search=cats  ==>  Some (Overview (Some \"cats\"))\n</pre>\n*)\nlet stringParam name =\n    customParam name id\n\nlet internal intParamHelp =\n    Option.bind\n        (fun (value: string) ->\n            match System.Int32.TryParse value with\n            | (true,x) -> Some x\n            | _ -> None)\n\n(** Parse a query parameter as an `int`. Option you want to show paginated\nsearch results. You could have a `start` query parameter to say which result\nshould appear first.\n```\n    parse (s \"results\" <?> intParam \"start\") location\n```\n<pre>\n    /results           ==>  Some None\n    /results?start=10  ==>  Some (Some 10)\n</pre>\n*)\nlet intParam name =\n    customParam name intParamHelp\n\n\n// PARSER HELPERS\n\nlet rec internal parseHelp states =\n    match states with\n    | [] ->\n        None\n    | state :: rest ->\n        match state.unvisited with\n        | [] ->\n            Some state.value\n        | [\"\"] ->\n            Some state.value\n        | _ ->\n            parseHelp rest\n\nlet internal splitUrl (url: string) =\n    match List.ofArray <| url.Split([|'/'|]) with\n    | \"\" :: segments ->\n        segments\n    | segments ->\n        segments\n\n/// parse a given part of the location\nlet parse (parser: Parser<'a->'a,'a>) url args =\n    { visited = []\n      unvisited = splitUrl url\n      args = args\n      value = id }\n    |> parser\n    |> parseHelp\n\nopen Fable.Core\n\nlet internal toKeyValuePair (segment: string) =\n    match segment.Split('=') with\n    | [| key; value |] ->\n        Option.tuple (Option.ofFunc JS.decodeURIComponent key) (Option.ofFunc JS.decodeURIComponent value)\n    | _ -> None\n\n\nlet internal parseParams (querystring: string) =\n    if querystring.Length > 1 then\n        querystring.Substring(1).Split('&')\n        |> Seq.map toKeyValuePair\n        |> Seq.choose id\n        |> Map.ofSeq\n    else Map.empty\n\nopen Browser.Types\n\n(**\n#### Parsers\nParse based on `location.pathname` and `location.search`. This parser\nignores the hash entirely.\n*)\nlet parsePath (parser: Parser<_,_>) (location: Location) =\n    parse parser location.pathname (parseParams location.search)\n\n(** Parse based on `location.hash`. This parser ignores the normal\npath entirely.\n*)\nlet parseHash (parser: Parser<_,_>) (location: Location) =\n    let hash, search =\n        let hash =\n            if location.hash.Length > 1 then location.hash.Substring 1\n            else \"\"\n        if hash.Contains(\"?\") then\n            let h = hash.Substring(0, hash.IndexOf(\"?\"))\n            h, hash.Substring(h.Length)\n        else\n            hash, \"?\"\n\n    parse parser hash (parseParams search)\n","namespace Elmish\nopen System\n\n[<Struct>]\ntype internal RingState<'item> =\n    | Writable of wx:'item array * ix:int\n    | ReadWritable of rw:'item array * wix:int * rix:int\n\ntype internal RingBuffer<'item>(size) =\n    let doubleSize ix (items: 'item array) =\n        seq { yield! items |> Seq.skip ix\n              yield! items |> Seq.take ix\n              for _ in 0..items.Length do\n                yield Unchecked.defaultof<'item> }\n        |> Array.ofSeq\n\n    let mutable state : 'item RingState =\n        Writable (Array.zeroCreate (max size 10), 0)\n\n    member __.Pop() =\n        match state with\n        | ReadWritable (items, wix, rix) ->\n            let rix' = (rix + 1) % items.Length\n            match rix' = wix with\n            | true -> \n                state <- Writable(items, wix)\n            | _ ->\n                state <- ReadWritable(items, wix, rix')\n            Some items.[rix]\n        | _ ->\n            None\n\n    member __.Push (item:'item) =\n        match state with\n        | Writable (items, ix) ->\n            items.[ix] <- item\n            let wix = (ix + 1) % items.Length\n            state <- ReadWritable(items, wix, ix)\n        | ReadWritable (items, wix, rix) ->\n            items.[wix] <- item\n            let wix' = (wix + 1) % items.Length\n            match wix' = rix with\n            | true -> \n                state <- ReadWritable(items |> doubleSize rix, items.Length, 0)\n            | _ -> \n                state <- ReadWritable(items, wix', rix)","(** Custom navigation\n------\nThis port of the Elm library is about treating the address bar as an input to your program.\nIt converts changes in the address bar into messages and provides functions for manipulation of the browser history.\n*)\nnamespace Elmish.Navigation\n\nopen Browser\nopen Browser.Types\nopen Elmish\n\n(**\n#### Parser\nA function to turn the string in the address bar into data that is easier for your app to handle.\n*)\ntype Parser<'a> = Location -> 'a\n\ntype Navigable<'msg> =\n    | Change of Location\n    | UserMsg of 'msg\n\n(**\n#### Direct history manipulation\n*)\n[<RequireQualifiedAccess>]\nmodule Navigation =\n    let [<Literal>] internal NavigatedEvent = \"NavigatedEvent\"\n\n    /// Modify current location\n    let modifyUrl (newUrl:string):Cmd<_> =\n        [fun _ -> history.replaceState((), \"\", newUrl)]\n\n    /// Push new location into history and navigate there\n    let newUrl (newUrl:string):Cmd<_> =\n        [fun _ -> history.pushState((), \"\", newUrl)\n                  let ev = CustomEvent.Create(NavigatedEvent)\n                  window.dispatchEvent ev\n                  |> ignore ]\n\n    /// Jump to some point in history (positve=forward, nagative=backward)\n    let jump (n:int):Cmd<_> =\n        [fun _ -> history.go n]\n\n\n(**\n#### Program extensions\nTreat user's program as a child component, by wrapping it and handling navigation events.\n*)\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\n[<RequireQualifiedAccess>]\nmodule Program =\n\n    module Internal =\n        let mutable private onChangeRef : Event -> unit =\n            fun _ ->\n                failwith \"`onChangeRef` has not been initialized.\\nPlease make sure you used Elmish.Navigation.Program.Internal.subscribe\"\n\n        let subscribe (dispatch:Dispatch<_ Navigable>) =\n            let mutable lastLocation = None\n            let onChange _ =\n                match lastLocation with\n                | Some href when href = window.location.href -> ()\n                | _ ->\n                    lastLocation <- Some window.location.href\n                    Change window.location |> dispatch\n\n            onChangeRef <- onChange\n\n            window.addEventListener(\"popstate\", onChangeRef)\n            window.addEventListener(\"hashchange\", onChangeRef)\n            window.addEventListener(Navigation.NavigatedEvent, onChangeRef)\n\n        let unsubscribe () =\n            window.removeEventListener(\"popstate\", onChangeRef)\n            window.removeEventListener(\"hashchange\", onChangeRef)\n            window.removeEventListener(Navigation.NavigatedEvent, onChangeRef)\n\n        let toNavigableWith (parser : Parser<'a>)\n                            (urlUpdate : 'a->'model->('model * Cmd<'msg>))\n                            (program : Program<'a,'model,'msg,'view>)\n                            (onLocationChange : Dispatch<Navigable<'msg>> -> unit) =\n\n            let map (model, cmd) =\n                model, cmd |> Cmd.map UserMsg\n\n            let update userUpdate msg model =\n                match msg with\n                | Change location ->\n                    urlUpdate (parser location) model\n                | UserMsg userMsg ->\n                    userUpdate userMsg model\n                |> map\n\n            let subs userSubscribe model =\n                Cmd.batch\n                  [ [ onLocationChange ]\n                    userSubscribe model |> Cmd.map UserMsg ]\n\n            let init userInit () =\n                userInit (parser window.location) |> map\n\n            let setState userSetState model dispatch =\n                userSetState model (UserMsg >> dispatch)\n\n            let view userView model dispatch =\n                userView model (UserMsg >> dispatch)\n            \n            program\n            |> Program.map init update view setState subs\n\n    /// Add the navigation to a program made with `mkProgram` or `mkSimple`.\n    /// urlUpdate: similar to `update` function, but receives parsed url instead of message as an input.\n    let toNavigable (parser : Parser<'a>)\n                    (urlUpdate : 'a->'model->('model * Cmd<'msg>))\n                    (program : Program<'a,'model,'msg,'view>) =\n\n        Internal.toNavigableWith parser urlUpdate program Internal.subscribe\n","module Global\r\n\r\ntype Page =\r\n    | Home\r\n\r\nlet toUrl page =\r\n    match page with\r\n    | Home -> \"/\"\r\n","(**\nProgram\n---------\nCore abstractions for creating and running the dispatch loop.\n\n*)\n\nnamespace Elmish\n\n\n/// Program type captures various aspects of program behavior\ntype Program<'arg, 'model, 'msg, 'view> = private {\n    init : 'arg -> 'model * Cmd<'msg>\n    update : 'msg -> 'model -> 'model * Cmd<'msg>\n    subscribe : 'model -> Cmd<'msg>\n    view : 'model -> Dispatch<'msg> -> 'view\n    setState : 'model -> Dispatch<'msg> -> unit\n    onError : (string*exn) -> unit\n    syncDispatch: Dispatch<'msg> -> Dispatch<'msg>\n}\n\n/// Program module - functions to manipulate program instances\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Program =\n    /// Typical program, new commands are produced by `init` and `update` along with the new state.\n    let mkProgram \n        (init : 'arg -> 'model * Cmd<'msg>) \n        (update : 'msg -> 'model -> 'model * Cmd<'msg>)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init\n          update = update\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = Log.onError\n          syncDispatch = id }\n\n    /// Simple program that produces only new state with `init` and `update`.\n    let mkSimple \n        (init : 'arg -> 'model) \n        (update : 'msg -> 'model -> 'model)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init >> fun state -> state,Cmd.none\n          update = fun msg -> update msg >> fun state -> state,Cmd.none\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = Log.onError\n          syncDispatch = id }\n\n    /// Subscribe to external source of events.\n    /// The subscription is called once - with the initial model, but can dispatch new messages at any time.\n    let withSubscription (subscribe : 'model -> Cmd<'msg>) (program: Program<'arg, 'model, 'msg, 'view>) =\n        let sub model =\n            Cmd.batch [ program.subscribe model\n                        subscribe model ]\n        { program with subscribe = sub }\n\n    /// Trace all the updates to the console\n    let withConsoleTrace (program: Program<'arg, 'model, 'msg, 'view>) =\n        let traceInit (arg:'arg) =\n            let initModel,cmd = program.init arg\n            Log.toConsole (\"Initial state:\", initModel)\n            initModel,cmd\n\n        let traceUpdate msg model =\n            Log.toConsole (\"New message:\", msg)\n            let newModel,cmd = program.update msg model\n            Log.toConsole (\"Updated state:\", newModel)\n            newModel,cmd\n\n        { program with\n            init = traceInit \n            update = traceUpdate }\n\n    /// Trace all the messages as they update the model\n    let withTrace trace (program: Program<'arg, 'model, 'msg, 'view>) =\n        let update msg model =\n            let state,cmd = program.update msg model\n            trace msg state\n            state,cmd\n        { program\n            with update = update }\n\n    /// Handle dispatch loop exceptions\n    let withErrorHandler onError (program: Program<'arg, 'model, 'msg, 'view>) =\n        { program\n            with onError = onError }\n\n    /// For library authors only: map existing error handler and return new `Program` \n    let mapErrorHandler map (program: Program<'arg, 'model, 'msg, 'view>) =\n        { program\n            with onError = map program.onError }\n\n    /// For library authors only: get the current error handler \n    let onError (program: Program<'arg, 'model, 'msg, 'view>) =\n        program.onError\n\n    /// For library authors only: function to render the view with the latest state \n    let withSetState (setState:'model -> Dispatch<'msg> -> unit)\n                     (program: Program<'arg, 'model, 'msg, 'view>) =        \n        { program\n            with setState = setState }\n\n    /// For library authors only: return the function to render the state \n    let setState (program: Program<'arg, 'model, 'msg, 'view>) =        \n        program.setState\n\n    /// For library authors only: return the view function \n    let view (program: Program<'arg, 'model, 'msg, 'view>) =        \n        program.view\n\n    /// For library authors only: function to synchronize the dispatch function\n    let withSyncDispatch (syncDispatch:Dispatch<'msg> -> Dispatch<'msg>)\n                         (program: Program<'arg, 'model, 'msg, 'view>) =        \n        { program\n            with syncDispatch = syncDispatch }\n\n    /// For library authors only: map the program type\n    let map mapInit mapUpdate mapView mapSetState mapSubscribe\n            (program: Program<'arg, 'model, 'msg, 'view>) =\n        { init = mapInit program.init\n          update = mapUpdate program.update\n          view = mapView program.view\n          setState = mapSetState program.setState\n          subscribe = mapSubscribe program.subscribe\n          onError = program.onError\n          syncDispatch = id }\n\n    /// Start the program loop.\n    /// arg: argument to pass to the init() function.\n    /// program: program created with 'mkSimple' or 'mkProgram'.\n    let runWith (arg: 'arg) (program: Program<'arg, 'model, 'msg, 'view>) =\n        let (model,cmd) = program.init arg\n        let rb = RingBuffer 10\n        let mutable reentered = false\n        let mutable state = model        \n        let rec dispatch msg = \n            if reentered then\n                rb.Push msg\n            else\n                reentered <- true\n                let mutable nextMsg = Some msg\n                while Option.isSome nextMsg do\n                    let msg = nextMsg.Value\n                    try\n                        let (model',cmd') = program.update msg state\n                        program.setState model' syncDispatch\n                        cmd' |> Cmd.exec (fun ex -> program.onError (sprintf \"Error in command while handling: %A\" msg, ex)) syncDispatch\n                        state <- model'\n                    with ex ->\n                        program.onError (sprintf \"Unable to process the message: %A\" msg, ex)\n                    nextMsg <- rb.Pop()\n                reentered <- false\n        and syncDispatch = program.syncDispatch dispatch            \n\n        program.setState model syncDispatch\n        let sub = \n            try \n                program.subscribe model \n            with ex ->\n                program.onError (\"Unable to subscribe:\", ex)\n                Cmd.none\n        Cmd.batch [sub; cmd]\n        |> Cmd.exec (fun ex -> program.onError (\"Error intitializing:\", ex)) syncDispatch\n\n    /// Start the dispatch loop with `unit` for the init() function.\n    let run (program: Program<unit, 'model, 'msg, 'view>) = runWith () program\n","module App.View\r\n\r\nopen Elmish\r\nopen Elmish.Navigation\r\nopen Elmish.UrlParser\r\nopen Fable.Core.JsInterop\r\nopen Types\r\nopen App.State\r\nopen Global\r\nopen Imports\r\nopen Browser.Dom\r\nopen Fable.React\r\nopen Fable.Core\r\nopen Web3TreeDapp\r\nopen Common\r\nopen ViewComponents\r\n\r\n// import stylesheet\r\nimportAll \"../sass/main.sass\"\r\n\r\n// Dapp Component for executing transactions\r\ntype DappProps<'txmsg, 'model, 'msg> =\r\n    { makeTxProcessor :UseWeb3ReactHook -> 'txmsg -> JS.Promise<TransactionResponse>\r\n      model: 'model\r\n      dispatch: 'msg -> unit\r\n      childRender: DappChildProps<'txmsg, 'model, 'msg> -> ReactElement }\r\n\r\nand DappChildProps<'txmsg, 'model, 'msg> =\r\n    { model: 'model\r\n      dispatch: 'msg -> unit\r\n      txResult: DappTxResult<'txmsg> option\r\n      txDispatch: 'txmsg -> unit }\r\n\r\nlet Dapp<'txmsg, 'model, 'msg> props =\r\n    FunctionComponent.Of ((fun (props :DappProps<'txmsg, 'model, 'msg>) ->\r\n        let web3 = useWeb3React()\r\n        let txMsg = Hooks.useState None\r\n        let txProcessor = Hooks.useRef None\r\n        let txResult = Hooks.useState None\r\n        let connectModalActive = Hooks.useState false\r\n        window?wr <- web3\r\n        Hooks.useEffect(fun _ ->\r\n            match web3.active with\r\n            | true ->\r\n                txProcessor.current <- (Some (props.makeTxProcessor web3))\r\n            | _ -> ())\r\n        Hooks.useEffect(fun () ->\r\n            match txMsg.current, txProcessor.current with\r\n            | Some txmsg, Some processor ->\r\n                txMsg.update None\r\n                promise {\r\n                    let! response = processor txmsg\r\n                    txResult.update (Some (Response (txmsg, response)))\r\n                    let! confirmed = response.wait()\r\n                    txResult.update (Some (Confirmed (txmsg, confirmed)))\r\n                } |> Promise.catch (fun e ->\r\n                    if e?code = 4001 then txResult.update (Some (UserCancelled txmsg))\r\n                    else txResult.update (Some (UnknownError (txmsg, e)))\r\n                    ) |> Promise.start\r\n            | _ -> ())\r\n        contextProvider connectModalControlsContext (Some { show = (fun () -> connectModalActive.update true); hide = fun () -> connectModalActive.update false })\r\n            [div []\r\n                [ConnectModal { active = connectModalActive.current }\r\n                 props.childRender\r\n                    { model = props.model\r\n                      dispatch = props.dispatch\r\n                      txResult = txResult.current\r\n                      txDispatch = Feliz.React.useCallbackRef(fun msg -> txMsg.update (Some msg) ) }]]\r\n    ), \"Dapp\", equalsButFunctions) props\r\n\r\n// Page Control\r\nlet pageRender props =\r\n    match props.model.page with\r\n    | Home -> Home.View.root props.model.home props.model.common (HomeMsg >> props.dispatch)\r\n\r\n// View root\r\nlet root model dispatch = \r\n    web3ReactProvider\r\n        [Web3ReactProviderProps.GetLibrary Common.getLibrary]\r\n        [Dapp<TransactionMsg, Model, Msg> { makeTxProcessor = makeTxProcessor; model = model; dispatch = dispatch; childRender = pageRender }] \r\n\r\nopen Elmish.React\r\nopen Elmish.Debug\r\nopen Elmish.HMR \r\n\r\nlet gbl =\r\n    { web3Modal = obj() //web3Modal\r\n      window = window\r\n      web3 = obj()//web3\r\n      web3treeContract = obj() }//contract}\r\n\r\n// App\r\nProgram.mkProgram (init gbl) (update gbl) root\r\n//|> Program.withSubscription metamaskChangeAccount\r\n//|> Program.withSubscription scrollToBottom\r\n|> Program.toNavigable (parsePath pageParser) (urlUpdate gbl)\r\n#if DEBUG\r\n|> Program.withDebugger\r\n#endif\r\n|> Program.withReactBatched \"elmish-app\"\r\n|> Program.run\r\n"],"names":["module","exports","isArrayLike","x","Array","isArray","ArrayBuffer","isView","isDisposable","Dispose","tryGetValue","map","key","defaultValue","has","get","Lazy","factory","isValueCreated","createdValue","padWithZeros","i","length","str","toString","dateOffset","date","date1","offset","kind","getTimezoneOffset","int32ToString","radix","ObjectRef","o","idMap","set","count","WeakMap","stringHash","s","h","len","charCodeAt","numberHash","combineHashCodes","hashes","reduce","h1","h2","structuralHash","GetHashCode","isHashable","String","equalArraysWith","y","eq","equalArrays","equals","Equals","isEquatable","Date","compareDates","xtime","ytime","getTime","comparePrimitives","compareArraysWith","comp","j","compareArrays","compare","CompareTo","isComparable","max","comparer","dashify","separator","replace","m","toLowerCase","charAt","changeCase","caseRule","slice","toUpperCase","createObj","fields","fail","kvPair","Error","definedCaseRule","toJSON","value","CURRIED_KEY","uncurry","arity","f","uncurriedFn","a1","a2","a3","a4","a5","a6","a7","a8","curry","partialApply","args","apply","undefined","concat","getItemFromDict","sameType","Object","getPrototypeOf","constructor","declare","cons","superClass","subClass","prototype","create","enumerable","writable","configurable","inherits","SystemObject","entries","k","v","join","id","identityHash","compareList","self","other","tail","res","head","List","from","Symbol","iterator","cur","next","done","Union","tag","name","splice","Record","record","getFieldNames","keys","recordToJson","values","thisNames","recordEquals","result","recordCompare","FSharpRef","contents","message","stack","TypeInfo","fullname","generics","construct","cases","enumCases","fullName","getGenerics","t","t1","t2","getRecordElements","k1","v1","k2","v2","gen","endsWith","Some","some","defaultArg","opt","P","e","c","cmp","MAX_DP","NAME","INVALID","INVALID_DP","INVALID_RM","DIV_BY_ZERO","UNDEFINED","NUMERIC","parse","n","nl","test","indexOf","search","substring","round","Big","DP","RM","dp","rm","more","xc","unshift","pop","stringify","z","push","NE","PE","abs","isneg","yc","l","Math","div","a","b","bl","bt","ri","bz","ai","al","r","rl","q","qc","qi","d","shift","gt","gte","lt","lte","minus","sub","xlty","plus","xe","ye","reverse","mod","ygtx","times","add","pow","one","sqrt","half","toExponential","mul","toFixed","toPrecision","sd","valueOf","_Big_","findIndex","normalize","version","NumberStyles","Decimal","wasm","WebAssembly","Instance","Module","Uint8Array","Long","low","high","unsigned","isLong","obj","__isLong__","defineProperty","INT_CACHE","UINT_CACHE","fromInt","cachedObj","cache","fromBits","fromNumber","isNaN","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","fromString","RangeError","p","radixToPower","size","min","parseInt","multiply","fromValue","val","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","toInt","$this","toNumber","isZero","isNegative","radixLong","divide","rem1","subtract","rem","remDiv","digits","isOdd","lessThan","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtrahend","multiplier","get_high","b00","divisor","approx","div_u","div_s","toUnsigned","numBits","shiftRightUnsigned","shiftLeft","shiftRight","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","op_Addition","LongLib","op_Multiply","op_Division","op_UnaryNegation","op_BitwiseAnd","fromInteger","xh","Enumerator","iter","current","getEnumerator","toIterator","en","MoveNext","Current","makeSeq","seq","append","xs","ys","delay","firstDone","iters","unfold","_a","_b","collect","output","innerIter","hasFinished","choose","fold","acc","iterate","_","iterateIndexed","sumBy","adder","Add","GetZero","fst","dateOffsetToString","isMinus","minutes","dateToHalfUTCString","toISOString","dateToStringWithCustomFormat","format","utc","match","rep","Number","NaN","getUTCFullYear","getFullYear","getUTCMonth","getMonth","getUTCDate","getDate","getUTCHours","getHours","getUTCMinutes","getMinutes","getUTCSeconds","getSeconds","getUTCMilliseconds","getMilliseconds","_provider","dateWithOffset","_c","dateToStringWithOffset","toUTCString","toLocaleString","toLocaleDateString","toLocaleTimeString","printOffset","dateToISOString","dateToStringWithKind","fsFormatRegExp","formatRegExp","isNumeric","isLessThan","_Long","substr","toHex","bytes","le","fromBytesLE","fromBytesBE","hi","lo","toBytesLE","toBytesBE","printf","input","cont","createPrinter","toText","arg","formatOnce","str2","prefix","flags","padLength","precision","sign","zeroFlag","minusFlag","ch","padLeft","strCopy","idx","pattern","intPart","decimalPart","dateToString","isNullOrEmpty","delimiter","isRight","MutableMap$00602","pairs","$this$$1","this","this$","hashMap","Map","pair","MutableMap$00602$$Add$$5BDDA1","MutableMap$00602$$TryFindIndex$$2B595","this$$$1","matchValue","pair$$1","MutableMap$00602$$TryFind$$2B595","this$$$2","k$$1","matchValue$$1","MutableMap$00602$$Clear","this$$$4","clear","MutableMap$00602$$get_Count","this$$$5","pairs$$2","$x$$2","$y$$3","this$$$8","k$$4","v$$1","matchValue$$4","msg","MutableMap$00602$$Remove$$2B595","this$$$10","k$$6","matchValue$$6","this$$$11","pairs$$3","pair$$3","item","Clear","Contains","item$$1","matchValue$$7","CopyTo","array","arrayIndex","i$$10","Remove","item$$2","matchValue$$8","delete","k$$7","k$$8","this$$$6","k$$2","matchValue$$2","MutableMap$00602$$get_Item$$2B595","k$$9","this$$$9","k$$5","matchValue$$5","MutableMap$00602$$ContainsKey$$2B595","pair$$5","k$$10","v$$2","this$$$7","k$$3","matchValue$$3","MutableMap$00602$$set_Item$$5BDDA1","pair$$6","MapTree$00602","MapTreeModule$$$sizeAux","$acc$$5","$m$$6","MapTreeModule$$$size","MapTreeModule$$$empty","MapTreeModule$$$height","_arg1","MapTreeModule$$$mk","l$$1","r$$1","hl","hr","MapTreeModule$$$rebalance","t1h","t2h","MapTreeModule$$$add","m$$3","Compare","c$$1","MapTreeModule$002EMapIterator$00602","started","MapTreeModule$$$collapseLHS","$stack$$111","MapTreeModule$$$mkIterator","s$$5","MapTreeModule$002EmkIEnumerator$0027$00602","s$$6","MapTreeModule$$$mkIEnumerator","s$$7","call","MapTreeModule$002EmkIEnumerator$0027$00602$$$$002Ector$$Z26BC498C","MapTreeModule$$$toSeq","s$$8","en$$1","i$$2","MapTreeModule$$$alreadyFinished","MapTreeModule$$$notStarted","MapTreeModule$$$current","i$$3","MapTreeModule$$$moveNext","Reset","FSharpMap","comparer$$17","tree","FSharpMap$$$$002Ector$$58ADD115","FSharpMap$$get_Tree","__$$5","ofList","l$$22","comparer$$18","comparer$$13","l$$20","fold$$1","acc$$9","tupledArg","empty","comparer$$21","map$$2","kv","combineHash","x$$16","y$$3","res$$3","e$$1","activePatternResult3682","that","res$$4","finished","e1","e2","kvp1","kvp2","c$$10","_arg1$$1","k$$34","k$$29","$comparer$$1$$23","$k$$3$$24","$m$$4$$25","MapTreeModule$$$find","comparer$$1","m$$4","c$$3","__$$8","k$$35","k$$31","$comparer$$10$$59","$k$$12$$60","$m$$8$$61","MapTreeModule$$$mem","comparer$$10","k$$12","m$$8","c$$8","__$$21","kv$$1","k$$36","v$$26","kv$$2","MutableSet$00601","items","MutableSet$00601$$Add$$2B595","MutableSet$00601$$TryFindIndex$$2B595","MutableSet$00601$$Clear","MutableSet$00601$$get_Count","MutableSet$00601$$Contains$$2B595","MutableSet$00601$$Remove$$2B595","values$$1","value$$2","i$$8","item$$3","add_","x$$1","SetTree$00601","SetTreeModule$$$SetOne","SetTreeModule$$$SetNode","SetTreeModule$002ESetIterator$00601","SetTreeModule$$$collapseLHS","$stack$$104","SetTreeModule$$$mkIterator","s$$13","SetTreeModule$002EmkIEnumerator$00601","s$$14","SetTreeModule$$$mkIEnumerator","s$$15","SetTreeModule$002EmkIEnumerator$00601$$$$002Ector$$Z5B395D56","SetTreeModule$$$compare","s1","s2","$comparer$$17$$112","$l1$$113","$l2$$114","SetTreeModule$$$compareStacks","$target$$115","t1$$6","t2$$6","n1k","n2k","t1$$7","t2$$7","n1k$$1","n2k$$1","n2r","t1$$8","t2$$8","emp","n1k$$2","n1r","n2k$$2","t1$$9","t2$$9","n1k$$3","n1r$$1","n2k$$3","n2r$$1","t1$$10","t2$$10","n1k$$4","t1$$11","n1k$$5","n1l","n1r$$2","t1$$12","n2k$$4","t2$$11","n2k$$5","n2l","n2r$$2","t2$$12","l1","l2","c$$7","c$$9","SetTreeModule$$$alreadyFinished","SetTreeModule$$$notStarted","SetTreeModule$$$current","i$$1","SetTreeModule$$$moveNext","FSharpSet","comparer$$22","FSharpSet$$get_Comparer","__$$4","FSharpSet$$get_Tree","initialize","count$$8","initializer","cons$$15","result$$7","i$$13","source$$7","cons$$32","$f$$2$$19","$state$$1$$20","$xs$$8$$21","f$$2","state$$1","xs$$8","xs$$9","acc$$1","x$$6","f$$16","xs$$31","acc$$11","ofArray","xs$$50","res$$1","i$$9","col","map$$1","x$$21","that$$1","capacity","buf","tryParse","ok","Parsimmon","action","seed","arr","forEach","elem","isParser","isBuffer","Buffer","makeSuccess","index","status","furthest","expected","makeFailure","mergeReplies","last","hasOwnProperty","sort","union","makeLineColumnIndex","line","column","lines","split","assertParser","assertNumber","assertRegexp","RegExp","assertFunction","assertString","repeat","string","amount","leftPad","pad","char","rangeFromIndexAndOffsets","before","after","to","formatGot","error","lineWithErrorIndex","lineRange","lastLineNumberLabelLength","verticalMarkerLength","byteLineWithErrorIndex","columnByteIndex","byteRange","bytesPerLine","bytesAfter","bytesInChunks","chunkSize","chunks","chunkIndex","toChunks","data","byteLines","byteRow","byteValue","byteRangeToRange","byteLine","inputLines","lineWithErrorCurrentIndex","linesWithLineNumbers","lineSource","lineNumberLabel","isLineWithError","re","lastIndexOf","anchoredRegexp","source","parsers","arguments","numParsers","accum","seqMap","mapper","results","alt","sepBy1","parser","then","many","rs","regexp","group","anchored","exec","fullMatch","groupMatch","succeed","lookahead","predicate","skip","eof","err","type","or","alternative","trim","wrap","leftParser","rightParser","left","middle","thru","wrapper","tieWith","assertArray","tie","prevResult","atMost","atLeast","init","rest","fn","contramap","promap","g","mark","start","end","node","sepBy","notFollowedBy","text","desc","reply","fallback","ap","chain","of","digit","optWhitespace","cr","lf","newline","content","others","right","skipped","ps","f$$47","_arg1$$16","strings","escape","anyCharSnippet","otherParser","jint","arg0","jfloat","negJint","tuple","withWhitespace","jnull","jbool","jnumber","stringLiteral","jarray","comma","json","jobject","leftBrace","rightBrace","jvalue","BigNat","bound","BigNatModule$002EFFT$$$pow32","$x$$1","$n$$2","BigNatModule$$$bound","n$$10","BigNatModule$$$coeff","n$$12","i$$5","BigNatModule$$$coeff64","n$$13","i$$6","BigNatModule$$$setCoeff","n$$14","i$$7","v$$4","BigNatModule$$$pow64","$x$$23$$48","$n$$15$$49","x$$23","n$$15","BigNatModule$$$pow32","$x$$24$$50","$n$$16$$51","x$$24","n$$16","BigNatModule$002EFFT$$$maxTwoPower","Int32Array","BigNatModule$$$baseN","BigNatModule$$$baseNi64","BigNatModule$$$baseMaski64","BigNatModule$$$createN","b$$4","BigNatModule$$$normN","n$$18","bound$$1","$na$$62","$i$$9$$63","na","findLeastBound","BigNatModule$$$embed","x$$28","x$$29","r$$2","r$$3","BigNatModule$$$boundInt","BigNatModule$$$one","BigNatModule$$$zero","BigNatModule$$$degree","n$$24","BigNatModule$$$isZero","p$$4","BigNatModule$$$lt","p$$10","q$$7","q$$6","p$$9","$pa$$2$$108","$qa$$2$$109","$i$$24$$110","pa$$2","qa$$2","i$$24","check$$2","BigNatModule$$$mulSchoolBookCarry","$r$$12$$130","$c$$8$$131","$k$$4$$132","r$$12","rak$$1","BigNatModule$$$mulSchoolBookOneSmall","p$$16","q$$12","value$$3","bp","r$$13","q$$13","i$$28","rak$$2","BigNatModule$002Eencoding","bigL","twoToBigL","bigK","bigN","splits","BigNatModule$$$mkEncoding","bigK$$2","i$$30","BigNatModule$$$table","BigNatModule$$$mul","p$$20","q$$17","q$$15","pSmall","p$$18","qSmall","p$$15","q$$11","r$$11","rak","value$$1","p$$17","q$$14","value$$4","r$$14","i$$29","pai$$1","j$$1","qaj","rak$$3","BigNatModule$$$mulSchoolBookNeitherSmall","BigNatModule$$$scaleSubInPlace","x$$57","a$$5","n$$30","patternInput$$2","patternInput$$3","f$$1","j$$4","z$$7","zLo","value$$5","zHi","BigNatModule$$$scaleAddInPlace","x$$62","f$$3","a$$8","n$$32","patternInput$$4","patternInput$$5","f$$4","j$$5","z$$8","zLo$$1","value$$7","zHi$$1","BigNatModule$$$removeFactor","x$$67","a$$11","n$$34","f$$6","p$$8","pn","q$$5","patternInput$$6","f64","f64$$1","$pa$$1$$103","$qa$$1$$104","$i$$23$$105","pa$$1","qa$$1","i$$23","pai","qai","check$$1","BigNatModule$$$ofInt32","n$$41","BigNatModule$$$toString","n$$45","degn","kten2ks","$prior$$227","$k$$11$$228","$ten2k$$229","prior","k$$11","ten2k","route","digits$$4","isLeading","n$$46","patternInput$$13","b$$7","a$$12","x$$68","x$$27","array$$31","d$$6","p$$21","m$$2","n$$35","f$$7","BigNatModule$$$divmod","digits$$2","n$$47","n$$19","i$$12","BigNatModule$$$eval32","BigNatModule$$$getSmall","n$$49","i$$32","i$$33","i$$34","BigInteger","signInt","BigInteger$$$$002Ector$$Z2BE94A1","BigInteger$$$nat$$Z67CCE57D","n$$1","BigNatModule$0024$0024$0024getSmall","smallLim","smallPosTab","BigInteger$$get_SignInt","BigInteger$$get_V","x$$2","BigInteger$$$op_Equality$$56F059C0","x$$3","p$$7","q$$4","$pa$$96","$qa$$97","$i$$22$$98","pa","qa","i$$22","check","BigNatModule$0024$0024$0024isZero","BigInteger$$$$002Ector$$Z524259A4","n$$6","BigNatModule$0024$0024$0024ofInt32","x$$30","x$$31","r$$4","i$$11","BigNatModule$$$boundInt64","rem_u","rem_s","BigNatModule$$$embed64","BigInteger$$$get_One","BigInteger$$$get_Zero","zero","two","x$$7","BigNatModule$0024$0024$0024toString","n$$17","res$$2","BigNatModule$0024$0024$0024hash","obj$$1","x$$5","y$$2","BigNatModule$0024$0024$0024lt","BigInteger$$$op_LessThan$$56F059C0","n$$5","nn","BigInteger$0024$0024$0024get_Zero","BigInteger$0024$0024$0024get_One","MutableMap$002400602$0024$0024$0024$0024002Ector$0024$00246623D9B3","window","document","isDefined","CancellationToken","cancelled","_id","_cancelled","_listeners","listener","state","$","addListener","removeListener","OperationCanceledError","setPrototypeOf","protectedCont","ctx","cancelToken","isCancelled","onCancel","trampoline","incrementAndCheck","hijack","onError","computation","binder","onSuccess","ex","protectedBind","computation1","computation2","Bind","generator","sequence","body","While","Delay","protectedReturn","compensation","catchHandler","ex2","resource","TryFinally","guard","Return","list","emojis","mainnet","getLibrary","provider","network","web3treeAbi","formatTypes","full","PromiseBuilder","xValue","baseClass","classes","props","children","render","displayName","memoizeWith","withKey","__callingMemberName","__callingSourceFile","__callingSourceLine","valueFactory","elemType","memoElement","areEqual","GetOrAdd","web3","useWeb3React","modalControls","connectModalControlsContext","PageModal","_arg2","_arg3","_arg4","callback","callbackFunction","arg10","effect","initialValue","getDisposable","lastRenderCallbackRef","callbackRef","dispose","useLayoutEffectReact","disposable","elems","getElem","traitValues","prev","elemsWrapped","cons$$1","target$$1","delegateArg0","delegateArg1","classBaseList","setTimeout","Carousel","web3treeContract","ofFunc","xs$$12","collect$$1","acc$$3","x$$9","toKeyValuePair","segment","parseParams","querystring","comparer$$19","comparer$$16","ie","$comparer$$14$$97","$acc$$10$$98","$e$$99","comparer$$14","acc$$10","MapTreeModule$$$mkFromEnumerator","MapTreeModule$$$ofSeq","startIndex","dispatch","cmd","f$$24","unitVar0","cmds","lists","state$$3","xs$$14","acc$$4","x$$10","target","fill","__","ix","source$$6","wix'","truncate","wix","lastLocation","onChangeRef","location","href","addEventListener","subValue","visited","unvisited","( arg10@ )","gbl","model","nextProps","_nextState","view","pageRender","HomePage","assign","program","patternInput","rb","reentered","syncDispatch","clo1","nextMsg","rix'","runWith","lazyView2With","placeholderId","setState","lastRequest","withReactBatchedUsing","equal","urlUpdate","onLocationChange","mapUpdate","mapView","mapSetState","mapSubscribe","update","userUpdate","userView","userSetState","userSubscribe","userInit","unitVar1","toNavigableWith","url","parseHelp","states","segments","splitUrl","pathname","parsePath","subscribe","history","pushState","ev","dispatchEvent","Web3ReactProviderProps","txMsg","txProcessor","txResult","connectModalActive","processor","txmsg","er","reject","ConnectModal"],"sourceRoot":""}